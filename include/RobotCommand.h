// AUTOGENERATED. Run generator/main.py to regenerate
// Generated on June 05 2021, 02:43:53

#ifndef __ROBOT_COMMAND_H
#define __ROBOT_COMMAND_H

#include <stdbool.h>
#include <stdint.h>
#include "BaseTypes.h"

typedef struct _RobotCommandPayload {
	uint8_t payload[PACKET_SIZE_ROBOT_COMMAND];
} RobotCommandPayload;



/** ================================ PACKET ================================ 
[---0--] [---1--] [---2--] [---3--] [---4--] [---5--] [---6--] [---7--] [---8--] [---9--] [--10--]
11111111 -------- -------- -------- -------- -------- -------- -------- -------- -------- -------- header
-------- 1111---- -------- -------- -------- -------- -------- -------- -------- -------- -------- id
-------- ----1--- -------- -------- -------- -------- -------- -------- -------- -------- -------- doKick
-------- -----1-- -------- -------- -------- -------- -------- -------- -------- -------- -------- doChip
-------- ------1- -------- -------- -------- -------- -------- -------- -------- -------- -------- doForce
-------- -------1 -------- -------- -------- -------- -------- -------- -------- -------- -------- useCameraAngle
-------- -------- 11111111 11111111 -------- -------- -------- -------- -------- -------- -------- rho
-------- -------- -------- -------- 11111111 11111111 -------- -------- -------- -------- -------- theta
-------- -------- -------- -------- -------- -------- 11111111 11111111 -------- -------- -------- angle
-------- -------- -------- -------- -------- -------- -------- -------- 11111111 11111111 -------- cameraAngle
-------- -------- -------- -------- -------- -------- -------- -------- -------- -------- 111----- dribbler
-------- -------- -------- -------- -------- -------- -------- -------- -------- -------- ---111-- kickChipPower
-------- -------- -------- -------- -------- -------- -------- -------- -------- -------- ------1- angularControl
-------- -------- -------- -------- -------- -------- -------- -------- -------- -------- -------1 feedback
*/



/** ================================ STRUCT ================================ */
typedef struct _RobotCommand {
    uint8_t    header;                  // Header byte indicating the type of packet
    uint8_t    id;                      // Id of the robot
    bool       doKick;                  // Do a kick if ballsensor
    bool       doChip;                  // Do a chip if ballsensor
    bool       doForce;                 // Do regardless of ballsensor
    bool       useCameraAngle;          // Use the info in 'cameraAngle'
    float      rho;                     // Magnitude of movement (m/s)
    float      theta;                   // Direction of movement (radians)
    float      angle;                   // Absolute angle (rad) / angular velocity (rad/s)
    float      cameraAngle;             // Angle of the robot as seen by camera (rad)
    uint8_t    dribbler;                // Dribbler speed
    uint8_t    kickChipPower;           // Power of the kick or chip
    bool       angularControl;          // 0 = angular velocity, 1 = absolute angle
    bool       feedback;                // Ignore the packet. Just send feedback
} RobotCommand;



/** ================================ GETTERS ================================ */
static inline uint8_t RobotCommand_get_header(RobotCommandPayload *rcp){
    return ((rcp->payload[0]));
}
static inline uint8_t RobotCommand_get_id(RobotCommandPayload *rcp){
    return ((rcp->payload[1] & 0b11110000) >> 4);
}
static inline bool RobotCommand_get_doKick(RobotCommandPayload *rcp){
    return ((rcp->payload[1] & 0b00001000) > 0);
}
static inline bool RobotCommand_get_doChip(RobotCommandPayload *rcp){
    return ((rcp->payload[1] & 0b00000100) > 0);
}
static inline bool RobotCommand_get_doForce(RobotCommandPayload *rcp){
    return ((rcp->payload[1] & 0b00000010) > 0);
}
static inline bool RobotCommand_get_useCameraAngle(RobotCommandPayload *rcp){
    return ((rcp->payload[1] & 0b00000001) > 0);
}
static inline float RobotCommand_get_rho(RobotCommandPayload *rcp){
    uint16_t rho = ((rcp->payload[2]) << 8) | ((rcp->payload[3]));
    return (rho * 0.0001220703125000) + 0.0000000000000000;
}
static inline float RobotCommand_get_theta(RobotCommandPayload *rcp){
    uint16_t theta = ((rcp->payload[4]) << 8) | ((rcp->payload[5]));
    return (theta * 0.0000958737992429) + -3.1415926535897931;
}
static inline float RobotCommand_get_angle(RobotCommandPayload *rcp){
    uint16_t angle = ((rcp->payload[6]) << 8) | ((rcp->payload[7]));
    return (angle * 0.0000958737992429) + -3.1415926535897931;
}
static inline float RobotCommand_get_cameraAngle(RobotCommandPayload *rcp){
    uint16_t cameraAngle = ((rcp->payload[8]) << 8) | ((rcp->payload[9]));
    return (cameraAngle * 0.0000958737992429) + -3.1415926535897931;
}
static inline uint8_t RobotCommand_get_dribbler(RobotCommandPayload *rcp){
    return ((rcp->payload[10] & 0b11100000) >> 5);
}
static inline uint8_t RobotCommand_get_kickChipPower(RobotCommandPayload *rcp){
    return ((rcp->payload[10] & 0b00011100) >> 2);
}
static inline bool RobotCommand_get_angularControl(RobotCommandPayload *rcp){
    return ((rcp->payload[10] & 0b00000010) > 0);
}
static inline bool RobotCommand_get_feedback(RobotCommandPayload *rcp){
    return ((rcp->payload[10] & 0b00000001) > 0);
}



/** ================================ SETTERS ================================ */
static inline void RobotCommand_set_header(RobotCommandPayload *rcp, uint8_t header){
    rcp->payload[0] = header;
}
static inline void RobotCommand_set_id(RobotCommandPayload *rcp, uint8_t id){
    rcp->payload[1] = ((id << 4) & 0b11110000) | (rcp->payload[1] & 0b00001111);
}
static inline void RobotCommand_set_doKick(RobotCommandPayload *rcp, bool doKick){
    rcp->payload[1] = ((doKick << 3) & 0b00001000) | (rcp->payload[1] & 0b11110111);
}
static inline void RobotCommand_set_doChip(RobotCommandPayload *rcp, bool doChip){
    rcp->payload[1] = ((doChip << 2) & 0b00000100) | (rcp->payload[1] & 0b11111011);
}
static inline void RobotCommand_set_doForce(RobotCommandPayload *rcp, bool doForce){
    rcp->payload[1] = ((doForce << 1) & 0b00000010) | (rcp->payload[1] & 0b11111101);
}
static inline void RobotCommand_set_useCameraAngle(RobotCommandPayload *rcp, bool useCameraAngle){
    rcp->payload[1] = (useCameraAngle & 0b00000001) | (rcp->payload[1] & 0b11111110);
}
static inline void RobotCommand_set_rho(RobotCommandPayload *rcp, float _rho){
    uint16_t rho = (_rho - 0.0000000000000000) * 8192.0000000000000000;
    rcp->payload[2] = (rho >> 8);
    rcp->payload[3] = rho;
}
static inline void RobotCommand_set_theta(RobotCommandPayload *rcp, float _theta){
    uint16_t theta = (_theta - -3.1415926535897931) * 10430.3783504704533698;
    rcp->payload[4] = (theta >> 8);
    rcp->payload[5] = theta;
}
static inline void RobotCommand_set_angle(RobotCommandPayload *rcp, float _angle){
    uint16_t angle = (_angle - -3.1415926535897931) * 10430.3783504704533698;
    rcp->payload[6] = (angle >> 8);
    rcp->payload[7] = angle;
}
static inline void RobotCommand_set_cameraAngle(RobotCommandPayload *rcp, float _cameraAngle){
    uint16_t cameraAngle = (_cameraAngle - -3.1415926535897931) * 10430.3783504704533698;
    rcp->payload[8] = (cameraAngle >> 8);
    rcp->payload[9] = cameraAngle;
}
static inline void RobotCommand_set_dribbler(RobotCommandPayload *rcp, uint8_t dribbler){
    rcp->payload[10] = ((dribbler << 5) & 0b11100000) | (rcp->payload[10] & 0b00011111);
}
static inline void RobotCommand_set_kickChipPower(RobotCommandPayload *rcp, uint8_t kickChipPower){
    rcp->payload[10] = ((kickChipPower << 2) & 0b00011100) | (rcp->payload[10] & 0b11100011);
}
static inline void RobotCommand_set_angularControl(RobotCommandPayload *rcp, bool angularControl){
    rcp->payload[10] = ((angularControl << 1) & 0b00000010) | (rcp->payload[10] & 0b11111101);
}
static inline void RobotCommand_set_feedback(RobotCommandPayload *rcp, bool feedback){
    rcp->payload[10] = (feedback & 0b00000001) | (rcp->payload[10] & 0b11111110);
}



/** ================================ DECODE ================================ */
static inline void decodeRobotCommand(RobotCommand *rc, RobotCommandPayload *rcp){
	rc->header              = RobotCommand_get_header(rcp);
	rc->id                  = RobotCommand_get_id(rcp);
	rc->doKick              = RobotCommand_get_doKick(rcp);
	rc->doChip              = RobotCommand_get_doChip(rcp);
	rc->doForce             = RobotCommand_get_doForce(rcp);
	rc->useCameraAngle      = RobotCommand_get_useCameraAngle(rcp);
	rc->rho                 = RobotCommand_get_rho(rcp);
	rc->theta               = RobotCommand_get_theta(rcp);
	rc->angle               = RobotCommand_get_angle(rcp);
	rc->cameraAngle         = RobotCommand_get_cameraAngle(rcp);
	rc->dribbler            = RobotCommand_get_dribbler(rcp);
	rc->kickChipPower       = RobotCommand_get_kickChipPower(rcp);
	rc->angularControl      = RobotCommand_get_angularControl(rcp);
	rc->feedback            = RobotCommand_get_feedback(rcp);
}



/** ================================ ENCODE ================================ */
static inline void encodeRobotCommand(RobotCommandPayload *rcp, RobotCommand *rc){
	RobotCommand_set_header              (rcp, rc->header);
	RobotCommand_set_id                  (rcp, rc->id);
	RobotCommand_set_doKick              (rcp, rc->doKick);
	RobotCommand_set_doChip              (rcp, rc->doChip);
	RobotCommand_set_doForce             (rcp, rc->doForce);
	RobotCommand_set_useCameraAngle      (rcp, rc->useCameraAngle);
	RobotCommand_set_rho                 (rcp, rc->rho);
	RobotCommand_set_theta               (rcp, rc->theta);
	RobotCommand_set_angle               (rcp, rc->angle);
	RobotCommand_set_cameraAngle         (rcp, rc->cameraAngle);
	RobotCommand_set_dribbler            (rcp, rc->dribbler);
	RobotCommand_set_kickChipPower       (rcp, rc->kickChipPower);
	RobotCommand_set_angularControl      (rcp, rc->angularControl);
	RobotCommand_set_feedback            (rcp, rc->feedback);
}

#endif /*__ROBOT_COMMAND_H*/
