-- Neonode zForce Communication Protocol ASN.1 PDU definition
-- Protocol ASN.1 PDU Definition for Platform Version 7
-- Status: Draft
-- Definition version: 1.9
-- Last update: 2021-02-17
-- See end of document for changelog

ProtocolMessage DEFINITIONS IMPLICIT TAGS EXTENSIBILITY IMPLIED ::=
BEGIN

	-- General notes;
	-- items typed as INTEGER are unsigned, unless
	-- explicitly using the SignedInteger datatype

	-- -------------------------------------------- --
	-- Top level PDU								--
	-- -------------------------------------------- --

	-- Top level container of choice type, to be able to
	-- give implicit tag identifier. To replicate old protocol
	-- PRIVATE 14 generates id EE using DER encoding
	ProtocolMessage ::= CHOICE {
		request [PRIVATE 14] Message,
		response [PRIVATE 15] Message,
		notification [PRIVATE 16] Notification
	}

	-- General top level info:
	-- Request is sent from host to device, and is
	-- responded to with a response. The structure
	-- of both request and response are the same,
	-- the Message sequence.

	-- Notifications are reports from the platform
	-- to the host that are not explicitly requested.
	-- This contains startup information and touch
	-- notifications.

	-- -------------------------------------------- --
	-- Message - Input & Output						--
	-- -------------------------------------------- --

	-- Used for input and output to the system.
	-- In the request case the host device will send a
	-- top level Message with the request identifier and
	-- fill it out with operations to perform.

	-- The system will respond with response messages
	-- contained in a Message with the response identifier
	-- including requested data or operation results.

	-- General way of working:

	-- To perform a get request, make sure to send the
	-- message with an empty sequence for the data being
	-- requested

	-- To perform a set request, send the message with
	-- the sequence for the command filled with the
	-- appropriate parameters as payload

	-- All requests will get a response message with
	-- the sequences existing in the request message
	-- filled with their current values. If a set
	-- request was performed the returned value should
	-- be checked to verify the operation was successful

	-- The current communications layer handles a single
	-- command/sequence at a time. As such each setting
	-- should be sent in their own message.

	Message ::= SEQUENCE {
		deviceAddress DeviceAddress OPTIONAL,
		-- Used to address a specific device when multiple devices are in the same system.
		-- For request, the last value is kept so multiple requests to the same
		-- device only needs to include the deviceAddress in the first of the requests.

		-- Command/Message to start.
		-- Do all configuration before issuing.
		enable [APPLICATION 5] SEQUENCE {
			disable [0] NULL OPTIONAL,

			-- Send enable with value 0 to enable continuous mode.
			-- If any other value is given, scanning will stop
			-- after that number of frames of data has been sent.
			-- This is useful for diagnostics scans and robot measurements.
			enable [1] INTEGER (0..127) OPTIONAL,

			reset [2] NULL OPTIONAL
		} OPTIONAL,
		-- If enable is in a set request, e.g. populated with any member,
		-- no more commands should be included in the same message.


		-- Request for touch format descriptor. See TouchDescriptor
		--	in primitive data types section below for more info.
		touchFormat [APPLICATION 6] SEQUENCE { -- Read only, touchDescriptor will be ignored in request message
			touchDescriptor TouchDescriptor OPTIONAL
		} OPTIONAL,

		-- The various types of data that can be reported
		-- are controlled indepentenly by sending boolean
		-- values for them.
		operationMode [APPLICATION 7] SEQUENCE {	-- Initial state after power up
			detection [0] BOOLEAN OPTIONAL,			-- Enabled
			signals [1] BOOLEAN OPTIONAL,			-- Disabled
			ledLevels [2] BOOLEAN OPTIONAL,			-- Disabled
			detectionHid [3] BOOLEAN OPTIONAL,		-- Only for USB Equipped devices - Disabled
			gestures [4] BOOLEAN OPTIONAL			-- Only for gesture supporting devices - Enabled
		} OPTIONAL,

		-- Target frequency for different modes of operation
		frequency [APPLICATION 8] SEQUENCE {
			finger [0] INTEGER OPTIONAL,
			stylus [1] INTEGER OPTIONAL,
			idle [2] INTEGER OPTIONAL
		} OPTIONAL,

		-- Scaling factor for coordinates reported.
		-- Does not affect internal working resolution.
		resolution [APPLICATION 9] SEQUENCE {
			x [0] INTEGER OPTIONAL,
			y [1] INTEGER OPTIONAL,
			z [2] INTEGER OPTIONAL
		} OPTIONAL,

		-- Diagnostic method for reporting open or short LEDs/PDs.
		-- Always run on platform level, as such all ASICs independent of device will be reported.
		-- OpenShortInformation in constructed data types provides more info
		openShort [APPLICATION 10] SEQUENCE { -- Read only, openShortInfo will be ignored in request message
			openShortInfo [0] SEQUENCE OF OpenShortInformation OPTIONAL,	-- One result set for each ASIC
			errorCount [1] INTEGER (0..127) OPTIONAL	-- Total number of open and short errors encountered across
			-- all ASICs. Should always be 0 on a correctly assembled system.
			-- If larger than 127 the number is restricted to 127.
		} OPTIONAL,

		-- Static information about the platform or a device can be fetched by requesting deviceInformation
		deviceInformation [APPLICATION 12] SEQUENCE {-- Read only, all parameters will be ignored in request message

			-- Information returned when deviceInformation is addressed to the platform device
			platformInformation [0] SEQUENCE {
				platformVersionMajor	[0] INTEGER (0..32767) OPTIONAL,
				platformVersionMinor	[1] INTEGER (0..32767) OPTIONAL,
				protocolVersionMajor    [2] INTEGER (0..32767) OPTIONAL,
				protocolVersionMinor    [3] INTEGER (0..32767) OPTIONAL,
				firmwareVersionMajor	[4] INTEGER (0..32767) OPTIONAL,
				firmwareVersionMinor	[5] INTEGER (0..32767) OPTIONAL,
				hardwareIdentifier		[6] IA5String OPTIONAL,
				hardwareVersion			[7] IA5String OPTIONAL,
				asicType				[8] AsicType OPTIONAL,
				numberOfAsics			[9] INTEGER (0..127) OPTIONAL,
				mcuUniqueIdentifier		[10] OCTET STRING (SIZE(0..32)) OPTIONAL,
				-- MCU Serial or die and chip identifier when such is available
				projectReference  [11] IA5String OPTIONAL,
				platformReference [12] IA5String OPTIONAL,
				buildTime         [13] IA5String OPTIONAL,
				buildDate         [14] IA5String OPTIONAL
			} OPTIONAL,

			-- Information returned from other device instances. Please note that
			-- each instance, if more than one available according to deviceCount,
			-- may return different data, as they are configured independently.
			deviceInstanceInformation [1] SEQUENCE {					-- Device type restrictions
				productVersionMajor	[0] INTEGER (0..32767) OPTIONAL,
				productVersionMinor	[1] INTEGER (0..32767) OPTIONAL,
				physicalWidth		[2] INTEGER (0..32767) OPTIONAL,
				physicalHeight		[3] INTEGER (0..32767) OPTIONAL,	-- N/A for Air Devices
				numberOfSignalAxes	[4] INTEGER (0..32767) OPTIONAL,
				signalsPerSignalAxis [5] SEQUENCE OF [0] INTEGER OPTIONAL,
				-- Added in protocol 1.1
				ledsPerPhysicalAxis [6] SEQUENCE OF [0] INTEGER OPTIONAL,
				pdsPerPhysicalAxis [7] SEQUENCE OF [0] INTEGER OPTIONAL,
				ledPdPlacementPerPhysicalAxis [8] SEQUENCE OF [0] LedPdPlacement OPTIONAL
			} OPTIONAL,

			-- If device contains any readable or writable storage areas
			-- each such area will be presented with a StorageArea sequence
			storageInformation [2] SEQUENCE {
				storageAreas [0] SEQUENCE OF [0] StorageArea,

				-- Buffer size indicators, to indicate maximum payloads
				maxReadSize [1] INTEGER,
				maxWriteSize [2] INTEGER
			} OPTIONAL,

			-- Response type expected from devices of type lightingDevices
			-- Provides metadata about the type and amount of available lights
			lightingInformation [3] SEQUENCE {
				numberOfLeds [0] INTEGER OPTIONAL,
				bitsPerLedChannel [1] SEQUENCE OF [0] INTEGER OPTIONAL
				-- Regular LEDs will only give a single channel while
				-- RGB LEDs will give three integers, one for each color channel
				-- Simple on/off channels will only be a single bit while
				-- channels with controllable intensity will have multiple bits
			} OPTIONAL

		} OPTIONAL,

		-- To be able to enumerate the virtual devices a request for deviceCount gives
		-- the count of each type of device.
		deviceCount [APPLICATION 15] SEQUENCE {-- Read only, all parameters will be ignored in request message
			totalNumberOfDevices	[0] INTEGER (0..127) OPTIONAL,
			-- Total number of devices does not include the platform and
			-- will always equal the sum of the other members of the sequence.

			-- Devices of which there are none is not reported.
			coreDevices				[1] INTEGER (0..127) OPTIONAL,
			airDevices				[2] INTEGER (0..127) OPTIONAL,
			plusDevices				[3] INTEGER (0..127) OPTIONAL,
			lightingDevices			[4] INTEGER (0..127) OPTIONAL
		} OPTIONAL,

		status [APPLICATION 13] SEQUENCE { -- Read only, all parameters will be ignored in request message
			-- If you want to restrict the get request to a subset, include a empty sequence corresponding
			-- to the subset you want. If left entirely empty the full get response will be provided
			counters [0] SEQUENCE {
				currentContacts			[0] INTEGER (0..127) OPTIONAL,
				scanningCounter			[1] INTEGER (0..65535) OPTIONAL,
				preparedTouchCounter	[2] INTEGER (0..65535) OPTIONAL,
				sentTouchCounter		[3] INTEGER (0..65535) OPTIONAL,
				invalidTouchCounter		[4] INTEGER (0..65535) OPTIONAL
			} OPTIONAL
		} OPTIONAL,

		resultCode [APPLICATION 20] INTEGER {
			ok (0),
			fail (1)
		} OPTIONAL,

		-- Instance specific settings for a device
		deviceConfiguration [APPLICATION 19] SEQUENCE {
			-- Set / get the number of touches to be tracked:
			numberOfTrackedTouches	[0] INTEGER (0..255) OPTIONAL,
			-- Set / get the minimal distance for updating a tracked touch in move state
			trackingMinDistanceMove	[1] INTEGER (0..16383) OPTIONAL,
			-- Set / get the sub touch active area low bound in X coordinate
			subTouchActiveArea		[2] SEQUENCE {
				-- Write Request and Read Response only:
				-- Set / get the sub touch active area low bound in X coordinate
				lowBoundX		[0] INTEGER (0..16383) OPTIONAL,
				-- Set / get the sub touch active area low bound in Y coordinate
				lowBoundY		[1] INTEGER (0..16383) OPTIONAL,
				-- Set / get the sub touch active area high bound in X coordinate
				highBoundX	[2] INTEGER (0..16383) OPTIONAL,
				-- Set / get the sub touch active area high bound in Y coordinate
				highBoundY	[3] INTEGER (0..16383) OPTIONAL,
				-- subTaa Reverse X coordinates, set / get true or false
				reverseX		[4] BOOLEAN OPTIONAL,
				-- SubTaa Reverse Y coordinates, set / get true or false
				reverseY		[5] BOOLEAN OPTIONAL,
				-- Flip x and y axis, set / get true or false
				flipXY			[6] BOOLEAN OPTIONAL,
				-- Offset X coordinate
				offsetX			[7] INTEGER (0..32767) OPTIONAL,
				-- Offset Y coordinate
				offsetY			[8] INTEGER (0..32767) OPTIONAL
			} OPTIONAL,

			-- configure the reference signal setting
			referenceSignalConfig	[3] INTEGER (0..255) OPTIONAL,

			-- Restriction of detected objects based on their size
			sizeRestriction [4] SEQUENCE {
				maxSizeEnabled			[0] BOOLEAN OPTIONAL,
				maxSize					[1] INTEGER (0..32767) OPTIONAL,
				minSizeEnabled			[2] BOOLEAN OPTIONAL,
				minSize					[3] INTEGER (0..32767) OPTIONAL
			} OPTIONAL,

			-- Detection mode
			-- Is actually a set of flags, and should thus be a BIT STRING,
			-- but since it is an INTEGER, all combinations must be listed.
			-- Flags for Core:
			-- * finger: bit 0: Touch limit increased by 0 (No effect)
			-- * insensitiveFTIR: bit 6: Touch limit increased by 55
			-- Flags for Air:
			-- * mergeTouches: bit 5: Merge all touch objects into one
			-- * reflectiveEdge: bit 7: Improved functionality when we have reflective objects close to the active area
			detectionMode [5] INTEGER {
				none (0),
				-- Core only:
				finger (1),
				insensitiveFTIR (64),
				fingerAndInsensitiveFTIR (65),
				-- Air only:
				mergeTouches (32),
				reflectiveEdge (128),
				mergeTouchesAndReflectiveEdge (160)
			} OPTIONAL,

			-- Set / get the number of touches to be reported:
			numberOfReportedTouches	[6] INTEGER (0..255) OPTIONAL,

			-- Adapt active touch area to a HID display
			hidDisplaySize [7] SEQUENCE {
				x	[0] INTEGER (0..32767) OPTIONAL,
				y	[1] INTEGER (0..32767) OPTIONAL
			} OPTIONAL,

			-- Enable or disable floating protection, and set how long for it to react, in ms.
			-- Time is 0 to 3276 as the internal FW value is 1/10th of ms and a 16bit integer.
			floatingProtection [8] SEQUENCE {
				enabled	[0] BOOLEAN OPTIONAL,
				time [1] INTEGER (0..3276) OPTIONAL
			} OPTIONAL
		} OPTIONAL,

		-- Configurable options useful for retrieving diagnostic information
		diagnosticsSettings [APPLICATION 21] SEQUENCE {

			-- If fixedStrength is set, the next scan uses the
			-- set strength for all LEDs. The value is cleared upon receiving
			-- a disable command, or the fixed number of scans are done.
			fixedStrength [0] INTEGER (0..255) OPTIONAL,

			-- If forceCalibration is set to anything other than 0
			-- the device will recalibrate itself next time it is
			-- enabled. As a recalibration of led levels is needed
			-- when the ASIC gain is calibrated, this is included
			-- in the same settings level.
			-- Not cleared on disable/end of fixed number scan,
			-- so make sure to set to noCalibration when done.
			-- Ignored if fixedStrength is set at the same time.
			forceCalibration [1] INTEGER {
				noCalibration (0),
				calibrateLedLevels (1),
				calibrateLedLevelsWithHighestASICGain (2)
			} OPTIONAL,

			-- To enable filtering or normalization of raw signals
			-- reported, enable it here.
			rawSignalFiltering [2] INTEGER {
				disabled (0),
				enabled (1)
			} OPTIONAL,

			-- For systems with calibration data the storage area currently
			-- being used is indicated and set by altering the following parameter.
			calibrationStorageAreaInUse [3] StorageIdentifier OPTIONAL,

			-- Sends Air maximum filter result.
			signalMaximum [4] BOOLEAN OPTIONAL

		} OPTIONAL,

		-- Storage operations, available for storage devices
		-- Only one type of operation can be performed per request
		storageOperation [APPLICATION 25] SEQUENCE {
			storageIdentifier [0] StorageIdentifier,

			operationType [1] INTEGER {
				read (0),
				write (1),
				delete (2)
			},

			-- Offset into the storage area.
			-- Offset + size should never exceed the size of the storage area
			offset [2] INTEGER,
			size [3] INTEGER,

			-- Payload should only be populated in the request
			-- when doing a write operation. It will only be
			-- populated in a response after a read operation
			payload [4] OCTET STRING OPTIONAL,

			-- Operation status code should never be
			-- included in requests, only returned in responses.
			-- This indicates the status
			operationStatusCode [5] INTEGER {
				success (0),
				genericError (1), -- For errors without specific status code
				outOfBounds (2), -- Read or write outside of storage area
				mediaNotPresent (3), -- For removable media
				identifierError (4), -- Storage with identifier does not exist.
				bufferOverflow (5), -- Storage read or write buffer not big enough for request.
				writeProtected (6), -- Storage is write protected, maybe ROM type.
				deleteNotApplicable (7) -- Delete attempted on media where operation not available
			} OPTIONAL

		} OPTIONAL,
		signalsLayout [APPLICATION 18] Vector OPTIONAL,

		-- For altering state of RGB LEDs on a device
		-- It is write only, and will only generate an empty sequence
		-- as a response to keep bandwidth usage low.
        lighting [APPLICATION 26] SEQUENCE {
            presenceBitMask [0] BIT STRING OPTIONAL,
            -- To avoid having to send state for all LEDs every
            -- time, this bitmask signifies the LEDs for which
            -- the state is to be changed. To set a LED to a
            -- specific color make sure to include it in the bitMask
            -- and send the color values in the right position of the
            -- state OCTET STRING

            state [1] OCTET STRING OPTIONAL,
            -- State data for the LEDs to be set.
            -- presenceBitMask indicates in rising order
            -- what LEDs' states are included in the payload.

            -- Expected format of each state is according to the
            -- number of bits per channel in the deviceInformation,
            -- where each channel is 0-padded to be evenly aligned
            -- on byte boundaries.

            -- The size of the entire state payload should be a
            -- multiple of the total state size per LED.
            -- The maximum size will be the number of bits enabled in
            -- precenceBitMask * total size per LED.
            -- If state contains a smaller payload than maximum the
            -- last state information is repeated for all successive LEDs
            -- As such, to set all LEDs to the same state only a single state
            -- payload is required while setting all bits enabled in the
            -- presenceBitMask

            -- Some examples:
            -- Type    - Bits per channel   - Size per LED state
            -- On/Off  - 1                  - 1 byte
            -- Single  - 8                  - 1 byte
            -- RGB LED - 8, 8, 8            - 3 byte

            globalIntensity [2] INTEGER (0..65535) OPTIONAL
            -- Allows you to control the intensity level for all
            -- LEDs at the same time.

        } OPTIONAL,

		-- Low signal information.
		-- Get the comparing results between all signals to a minimal
		-- signal alert level.
		lowSignal [APPLICATION 28] SEQUENCE {
			-- Bit mask stating which signals having low signal error.
			lowSignalInfo [0] BIT STRING OPTIONAL
		} OPTIONAL,

		-- For systems where error counters are available,
		-- they can be cleared by sending a NULL value
		errorCounterClear [APPLICATION 31] NULL OPTIONAL,

		-- Error Information.
		-- Only Platform responds to this.
		errorInformation [APPLICATION 32] ErrorInformation OPTIONAL,

		-- Ask device to stream the Error Log for either a specific session,
		-- the current session (specify -1 as value) or all sessions (-2).
		-- The Error Log is streamed using ErrorLog entries.
		-- See the "errorLog" entry in StatusNotification for the Notification sent.
		-- Only Platform responds to this.
		errorLog [APPLICATION 33] INTEGER {
			currentSession (-1),
			allSessions (-2)
		} OPTIONAL,

		-- Get or Set Error Thresholds.
		errorThresholds [APPLICATION 34] ErrorThresholds OPTIONAL,

		-- Get or Set Touch Mode.
		touchMode [APPLICATION 36] TouchMode OPTIONAL
	}

	-- -------------------------------------------- --
	-- Notifications - Touch data					--
	-- -------------------------------------------- --

	Notification ::= SEQUENCE {
		deviceAddress DeviceAddress OPTIONAL,
		-- Present when more than one device is available in system.
		-- Indicates the source of the notification message.

		notificationMessage CHOICE {
			singleTouch TouchNotification,
			-- This will be used in cases where only single touch is available.

			touchNotifications [0] SEQUENCE (SIZE(0..127)) OF TouchNotification,
			-- In cases where multi touch of 2 or more touches will be available
			-- this sequence will be used.

			-- The payload, sizes and offsets for each TouchNotification
			-- is described by the TouchDescriptor bit string

			bootCompleteNotification BootCompleteNotification,
			-- BootCompleteNotification is sent upon system start,
			-- see definition of BootCompleteNotification further down
			-- to see what flags and states are reported

			ledLevels [APPLICATION 11] RawData,
			coreSignals  [APPLICATION 14] RawData,
			airSignals  [APPLICATION 17] Vector,
			airMaximum  [1] Vector,
			statusNotification StatusNotification,
			gestureNotifications [2] SEQUENCE (SIZE(0..127)) OF GestureNotification
		},

		notificationTimestamp Timestamp OPTIONAL,
		-- For notifications which have use of temporal data
		-- the notification contains a timestamp

		notificationLatency Latency OPTIONAL
		-- For notifications which have use of temporal data
		-- the notification contains a processing latency value.
		-- Currently this is only used for TouchNotification.
		-- For touchNotification, the latency time starts from the
		-- beginning of the first frame after a touch object
		-- presented in active area, and ends at the current touch
		-- notification encoded.
	}

	-- -------------------------------------------- --
	-- Primitive Data Types							--
	-- -------------------------------------------- --

	DeviceAddress ::= [APPLICATION 0] OCTET STRING (SIZE (2))
	-- Addressing information used when multiple touch devices are present
	-- in the system.
	-- Byte0 - deviceType, Byte1 - deviceIndex
	-- DeviceTypes:	0x00	-	Platform
	--				0x01	-	zForce Core
	--				0x02	-	zForce Air
	--				0x03	-	zForce Plus
	--				0x04	-	Lighting devices

	TouchDescriptor ::= [APPLICATION 1] BIT STRING
	{
	-- Bitmask descriptor outlining the payload each
	-- TouchNotification contains.
	-- Name (bit)			-  Description		- size		- comment
		id (0),				-- Touch Identifier	- 1 byte
		event (1),			-- Up/Down/Move		- 1 byte	- 0=Down; 1=Move; 2=Up; 3=Invalid; 4=Ghost
		loc-x-byte1 (2),	-- X coordinate		- 1 byte
		loc-x-byte2 (3),	-- X expanded		- 1 byte	- for higher precision
		loc-x-byte3 (4),	-- X expanded		- 1 byte	- for higher precision
		loc-y-byte1 (5),	-- Y coordinate		- 1 byte
		loc-y-byte2 (6),	-- Y expanded		- 1 byte	- for higher precision
		loc-y-byte3 (7),	-- Y expanded		- 1 byte	- for higher precision
		loc-z-byte1 (8),	-- Z coordinate		- 1 byte
		loc-z-byte2 (9),	-- Z expanded		- 1 byte	- for higher precision
		loc-z-byte3 (10),	-- Z expanded		- 1 byte	- for higher precision
		size-x-byte1 (11),	-- X size			- 1 byte
		size-x-byte2 (12),	-- X size			- 1 byte	- for higher precision
		size-x-byte3 (13),	-- X size			- 1 byte	- for higher precision
		size-y-byte1 (14),	-- Y size			- 1 byte
		size-y-byte2 (15),	-- Y size			- 1 byte	- for higher precision
		size-y-byte3 (16),	-- Y size			- 1 byte	- for higher precision
		size-z-byte1 (17),	-- Z size			- 1 byte
		size-z-byte2 (18),	-- Z size			- 1 byte	- for higher precision
		size-z-byte3 (19),	-- Z size			- 1 byte	- for higher precision
		orientation (20),	-- Orientation		- 1 byte	- Hand orientation
		confidence (21),	-- Confidence		- 1 byte
		pressure (22)		-- Pressure			- 1 byte
	}
	-- Total maximum size:    23 bytes per touch

	TouchNotification ::= [APPLICATION 2] OCTET STRING
	-- Binary payload with content as outlined by TouchDescriptor

	Timestamp ::= [APPLICATION 24] INTEGER
	-- Timestamps for general use. Runs at 32768 +-5% Hz.

	Latency ::= [APPLICATION 35] INTEGER
	-- Latency value for measurement use. Payload value is in millisecond unit.

	-- List of known ASIC types
	AsicType ::= INTEGER {
		nn1001 (1),
		nn1002 (2),
		nn1003 (3)
	}

	-- Addressing method for storage areas
	StorageIdentifier ::= INTEGER (0..127)

	-- Explicit notification for integers that
	-- contains signed values
	SignedInteger ::= INTEGER

	-- LED and PD placement types
	LedPdPlacement ::= INTEGER {
		pdFirstPdLast (0),
		pdFirstLedLast (1),
		ledFirstPdLast (2),
		ledFirstLedLast (3)
	}

	-- -------------------------------------------- --
	-- Constructed Data Types						--
	-- -------------------------------------------- --

	GestureNotification ::= [APPLICATION 4] SEQUENCE {
		gestureStatus [0] INTEGER {
			detection (0),	-- New gesture detected
			update (1),		-- Update of previously detected gesture
			stop (2)		-- Final update for previously detected gesture
		},

		-- Unique identifier for the gesture notification.
		-- If status is detection the first unoccupied ID is used,
		-- otherwise the ID is related to a previously detected gesture.
		gestureIdentifier [1] INTEGER OPTIONAL,

		gestureType [2] INTEGER {
--			Type				Continuous/Single Shot	Generic/Specific case	iOS Equivalent			Android equivalent
			tap (0),		--	Single Shot				Generic					UITapGesture			onDown / onSingleTapUp / onDoubleTap (GestureDetector)
			longPress (1),	--	Continuous				Generic					UILongPressGesture		onLongPress (GestureDetector)
			swipe (2),		--	Continuous				Generic					UISwipeGesture			onFling (GestureDetector)
			pan (3),		--	Continuous				Generic					UIPanGesture			onScroll (GestureDetector)
			pinch (4),		--	Continuous				Generic					UIPinchGesture			onScale (ScaleGestureDetector)
			rotation (5),	--	Continuous				Generic					UIRotationGesture		Not available
			grab (6),		--	Continuous				Steering Wheel specific	N/A						N/A
			rimTap (7)		--	Single Shot				Steering Wheel specific	N/A						N/A
		},

		originX [3] INTEGER OPTIONAL,
		originY [4] INTEGER OPTIONAL,

		sizeX [5] INTEGER OPTIONAL,
		sizeY [6] INTEGER OPTIONAL,

		deltaX [7] SignedInteger OPTIONAL,
		deltaY [8] SignedInteger OPTIONAL
	}

	-- Startup notification, indicating reset causes, proper ASIC
	-- function and global state before reset, in case of watchdog reset
	BootCompleteNotification ::= [APPLICATION 3] SEQUENCE {
		asicStatus [0] INTEGER
		{
			asicExists (0),
			asicNotFound (1)
		},
		resetSource [1] BIT STRING
		{
			powerUp (0),
			rstLow (1),
			watchdogExpired (2),
			flashViolation (3),
			nonMaskableInterrupt (4)
		},
		globalState [2] BIT STRING
		{
			asicFlaggedMemOverFlow (0),
			asicFlaggedVBGFault (1),
			asicFlaggedTSDFault (2),
			asicFlaggedUnexpectedPOR (3),
			watchDogExpiredUnhandledIRQ (4),
			watchDogExpiredWaitingForSPIRXComm (5),
			watchDogExpiredWaitingForSPITXComm (6),
			watchDogExpiredWaitingForASICIRQ (7)
		}
	}

	RawData ::= SEQUENCE OF VariableSizeIntegerString

	VariableSizeIntegerString ::= CHOICE
	{
		uint8 [0] OCTET STRING,
		uint12 [1] OCTET STRING,
		uint16 [2] OCTET STRING
	}

	-- A sequence containing the results for all LEDs and PDs
	-- of an Open Short test on an ASIC
	OpenShortInformation ::= [APPLICATION 23] SEQUENCE {
		asicIndex [0] INTEGER OPTIONAL,	-- Which ASIC the results belong to.
		ledOpen [1] BIT STRING,		-- Bit mask stating which LEDs indicate a open fault
		ledShort [2] BIT STRING,	-- Bit mask stating which LEDs indicate a short fault
		pdOpen [3] BIT STRING OPTIONAL,		-- Bit mask stating which PDs indicate a open fault
		-- NN1001 does not support PD open checks, so this may be omitted
		pdShort [4] BIT STRING		-- Bit mask stating which PDs indicate a short fault
	}

	-- For devices providing reading and writing of data to volatile or non-volatile
	-- memory, each available area that can be addressed will be described using a
	-- StorageArea sequence for each area.
	StorageArea ::= SEQUENCE {
		storageIdentifier [0] StorageIdentifier,
		-- Integer index required to pinpoint the specific storage area, to allow
		-- for multiple storage areas associated with the same device.
		storageDescription [1] IA5String (SIZE(0..32)) OPTIONAL,
		-- Description about the intended usage for this storage,
		-- e.g. Calibration, Configuration etc.
		storageType [2] INTEGER {
			rom (0),
			flash (1),
			eeprom (2),
			ram (3),
			asicRegister (4),
			asicSram (5)
		} OPTIONAL,
		storageLocation [3] INTEGER {
			internal (0), -- e.g. MCU flash memory
			external (1), -- e.g. external flash chip
			removable (2) -- e.g. SD card
		} OPTIONAL,
		storageSize [4] INTEGER
		-- Total size of the storage area.
		-- Adressable space will always be 0 <= address < storageSize

--		deleteLevel [5] INTEGER {
--			byteLevel (0),
--			blockLevel (1)
--		} OPTIONAL,
		-- If deletions for this storage area is done on
		-- block level, with lesser granularity than a byte
		-- it is indicated by deleteLevel

--		blockSize [6] INTEGER OPTIONAL,
		-- If deleteLevel is indeed an block level operation
		-- the block size is necessary to know starting addresses
		-- and block sizes of affected data.

	}

	Vector ::= SEQUENCE {
		dataType [0] ENUMERATED {
			uint8 (0),
			int8 (1),
			uint12 (2),
			int12 (3),
			uint16 (4),
			int16 (5),
			uint24 (6),
			int24 (7),
			uint32 (8),
			int32 (9),
			uint64 (10),
			int64 (11),
			float (12),
			double (13)
		} OPTIONAL,
		shape [1] SEQUENCE OF [0] INTEGER OPTIONAL,
		-- data format:
		-- Row major order (C)
		-- Big endian. When LSB is a partial octet, it is in the most significant bits
		-- no padding
		data [2] OCTET STRING OPTIONAL
	}

	StatusNotification ::= [APPLICATION 27] SEQUENCE {
		-- Hardware Error detected. This only signals that it has occured, not what it is.
		-- That is read seperately.
		hardwareError [0] NULL OPTIONAL,

		-- True if the device is receiving touches on a single axis. This can be due to
		-- for example a user touching the outside of the light guide, thereby changing
		-- the reflectiveness of the mirror.
		-- False if it is no longer detected.
		singleAxisTouchError [1] BOOLEAN OPTIONAL,

		-- True if touches are no longer detected and sent.
		-- False if touches are now sent normally.
		touchesIgnored [2] BOOLEAN OPTIONAL,

		-- True if any signal is lower than predefined minimum level.
		-- False if all the signals are back to normal level.
		lowSignalError [3] BOOLEAN OPTIONAL,

		-- Hardware Error Detected. This also contains specifics about the error.
		-- Replaces hardwareError above.
		error [4] ErrorNotification OPTIONAL,

		-- Error Log Transfer.
		errorLog [5] ErrorLog OPTIONAL
	}

	ErrorInformation ::= SEQUENCE {
		systemTests [0] SystemErrorInformation OPTIONAL,
		asics [1] SEQUENCE OF [0] AsicInformation OPTIONAL,
		visibleLedDrivers [2] SEQUENCE OF [0] VisibleLedDriverInformation OPTIONAL
	}

	SystemErrorInformation ::= SEQUENCE {
		cpu [0] ErrorFlags OPTIONAL,					-- CPU Error Detected.
		internalWatchdog [1] ErrorFlags OPTIONAL,		-- Internal Watchdog
		flashProgramChecksum [2] ErrorFlags OPTIONAL,	-- Flash Program Checksum
		ram [3] ErrorFlags OPTIONAL,					-- RAM
		pll [4] ErrorFlags OPTIONAL,					-- Phase Locked Loop
		startupTestChecksum2 [5] ErrorFlags OPTIONAL,	-- Startup Test Checksum 2
		lsi [6] ErrorFlags OPTIONAL,					-- Low Speed Internal Clock
		hse [7] ErrorFlags OPTIONAL,					-- High Speed External Clock
		hseSwitch [8] ErrorFlags OPTIONAL,				-- High Speed External Clock Switch
		externalClockSource [9] ErrorFlags OPTIONAL,	-- External Clock Source
		abnormalTermination [10] ErrorFlags OPTIONAL,	-- Abnormal Termination of Clock Test
		testFlowCheckpoint1 [11] ErrorFlags OPTIONAL,	-- Test Flow Checkpoint 1
		testFlowCheckpoint2 [12] ErrorFlags OPTIONAL,	-- Test Flow Checkpoint 2
		nvmLogFull [13] ErrorFlags OPTIONAL,			-- NVM Log Full
		nvmFlashCorrupt [14] ErrorFlags OPTIONAL,		-- NVM Log Flash Corrupt
		stackOverflow [15] ErrorFlags OPTIONAL,			-- Stack Overflow
		hardFault [16] ErrorFlags OPTIONAL,				-- Hard Fault
		logicError [17] ErrorFlags OPTIONAL,			-- Software triggered logic errors. assert() in the firmware.
		asicSyncSwitch [18] ErrorFlags OPTIONAL			-- ASIC sync switch test failed
	}

	ErrorFlags ::= BIT STRING {
		applicable (0),		-- Test has been run.
		qualified (1) 		-- Error is qualified.
	}

	AsicInformation ::= SEQUENCE {
		index [0] INTEGER OPTIONAL,
		irLeds [1] DiodeComponentInformation OPTIONAL,
		irPds [2] DiodeComponentInformation OPTIONAL,
		offline [3] ErrorFlags OPTIONAL,					-- ASIC Offline.
		timeout [4] ErrorFlags OPTIONAL,					-- ASIC Timeout.
		overTemperatureExternalSensor [5] ErrorFlags OPTIONAL,	-- External Temperature Sensor Overtemperature.
		porFault [6] ErrorFlags OPTIONAL,					-- POR Fault.
		analogOrVbgFault [7] ErrorFlags OPTIONAL,			-- Analogue circuits reporting Vref drop or VBG Fault.
		memoryOverflow [8] ErrorFlags OPTIONAL,				-- Memory Overflow, Storage memory full.
		internalThermalShutdown [9] ErrorFlags OPTIONAL,	-- Internal sensor tripped Thermal Shutdown.
		proxResultOverflow [10] ErrorFlags OPTIONAL			-- PROX instruction result out of range.
	}

	VisibleLedDriverInformation ::= SEQUENCE {
		index [0] INTEGER OPTIONAL,
		visibleLeds [1] DiodeComponentInformation OPTIONAL,
		offline [2] ErrorFlags OPTIONAL
	}

	DiodeComponentInformation ::= SEQUENCE {
		componentOpen [0] BIT STRING OPTIONAL,
		componentOpenApplicable [1] BIT STRING OPTIONAL,
		componentShort [2] BIT STRING OPTIONAL,
		componentShortApplicable [3] BIT STRING OPTIONAL
	}

	ErrorLog ::= SEQUENCE {
		sessionIdentifier [0] INTEGER OPTIONAL,
		timestamp [1] Timestamp OPTIONAL,
		isLastEntry [2] NULL OPTIONAL,
		errorEntry [3] ErrorEntry OPTIONAL,
		resetCause [4] INTEGER {
			hard (0),					-- Reset pin
			soft (1),					-- Software reset
			internalWatchdog (2),		-- Internal Watchdog
			brownOut (3)				-- Power loss
		} OPTIONAL
	}

	ErrorNotification ::= SEQUENCE {
		errorEntry [0] ErrorEntry OPTIONAL
	}

	-- Can either be none or one.
	ErrorEntry ::= CHOICE {
		systemTest [0] SystemErrorInformation,
		asic [1] AsicErrorEntry,
		visibleLedDriver [2] VisibleLedDriverErrorEntry
	}

	-- For a desciption of error types, check AsicInformation above.
	AsicErrorEntry ::= SEQUENCE {
		index [0] INTEGER OPTIONAL,
		irLedIndex [1] INTEGER OPTIONAL,
		irPdIndex [2] INTEGER OPTIONAL,
		open [3] BOOLEAN OPTIONAL,
		short [4] BOOLEAN OPTIONAL,
		offline [5] BOOLEAN OPTIONAL,
		timeout [6] BOOLEAN OPTIONAL,
		overTemperatureExternalSensor [7] BOOLEAN OPTIONAL,
		porFault [8] BOOLEAN OPTIONAL,
		analogOrVbgFault [9] BOOLEAN OPTIONAL,
		memoryOverflow [10] BOOLEAN OPTIONAL,
		internalThermalShutdown [11] BOOLEAN OPTIONAL,
		proxResultOverflow [12] BOOLEAN OPTIONAL
	}

	VisibleLedDriverErrorEntry ::= SEQUENCE {
		index [0] INTEGER OPTIONAL,
		ledChannelIndex [1] INTEGER OPTIONAL,
		open [2] BOOLEAN OPTIONAL,
		short [3] BOOLEAN OPTIONAL,
		offline [4] BOOLEAN OPTIONAL
	}

	-- Exposes system Error Thresholds. Structures based on (and used together with)
	-- ErrorInformation.
	ErrorThresholds ::= SEQUENCE {
		asicsThresholds [0] SEQUENCE OF [0] AsicThresholds OPTIONAL,
		visibleLedDriversThresholds [1] SEQUENCE OF [0] VisibleLedDriverThresholds OPTIONAL
	}

	AsicThresholds ::= SEQUENCE {
		asicIdentifier [0] INTEGER OPTIONAL,
		irLedOpenThresholds [1] Thresholds OPTIONAL,
		irLedShortThresholds [2] Thresholds OPTIONAL,
		irPdOpenThresholds [3] Thresholds OPTIONAL,
		irPdShortThresholds [4] Thresholds OPTIONAL
	}

	VisibleLedDriverThresholds ::= SEQUENCE {
		visibleLedDriverIdentifier [0] INTEGER OPTIONAL,
		visibleLedOpenThresholds [1] Thresholds OPTIONAL,
		visibleLedShortThresholds [2] Thresholds OPTIONAL
	}

	Thresholds ::= SEQUENCE {
		low [0] INTEGER OPTIONAL,
		high [1] INTEGER OPTIONAL
	}

	TouchMode ::= SEQUENCE {
		currentTouchMode [0] ENUMERATED {
			-- Normal mode where Down is Down, Move is Move (Or Down depending on protocol), Up is Up.
			normal (0),
			-- Click on Touch, where the down is sent immediately, but the Up is sent earlier, depending on sub-mode.
			-- Modes are: Instant or using time and radius. If clickOnTouchTime is 0, Instant is enabled, otherwise it will use time and radius.
			clickOnTouch (1)
		} OPTIONAL,
		-- In Click on Touch mode, how long to wait for the object to pass outside the specified radius before we send the Up.
		-- Units are milliseconds.
		clickOnTouchTime [1] INTEGER OPTIONAL,
		-- In Click on Touch mode, how far we have to move for the mode (for a particular touch) to change from click on touch to normal mode.
		-- Units are 1/10th of mm.
		clickOnTouchRadius [2] INTEGER OPTIONAL
	}

END

/*
  _____ _                            _
 / ____| |                          | |
| |    | |__   __ _ _ __   __ _  ___| |     ___   __ _
| |    | '_ \ / _` | '_ \ / _` |/ _ \ |    / _ \ / _` |
| |____| | | | (_| | | | | (_| |  __/ |___| (_) | (_| |
 \_____|_| |_|\__,_|_| |_|\__, |\___|______\___/ \__, |
                           __/ |                  __/ |
                          |___/                  |___/
----------------------------------------------------------------------
2021-02-17 - Protocol version 1.9
* Add Floating Protection enabled and time.

2020-10-27 - Protocol version 1.8
* Add Click on Touch.
* Add comment to specify that timestamp runs at 32768Hz.

2020-05-04 - Protocol version 1.7
* Reversed globalState flag order, in order to match faulty behavior of
  current implementation.

2018-04-10 - Protocol version 1.6
* Add possibility to enable or disable reflectiveEdgeFilter

2017-09-13 - Protocol version 1.5
* Add NN1003 to list of ASIC Types
* Add asicSram as storageType to easily discern NN1002 and NN1003 specific
  storage areas.
* Add gestures as operationMode parameter, to control transmission of
  gesture data.
* Make LedPdPlacement into its own datatype, instead of inline definition.
* Add offset, flipXY and hidDisplaySize to deviceConfiguration
* Extended touch size restriction range (0-255 -> 0-32767)

2016-04-26 - Protocol version 1.4
* Protocol cleanup and simplification by use of EXTENSIBILITY IMPLIED
* To avoid conflict due to EXTENSIBILITY IMPLIED the sub CHOICE for
  touch in notificationMessage has been eliminated.
* Add detectionMode to deviceConfiguration
* Add optional BuildInfo to platformInformation
* Command for clearing error counters added.
* Add delta values for gesture notifications.
* Add ErrorInformation, ErrorLog and ErrorNotification.
* Add ErrorThreshold getting/setting.
* Add Latency datatype and add notificationLatency to Notification

2016-03-02 - Protocol version 1.3
* Protocol added for gesture features.
* Add a StatusNotification message.
* Add HardwareError status notification.
* Add SingleAxisTouchError status notification for when someone
  touches the outside of a lightguide and it affects touches.
* Add TouchesIgnored status notification for when the unit will not
  be providing touches.
* Add lowSignalError to StatusNotification.
* Add new lowSignal message.
* Make Vector members optional.

2016-01-19 - Protocol version 1.2
* Add support for visual LED feedback from RGB LEDs.
* Add ASIC registers as storage type
* Added optional MCU serial number to platformInformation
* Add more complex singal data definition used when the standard
  matrix is not the best way. This consists of the new signalsLayout
  request and the airSignals notification.
* Add support for reporting maximum signal map.

2015-11-26 - Protocol version 1.1
* Renamed numberOfAxes and signalsPerAxis to numberOfSignalAxes and
  signalsPerSignalAxis to discern between physical and data related axes.
* Add LED and PD configuration info to deviceInstanceInformation.
* Added support for generic data storage
* Added indicator for used calibration storage area to diagnosticSettings
* Add MemOverFlow error to global state flags of BootComplete

2015-10-20 - Protocol version 1.0
* Initial release and feature freeze of protocol.
* Full support for Core Devices on platform v7.

*/
