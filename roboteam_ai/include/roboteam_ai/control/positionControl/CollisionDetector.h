//
// Created by martin on 11-5-22.
//

#pragma once

#include <optional>
#include <span>
#include <vector>

#include "PositionControlUtils.h"
#include "StateVector.h"
#include "control/positionControl/BBTrajectories/BBTrajectory2D.h"
#include "utilities/Constants.h"
#include "world/FieldComputations.h"

namespace rtt::ai::control {

struct Obstacles {
    StateVector ball;
    std::vector<StateVector> robotsThem;
    std::unordered_map<int, StateVector> robotsUs;
};


class CollisionDetector {

   private:
    using RobotView = rtt::world::view::RobotView;
    using BallView = rtt::world::view::BallView;

    Polygon ourDefenseArea = Polygon{Vector2{}, 0, 0};
    Polygon theirDefenseArea = Polygon{Vector2{}, 0, 0};

    double minBallDistance = 0.0;
    std::array<Obstacles, PositionControlUtils::COLLISION_DETECTOR_STEP_COUNT> timeline;
//    std::optional<rtt::Field> field;

    /**
     * @brief Consolidation of collision detection logic.
     * @tparam pathPoint PathPoint to check for collisions.
     * @param obstaclePos Obstacle to check against.
     * @param minDistance Minimum distance between origin and obstacle.
     * */
    [[nodiscard]] static bool isCollision(const Vector2& position, const Vector2& obstaclePos, double minDistance);
   public:
    CollisionDetector() = default;

    /**
     * @brief Finds the first (time-wise) collision with dynamic obstacles(ball and robots) on the path
     * @tparam pathPoints Trajectory approximation
     * @param robotId Robot id to ignore (i.e it self)
     * @param timeOffset Time offset to start checking from
     * @param shouldAvoidBall Whether to avoid the ball or not
     * @param timeLimit Time limit to check for collisions
     */
    [[nodiscard]] bool doesCollideWithMovingObjects(const Vector2& position, int robotId, bool shouldAvoidBall, double time = 0) const;

    /**
     * @brief Finds the first (time-wise) collision with the playing field.
     * @tparam pathPoints Trajectory approximation
     */
    [[nodiscard]] bool doesCollideWithField(const Vector2& position) const;

    /**
     * @brief Finds the first (time-wise) collision with defense area.
     * @tparam pathPoints Trajectory approximation
     */
    [[nodiscard]] bool doesCollideWithDefenseArea(const Vector2& position) const;


    /**
     * @brief Set minimal allowed distance from the ball.
     * @tparam distance minimal allowed distance.
     */
    void setMinBallDistance(double distance);


    void updateDefenseAreas(const std::optional<rtt::Field>& field);

    /**
     * @brief Updates the timeline with obstacles positions. Must be called *once* at the start of each tick.
     * For enemy robots and the ball the position is approximated.
     * For our robots only the observer position is updated (i.e the current position) or
     * if our robot is not moving the current position is set for all time steps.
     * @param robots Robots to update the timeline with
     * @param ball Ball to update the timeline with
     */
    void updateTimeline(const std::vector<RobotView>& robots, const std::optional<BallView>& ball);

    /**
     * @brief Updates the timeline with path approximation generated by path planning.
     * @param path Trajectory approximation.
     * @param currentPosition Current position of the robot.
     * @param robotId Id of robot to update the path for
     */
    void updateTimelineForOurRobot(std::span<const StateVector> path, const Vector2& currentPosition, int robotId);
};
}  // namespace rtt::ai::control
