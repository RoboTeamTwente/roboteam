/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const proto = $root.proto = (() => {

    /**
     * Namespace proto.
     * @exports proto
     * @namespace
     */
    const proto = {};

    proto.RobotPath = (function() {

        /**
         * Properties of a RobotPath.
         * @memberof proto
         * @interface IRobotPath
         * @property {number|null} [robotId] RobotPath robotId
         * @property {Array.<proto.RobotPath.IPoint>|null} [points] RobotPath points
         */

        /**
         * Constructs a new RobotPath.
         * @memberof proto
         * @classdesc Represents a RobotPath.
         * @implements IRobotPath
         * @constructor
         * @param {proto.IRobotPath=} [properties] Properties to set
         */
        function RobotPath(properties) {
            this.points = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RobotPath robotId.
         * @member {number} robotId
         * @memberof proto.RobotPath
         * @instance
         */
        RobotPath.prototype.robotId = 0;

        /**
         * RobotPath points.
         * @member {Array.<proto.RobotPath.IPoint>} points
         * @memberof proto.RobotPath
         * @instance
         */
        RobotPath.prototype.points = $util.emptyArray;

        /**
         * Creates a new RobotPath instance using the specified properties.
         * @function create
         * @memberof proto.RobotPath
         * @static
         * @param {proto.IRobotPath=} [properties] Properties to set
         * @returns {proto.RobotPath} RobotPath instance
         */
        RobotPath.create = function create(properties) {
            return new RobotPath(properties);
        };

        /**
         * Encodes the specified RobotPath message. Does not implicitly {@link proto.RobotPath.verify|verify} messages.
         * @function encode
         * @memberof proto.RobotPath
         * @static
         * @param {proto.IRobotPath} message RobotPath message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotPath.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.robotId != null && Object.hasOwnProperty.call(message, "robotId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.robotId);
            if (message.points != null && message.points.length)
                for (let i = 0; i < message.points.length; ++i)
                    $root.proto.RobotPath.Point.encode(message.points[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RobotPath message, length delimited. Does not implicitly {@link proto.RobotPath.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RobotPath
         * @static
         * @param {proto.IRobotPath} message RobotPath message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotPath.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RobotPath message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RobotPath
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RobotPath} RobotPath
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotPath.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RobotPath();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.robotId = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.points && message.points.length))
                            message.points = [];
                        message.points.push($root.proto.RobotPath.Point.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RobotPath message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RobotPath
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RobotPath} RobotPath
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotPath.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RobotPath message.
         * @function verify
         * @memberof proto.RobotPath
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RobotPath.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.robotId != null && message.hasOwnProperty("robotId"))
                if (!$util.isInteger(message.robotId))
                    return "robotId: integer expected";
            if (message.points != null && message.hasOwnProperty("points")) {
                if (!Array.isArray(message.points))
                    return "points: array expected";
                for (let i = 0; i < message.points.length; ++i) {
                    let error = $root.proto.RobotPath.Point.verify(message.points[i]);
                    if (error)
                        return "points." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RobotPath message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RobotPath
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RobotPath} RobotPath
         */
        RobotPath.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RobotPath)
                return object;
            let message = new $root.proto.RobotPath();
            if (object.robotId != null)
                message.robotId = object.robotId | 0;
            if (object.points) {
                if (!Array.isArray(object.points))
                    throw TypeError(".proto.RobotPath.points: array expected");
                message.points = [];
                for (let i = 0; i < object.points.length; ++i) {
                    if (typeof object.points[i] !== "object")
                        throw TypeError(".proto.RobotPath.points: object expected");
                    message.points[i] = $root.proto.RobotPath.Point.fromObject(object.points[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RobotPath message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RobotPath
         * @static
         * @param {proto.RobotPath} message RobotPath
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RobotPath.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.points = [];
            if (options.defaults)
                object.robotId = 0;
            if (message.robotId != null && message.hasOwnProperty("robotId"))
                object.robotId = message.robotId;
            if (message.points && message.points.length) {
                object.points = [];
                for (let j = 0; j < message.points.length; ++j)
                    object.points[j] = $root.proto.RobotPath.Point.toObject(message.points[j], options);
            }
            return object;
        };

        /**
         * Converts this RobotPath to JSON.
         * @function toJSON
         * @memberof proto.RobotPath
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RobotPath.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RobotPath
         * @function getTypeUrl
         * @memberof proto.RobotPath
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RobotPath.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RobotPath";
        };

        RobotPath.Point = (function() {

            /**
             * Properties of a Point.
             * @memberof proto.RobotPath
             * @interface IPoint
             * @property {number|null} [x] Point x
             * @property {number|null} [y] Point y
             */

            /**
             * Constructs a new Point.
             * @memberof proto.RobotPath
             * @classdesc Represents a Point.
             * @implements IPoint
             * @constructor
             * @param {proto.RobotPath.IPoint=} [properties] Properties to set
             */
            function Point(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Point x.
             * @member {number} x
             * @memberof proto.RobotPath.Point
             * @instance
             */
            Point.prototype.x = 0;

            /**
             * Point y.
             * @member {number} y
             * @memberof proto.RobotPath.Point
             * @instance
             */
            Point.prototype.y = 0;

            /**
             * Creates a new Point instance using the specified properties.
             * @function create
             * @memberof proto.RobotPath.Point
             * @static
             * @param {proto.RobotPath.IPoint=} [properties] Properties to set
             * @returns {proto.RobotPath.Point} Point instance
             */
            Point.create = function create(properties) {
                return new Point(properties);
            };

            /**
             * Encodes the specified Point message. Does not implicitly {@link proto.RobotPath.Point.verify|verify} messages.
             * @function encode
             * @memberof proto.RobotPath.Point
             * @static
             * @param {proto.RobotPath.IPoint} message Point message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Point.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
                if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
                return writer;
            };

            /**
             * Encodes the specified Point message, length delimited. Does not implicitly {@link proto.RobotPath.Point.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.RobotPath.Point
             * @static
             * @param {proto.RobotPath.IPoint} message Point message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Point.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Point message from the specified reader or buffer.
             * @function decode
             * @memberof proto.RobotPath.Point
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.RobotPath.Point} Point
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Point.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RobotPath.Point();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.x = reader.double();
                            break;
                        }
                    case 2: {
                            message.y = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Point message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.RobotPath.Point
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.RobotPath.Point} Point
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Point.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Point message.
             * @function verify
             * @memberof proto.RobotPath.Point
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Point.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.x != null && message.hasOwnProperty("x"))
                    if (typeof message.x !== "number")
                        return "x: number expected";
                if (message.y != null && message.hasOwnProperty("y"))
                    if (typeof message.y !== "number")
                        return "y: number expected";
                return null;
            };

            /**
             * Creates a Point message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.RobotPath.Point
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.RobotPath.Point} Point
             */
            Point.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.RobotPath.Point)
                    return object;
                let message = new $root.proto.RobotPath.Point();
                if (object.x != null)
                    message.x = Number(object.x);
                if (object.y != null)
                    message.y = Number(object.y);
                return message;
            };

            /**
             * Creates a plain object from a Point message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.RobotPath.Point
             * @static
             * @param {proto.RobotPath.Point} message Point
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Point.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.x = 0;
                    object.y = 0;
                }
                if (message.x != null && message.hasOwnProperty("x"))
                    object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                if (message.y != null && message.hasOwnProperty("y"))
                    object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                return object;
            };

            /**
             * Converts this Point to JSON.
             * @function toJSON
             * @memberof proto.RobotPath.Point
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Point.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Point
             * @function getTypeUrl
             * @memberof proto.RobotPath.Point
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Point.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.RobotPath.Point";
            };

            return Point;
        })();

        return RobotPath;
    })();

    proto.RobotSTP = (function() {

        /**
         * Properties of a RobotSTP.
         * @memberof proto
         * @interface IRobotSTP
         * @property {number|null} [robotId] RobotSTP robotId
         * @property {string|null} [role] RobotSTP role
         * @property {string|null} [roleStatus] RobotSTP roleStatus
         * @property {string|null} [tactic] RobotSTP tactic
         * @property {string|null} [tacticStatus] RobotSTP tacticStatus
         * @property {string|null} [skill] RobotSTP skill
         * @property {string|null} [skillStatus] RobotSTP skillStatus
         */

        /**
         * Constructs a new RobotSTP.
         * @memberof proto
         * @classdesc Represents a RobotSTP.
         * @implements IRobotSTP
         * @constructor
         * @param {proto.IRobotSTP=} [properties] Properties to set
         */
        function RobotSTP(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RobotSTP robotId.
         * @member {number} robotId
         * @memberof proto.RobotSTP
         * @instance
         */
        RobotSTP.prototype.robotId = 0;

        /**
         * RobotSTP role.
         * @member {string} role
         * @memberof proto.RobotSTP
         * @instance
         */
        RobotSTP.prototype.role = "";

        /**
         * RobotSTP roleStatus.
         * @member {string} roleStatus
         * @memberof proto.RobotSTP
         * @instance
         */
        RobotSTP.prototype.roleStatus = "";

        /**
         * RobotSTP tactic.
         * @member {string} tactic
         * @memberof proto.RobotSTP
         * @instance
         */
        RobotSTP.prototype.tactic = "";

        /**
         * RobotSTP tacticStatus.
         * @member {string} tacticStatus
         * @memberof proto.RobotSTP
         * @instance
         */
        RobotSTP.prototype.tacticStatus = "";

        /**
         * RobotSTP skill.
         * @member {string} skill
         * @memberof proto.RobotSTP
         * @instance
         */
        RobotSTP.prototype.skill = "";

        /**
         * RobotSTP skillStatus.
         * @member {string} skillStatus
         * @memberof proto.RobotSTP
         * @instance
         */
        RobotSTP.prototype.skillStatus = "";

        /**
         * Creates a new RobotSTP instance using the specified properties.
         * @function create
         * @memberof proto.RobotSTP
         * @static
         * @param {proto.IRobotSTP=} [properties] Properties to set
         * @returns {proto.RobotSTP} RobotSTP instance
         */
        RobotSTP.create = function create(properties) {
            return new RobotSTP(properties);
        };

        /**
         * Encodes the specified RobotSTP message. Does not implicitly {@link proto.RobotSTP.verify|verify} messages.
         * @function encode
         * @memberof proto.RobotSTP
         * @static
         * @param {proto.IRobotSTP} message RobotSTP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotSTP.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.robotId != null && Object.hasOwnProperty.call(message, "robotId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.robotId);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.role);
            if (message.roleStatus != null && Object.hasOwnProperty.call(message, "roleStatus"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.roleStatus);
            if (message.tactic != null && Object.hasOwnProperty.call(message, "tactic"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.tactic);
            if (message.tacticStatus != null && Object.hasOwnProperty.call(message, "tacticStatus"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.tacticStatus);
            if (message.skill != null && Object.hasOwnProperty.call(message, "skill"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.skill);
            if (message.skillStatus != null && Object.hasOwnProperty.call(message, "skillStatus"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.skillStatus);
            return writer;
        };

        /**
         * Encodes the specified RobotSTP message, length delimited. Does not implicitly {@link proto.RobotSTP.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RobotSTP
         * @static
         * @param {proto.IRobotSTP} message RobotSTP message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotSTP.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RobotSTP message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RobotSTP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RobotSTP} RobotSTP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotSTP.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RobotSTP();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.robotId = reader.int32();
                        break;
                    }
                case 2: {
                        message.role = reader.string();
                        break;
                    }
                case 3: {
                        message.roleStatus = reader.string();
                        break;
                    }
                case 4: {
                        message.tactic = reader.string();
                        break;
                    }
                case 5: {
                        message.tacticStatus = reader.string();
                        break;
                    }
                case 6: {
                        message.skill = reader.string();
                        break;
                    }
                case 7: {
                        message.skillStatus = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RobotSTP message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RobotSTP
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RobotSTP} RobotSTP
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotSTP.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RobotSTP message.
         * @function verify
         * @memberof proto.RobotSTP
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RobotSTP.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.robotId != null && message.hasOwnProperty("robotId"))
                if (!$util.isInteger(message.robotId))
                    return "robotId: integer expected";
            if (message.role != null && message.hasOwnProperty("role"))
                if (!$util.isString(message.role))
                    return "role: string expected";
            if (message.roleStatus != null && message.hasOwnProperty("roleStatus"))
                if (!$util.isString(message.roleStatus))
                    return "roleStatus: string expected";
            if (message.tactic != null && message.hasOwnProperty("tactic"))
                if (!$util.isString(message.tactic))
                    return "tactic: string expected";
            if (message.tacticStatus != null && message.hasOwnProperty("tacticStatus"))
                if (!$util.isString(message.tacticStatus))
                    return "tacticStatus: string expected";
            if (message.skill != null && message.hasOwnProperty("skill"))
                if (!$util.isString(message.skill))
                    return "skill: string expected";
            if (message.skillStatus != null && message.hasOwnProperty("skillStatus"))
                if (!$util.isString(message.skillStatus))
                    return "skillStatus: string expected";
            return null;
        };

        /**
         * Creates a RobotSTP message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RobotSTP
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RobotSTP} RobotSTP
         */
        RobotSTP.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RobotSTP)
                return object;
            let message = new $root.proto.RobotSTP();
            if (object.robotId != null)
                message.robotId = object.robotId | 0;
            if (object.role != null)
                message.role = String(object.role);
            if (object.roleStatus != null)
                message.roleStatus = String(object.roleStatus);
            if (object.tactic != null)
                message.tactic = String(object.tactic);
            if (object.tacticStatus != null)
                message.tacticStatus = String(object.tacticStatus);
            if (object.skill != null)
                message.skill = String(object.skill);
            if (object.skillStatus != null)
                message.skillStatus = String(object.skillStatus);
            return message;
        };

        /**
         * Creates a plain object from a RobotSTP message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RobotSTP
         * @static
         * @param {proto.RobotSTP} message RobotSTP
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RobotSTP.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.robotId = 0;
                object.role = "";
                object.roleStatus = "";
                object.tactic = "";
                object.tacticStatus = "";
                object.skill = "";
                object.skillStatus = "";
            }
            if (message.robotId != null && message.hasOwnProperty("robotId"))
                object.robotId = message.robotId;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = message.role;
            if (message.roleStatus != null && message.hasOwnProperty("roleStatus"))
                object.roleStatus = message.roleStatus;
            if (message.tactic != null && message.hasOwnProperty("tactic"))
                object.tactic = message.tactic;
            if (message.tacticStatus != null && message.hasOwnProperty("tacticStatus"))
                object.tacticStatus = message.tacticStatus;
            if (message.skill != null && message.hasOwnProperty("skill"))
                object.skill = message.skill;
            if (message.skillStatus != null && message.hasOwnProperty("skillStatus"))
                object.skillStatus = message.skillStatus;
            return object;
        };

        /**
         * Converts this RobotSTP to JSON.
         * @function toJSON
         * @memberof proto.RobotSTP
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RobotSTP.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RobotSTP
         * @function getTypeUrl
         * @memberof proto.RobotSTP
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RobotSTP.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RobotSTP";
        };

        return RobotSTP;
    })();

    proto.AIData = (function() {

        /**
         * Properties of a AIData.
         * @memberof proto
         * @interface IAIData
         * @property {Array.<proto.IRobotSTP>|null} [robotStps] AIData robotStps
         * @property {Array.<proto.IRobotPath>|null} [robotPaths] AIData robotPaths
         */

        /**
         * Constructs a new AIData.
         * @memberof proto
         * @classdesc Represents a AIData.
         * @implements IAIData
         * @constructor
         * @param {proto.IAIData=} [properties] Properties to set
         */
        function AIData(properties) {
            this.robotStps = [];
            this.robotPaths = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AIData robotStps.
         * @member {Array.<proto.IRobotSTP>} robotStps
         * @memberof proto.AIData
         * @instance
         */
        AIData.prototype.robotStps = $util.emptyArray;

        /**
         * AIData robotPaths.
         * @member {Array.<proto.IRobotPath>} robotPaths
         * @memberof proto.AIData
         * @instance
         */
        AIData.prototype.robotPaths = $util.emptyArray;

        /**
         * Creates a new AIData instance using the specified properties.
         * @function create
         * @memberof proto.AIData
         * @static
         * @param {proto.IAIData=} [properties] Properties to set
         * @returns {proto.AIData} AIData instance
         */
        AIData.create = function create(properties) {
            return new AIData(properties);
        };

        /**
         * Encodes the specified AIData message. Does not implicitly {@link proto.AIData.verify|verify} messages.
         * @function encode
         * @memberof proto.AIData
         * @static
         * @param {proto.IAIData} message AIData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AIData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.robotStps != null && message.robotStps.length)
                for (let i = 0; i < message.robotStps.length; ++i)
                    $root.proto.RobotSTP.encode(message.robotStps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.robotPaths != null && message.robotPaths.length)
                for (let i = 0; i < message.robotPaths.length; ++i)
                    $root.proto.RobotPath.encode(message.robotPaths[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AIData message, length delimited. Does not implicitly {@link proto.AIData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.AIData
         * @static
         * @param {proto.IAIData} message AIData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AIData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a AIData message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AIData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.AIData} AIData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AIData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.AIData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.robotStps && message.robotStps.length))
                            message.robotStps = [];
                        message.robotStps.push($root.proto.RobotSTP.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.robotPaths && message.robotPaths.length))
                            message.robotPaths = [];
                        message.robotPaths.push($root.proto.RobotPath.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a AIData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.AIData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.AIData} AIData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AIData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a AIData message.
         * @function verify
         * @memberof proto.AIData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AIData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.robotStps != null && message.hasOwnProperty("robotStps")) {
                if (!Array.isArray(message.robotStps))
                    return "robotStps: array expected";
                for (let i = 0; i < message.robotStps.length; ++i) {
                    let error = $root.proto.RobotSTP.verify(message.robotStps[i]);
                    if (error)
                        return "robotStps." + error;
                }
            }
            if (message.robotPaths != null && message.hasOwnProperty("robotPaths")) {
                if (!Array.isArray(message.robotPaths))
                    return "robotPaths: array expected";
                for (let i = 0; i < message.robotPaths.length; ++i) {
                    let error = $root.proto.RobotPath.verify(message.robotPaths[i]);
                    if (error)
                        return "robotPaths." + error;
                }
            }
            return null;
        };

        /**
         * Creates a AIData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.AIData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.AIData} AIData
         */
        AIData.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.AIData)
                return object;
            let message = new $root.proto.AIData();
            if (object.robotStps) {
                if (!Array.isArray(object.robotStps))
                    throw TypeError(".proto.AIData.robotStps: array expected");
                message.robotStps = [];
                for (let i = 0; i < object.robotStps.length; ++i) {
                    if (typeof object.robotStps[i] !== "object")
                        throw TypeError(".proto.AIData.robotStps: object expected");
                    message.robotStps[i] = $root.proto.RobotSTP.fromObject(object.robotStps[i]);
                }
            }
            if (object.robotPaths) {
                if (!Array.isArray(object.robotPaths))
                    throw TypeError(".proto.AIData.robotPaths: array expected");
                message.robotPaths = [];
                for (let i = 0; i < object.robotPaths.length; ++i) {
                    if (typeof object.robotPaths[i] !== "object")
                        throw TypeError(".proto.AIData.robotPaths: object expected");
                    message.robotPaths[i] = $root.proto.RobotPath.fromObject(object.robotPaths[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a AIData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.AIData
         * @static
         * @param {proto.AIData} message AIData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AIData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.robotStps = [];
                object.robotPaths = [];
            }
            if (message.robotStps && message.robotStps.length) {
                object.robotStps = [];
                for (let j = 0; j < message.robotStps.length; ++j)
                    object.robotStps[j] = $root.proto.RobotSTP.toObject(message.robotStps[j], options);
            }
            if (message.robotPaths && message.robotPaths.length) {
                object.robotPaths = [];
                for (let j = 0; j < message.robotPaths.length; ++j)
                    object.robotPaths[j] = $root.proto.RobotPath.toObject(message.robotPaths[j], options);
            }
            return object;
        };

        /**
         * Converts this AIData to JSON.
         * @function toJSON
         * @memberof proto.AIData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AIData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AIData
         * @function getTypeUrl
         * @memberof proto.AIData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AIData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AIData";
        };

        return AIData;
    })();

    proto.GameSettings = (function() {

        /**
         * Properties of a GameSettings.
         * @memberof proto
         * @interface IGameSettings
         * @property {boolean|null} [isPrimaryAi] GameSettings isPrimaryAi
         * @property {boolean|null} [isYellow] GameSettings isYellow
         * @property {boolean|null} [isLeft] GameSettings isLeft
         * @property {proto.GameSettings.RobotHubMode|null} [robotHubMode] GameSettings robotHubMode
         */

        /**
         * Constructs a new GameSettings.
         * @memberof proto
         * @classdesc Represents a GameSettings.
         * @implements IGameSettings
         * @constructor
         * @param {proto.IGameSettings=} [properties] Properties to set
         */
        function GameSettings(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameSettings isPrimaryAi.
         * @member {boolean} isPrimaryAi
         * @memberof proto.GameSettings
         * @instance
         */
        GameSettings.prototype.isPrimaryAi = false;

        /**
         * GameSettings isYellow.
         * @member {boolean} isYellow
         * @memberof proto.GameSettings
         * @instance
         */
        GameSettings.prototype.isYellow = false;

        /**
         * GameSettings isLeft.
         * @member {boolean} isLeft
         * @memberof proto.GameSettings
         * @instance
         */
        GameSettings.prototype.isLeft = false;

        /**
         * GameSettings robotHubMode.
         * @member {proto.GameSettings.RobotHubMode} robotHubMode
         * @memberof proto.GameSettings
         * @instance
         */
        GameSettings.prototype.robotHubMode = 0;

        /**
         * Creates a new GameSettings instance using the specified properties.
         * @function create
         * @memberof proto.GameSettings
         * @static
         * @param {proto.IGameSettings=} [properties] Properties to set
         * @returns {proto.GameSettings} GameSettings instance
         */
        GameSettings.create = function create(properties) {
            return new GameSettings(properties);
        };

        /**
         * Encodes the specified GameSettings message. Does not implicitly {@link proto.GameSettings.verify|verify} messages.
         * @function encode
         * @memberof proto.GameSettings
         * @static
         * @param {proto.IGameSettings} message GameSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameSettings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isPrimaryAi != null && Object.hasOwnProperty.call(message, "isPrimaryAi"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isPrimaryAi);
            if (message.isYellow != null && Object.hasOwnProperty.call(message, "isYellow"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isYellow);
            if (message.isLeft != null && Object.hasOwnProperty.call(message, "isLeft"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isLeft);
            if (message.robotHubMode != null && Object.hasOwnProperty.call(message, "robotHubMode"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.robotHubMode);
            return writer;
        };

        /**
         * Encodes the specified GameSettings message, length delimited. Does not implicitly {@link proto.GameSettings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.GameSettings
         * @static
         * @param {proto.IGameSettings} message GameSettings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameSettings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GameSettings message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GameSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GameSettings} GameSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameSettings.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameSettings();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.isPrimaryAi = reader.bool();
                        break;
                    }
                case 2: {
                        message.isYellow = reader.bool();
                        break;
                    }
                case 3: {
                        message.isLeft = reader.bool();
                        break;
                    }
                case 4: {
                        message.robotHubMode = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GameSettings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.GameSettings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.GameSettings} GameSettings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameSettings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GameSettings message.
         * @function verify
         * @memberof proto.GameSettings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GameSettings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isPrimaryAi != null && message.hasOwnProperty("isPrimaryAi"))
                if (typeof message.isPrimaryAi !== "boolean")
                    return "isPrimaryAi: boolean expected";
            if (message.isYellow != null && message.hasOwnProperty("isYellow"))
                if (typeof message.isYellow !== "boolean")
                    return "isYellow: boolean expected";
            if (message.isLeft != null && message.hasOwnProperty("isLeft"))
                if (typeof message.isLeft !== "boolean")
                    return "isLeft: boolean expected";
            if (message.robotHubMode != null && message.hasOwnProperty("robotHubMode"))
                switch (message.robotHubMode) {
                default:
                    return "robotHubMode: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a GameSettings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.GameSettings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.GameSettings} GameSettings
         */
        GameSettings.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.GameSettings)
                return object;
            let message = new $root.proto.GameSettings();
            if (object.isPrimaryAi != null)
                message.isPrimaryAi = Boolean(object.isPrimaryAi);
            if (object.isYellow != null)
                message.isYellow = Boolean(object.isYellow);
            if (object.isLeft != null)
                message.isLeft = Boolean(object.isLeft);
            switch (object.robotHubMode) {
            default:
                if (typeof object.robotHubMode === "number") {
                    message.robotHubMode = object.robotHubMode;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.robotHubMode = 0;
                break;
            case "BASESTATION":
            case 1:
                message.robotHubMode = 1;
                break;
            case "SIMULATOR":
            case 2:
                message.robotHubMode = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a GameSettings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.GameSettings
         * @static
         * @param {proto.GameSettings} message GameSettings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GameSettings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.isPrimaryAi = false;
                object.isYellow = false;
                object.isLeft = false;
                object.robotHubMode = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.isPrimaryAi != null && message.hasOwnProperty("isPrimaryAi"))
                object.isPrimaryAi = message.isPrimaryAi;
            if (message.isYellow != null && message.hasOwnProperty("isYellow"))
                object.isYellow = message.isYellow;
            if (message.isLeft != null && message.hasOwnProperty("isLeft"))
                object.isLeft = message.isLeft;
            if (message.robotHubMode != null && message.hasOwnProperty("robotHubMode"))
                object.robotHubMode = options.enums === String ? $root.proto.GameSettings.RobotHubMode[message.robotHubMode] === undefined ? message.robotHubMode : $root.proto.GameSettings.RobotHubMode[message.robotHubMode] : message.robotHubMode;
            return object;
        };

        /**
         * Converts this GameSettings to JSON.
         * @function toJSON
         * @memberof proto.GameSettings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GameSettings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GameSettings
         * @function getTypeUrl
         * @memberof proto.GameSettings
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GameSettings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GameSettings";
        };

        /**
         * RobotHubMode enum.
         * @name proto.GameSettings.RobotHubMode
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} BASESTATION=1 BASESTATION value
         * @property {number} SIMULATOR=2 SIMULATOR value
         */
        GameSettings.RobotHubMode = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "BASESTATION"] = 1;
            values[valuesById[2] = "SIMULATOR"] = 2;
            return values;
        })();

        return GameSettings;
    })();

    proto.Handshake = (function() {

        /**
         * Properties of a Handshake.
         * @memberof proto
         * @interface IHandshake
         * @property {string|null} [moduleName] Handshake moduleName
         * @property {proto.IUiOptionDeclarations|null} [declarations] Handshake declarations
         * @property {proto.IUiValues|null} [values] Handshake values
         */

        /**
         * Constructs a new Handshake.
         * @memberof proto
         * @classdesc Represents a Handshake.
         * @implements IHandshake
         * @constructor
         * @param {proto.IHandshake=} [properties] Properties to set
         */
        function Handshake(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Handshake moduleName.
         * @member {string} moduleName
         * @memberof proto.Handshake
         * @instance
         */
        Handshake.prototype.moduleName = "";

        /**
         * Handshake declarations.
         * @member {proto.IUiOptionDeclarations|null|undefined} declarations
         * @memberof proto.Handshake
         * @instance
         */
        Handshake.prototype.declarations = null;

        /**
         * Handshake values.
         * @member {proto.IUiValues|null|undefined} values
         * @memberof proto.Handshake
         * @instance
         */
        Handshake.prototype.values = null;

        /**
         * Creates a new Handshake instance using the specified properties.
         * @function create
         * @memberof proto.Handshake
         * @static
         * @param {proto.IHandshake=} [properties] Properties to set
         * @returns {proto.Handshake} Handshake instance
         */
        Handshake.create = function create(properties) {
            return new Handshake(properties);
        };

        /**
         * Encodes the specified Handshake message. Does not implicitly {@link proto.Handshake.verify|verify} messages.
         * @function encode
         * @memberof proto.Handshake
         * @static
         * @param {proto.IHandshake} message Handshake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Handshake.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.moduleName != null && Object.hasOwnProperty.call(message, "moduleName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.moduleName);
            if (message.declarations != null && Object.hasOwnProperty.call(message, "declarations"))
                $root.proto.UiOptionDeclarations.encode(message.declarations, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.values != null && Object.hasOwnProperty.call(message, "values"))
                $root.proto.UiValues.encode(message.values, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Handshake message, length delimited. Does not implicitly {@link proto.Handshake.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Handshake
         * @static
         * @param {proto.IHandshake} message Handshake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Handshake.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Handshake message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Handshake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Handshake} Handshake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Handshake.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Handshake();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.moduleName = reader.string();
                        break;
                    }
                case 2: {
                        message.declarations = $root.proto.UiOptionDeclarations.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.values = $root.proto.UiValues.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Handshake message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Handshake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Handshake} Handshake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Handshake.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Handshake message.
         * @function verify
         * @memberof proto.Handshake
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Handshake.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.moduleName != null && message.hasOwnProperty("moduleName"))
                if (!$util.isString(message.moduleName))
                    return "moduleName: string expected";
            if (message.declarations != null && message.hasOwnProperty("declarations")) {
                let error = $root.proto.UiOptionDeclarations.verify(message.declarations);
                if (error)
                    return "declarations." + error;
            }
            if (message.values != null && message.hasOwnProperty("values")) {
                let error = $root.proto.UiValues.verify(message.values);
                if (error)
                    return "values." + error;
            }
            return null;
        };

        /**
         * Creates a Handshake message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Handshake
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Handshake} Handshake
         */
        Handshake.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Handshake)
                return object;
            let message = new $root.proto.Handshake();
            if (object.moduleName != null)
                message.moduleName = String(object.moduleName);
            if (object.declarations != null) {
                if (typeof object.declarations !== "object")
                    throw TypeError(".proto.Handshake.declarations: object expected");
                message.declarations = $root.proto.UiOptionDeclarations.fromObject(object.declarations);
            }
            if (object.values != null) {
                if (typeof object.values !== "object")
                    throw TypeError(".proto.Handshake.values: object expected");
                message.values = $root.proto.UiValues.fromObject(object.values);
            }
            return message;
        };

        /**
         * Creates a plain object from a Handshake message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Handshake
         * @static
         * @param {proto.Handshake} message Handshake
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Handshake.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.moduleName = "";
                object.declarations = null;
                object.values = null;
            }
            if (message.moduleName != null && message.hasOwnProperty("moduleName"))
                object.moduleName = message.moduleName;
            if (message.declarations != null && message.hasOwnProperty("declarations"))
                object.declarations = $root.proto.UiOptionDeclarations.toObject(message.declarations, options);
            if (message.values != null && message.hasOwnProperty("values"))
                object.values = $root.proto.UiValues.toObject(message.values, options);
            return object;
        };

        /**
         * Converts this Handshake to JSON.
         * @function toJSON
         * @memberof proto.Handshake
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Handshake.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Handshake
         * @function getTypeUrl
         * @memberof proto.Handshake
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Handshake.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Handshake";
        };

        return Handshake;
    })();

    proto.Slider = (function() {

        /**
         * Properties of a Slider.
         * @memberof proto
         * @interface ISlider
         * @property {string|null} [text] Slider text
         * @property {number|null} [min] Slider min
         * @property {number|null} [max] Slider max
         * @property {number|null} [interval] Slider interval
         * @property {number|null} ["default"] Slider default
         * @property {number|null} [dpi] Slider dpi
         */

        /**
         * Constructs a new Slider.
         * @memberof proto
         * @classdesc Represents a Slider.
         * @implements ISlider
         * @constructor
         * @param {proto.ISlider=} [properties] Properties to set
         */
        function Slider(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Slider text.
         * @member {string} text
         * @memberof proto.Slider
         * @instance
         */
        Slider.prototype.text = "";

        /**
         * Slider min.
         * @member {number} min
         * @memberof proto.Slider
         * @instance
         */
        Slider.prototype.min = 0;

        /**
         * Slider max.
         * @member {number} max
         * @memberof proto.Slider
         * @instance
         */
        Slider.prototype.max = 0;

        /**
         * Slider interval.
         * @member {number} interval
         * @memberof proto.Slider
         * @instance
         */
        Slider.prototype.interval = 0;

        /**
         * Slider default.
         * @member {number} default
         * @memberof proto.Slider
         * @instance
         */
        Slider.prototype["default"] = 0;

        /**
         * Slider dpi.
         * @member {number} dpi
         * @memberof proto.Slider
         * @instance
         */
        Slider.prototype.dpi = 0;

        /**
         * Creates a new Slider instance using the specified properties.
         * @function create
         * @memberof proto.Slider
         * @static
         * @param {proto.ISlider=} [properties] Properties to set
         * @returns {proto.Slider} Slider instance
         */
        Slider.create = function create(properties) {
            return new Slider(properties);
        };

        /**
         * Encodes the specified Slider message. Does not implicitly {@link proto.Slider.verify|verify} messages.
         * @function encode
         * @memberof proto.Slider
         * @static
         * @param {proto.ISlider} message Slider message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slider.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            if (message.min != null && Object.hasOwnProperty.call(message, "min"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.min);
            if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.max);
            if (message.interval != null && Object.hasOwnProperty.call(message, "interval"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.interval);
            if (message["default"] != null && Object.hasOwnProperty.call(message, "default"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message["default"]);
            if (message.dpi != null && Object.hasOwnProperty.call(message, "dpi"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.dpi);
            return writer;
        };

        /**
         * Encodes the specified Slider message, length delimited. Does not implicitly {@link proto.Slider.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Slider
         * @static
         * @param {proto.ISlider} message Slider message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Slider.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Slider message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Slider
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Slider} Slider
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slider.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Slider();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.text = reader.string();
                        break;
                    }
                case 2: {
                        message.min = reader.float();
                        break;
                    }
                case 3: {
                        message.max = reader.float();
                        break;
                    }
                case 4: {
                        message.interval = reader.float();
                        break;
                    }
                case 5: {
                        message["default"] = reader.float();
                        break;
                    }
                case 6: {
                        message.dpi = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Slider message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Slider
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Slider} Slider
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Slider.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Slider message.
         * @function verify
         * @memberof proto.Slider
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Slider.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.min != null && message.hasOwnProperty("min"))
                if (typeof message.min !== "number")
                    return "min: number expected";
            if (message.max != null && message.hasOwnProperty("max"))
                if (typeof message.max !== "number")
                    return "max: number expected";
            if (message.interval != null && message.hasOwnProperty("interval"))
                if (typeof message.interval !== "number")
                    return "interval: number expected";
            if (message["default"] != null && message.hasOwnProperty("default"))
                if (typeof message["default"] !== "number")
                    return "default: number expected";
            if (message.dpi != null && message.hasOwnProperty("dpi"))
                if (!$util.isInteger(message.dpi))
                    return "dpi: integer expected";
            return null;
        };

        /**
         * Creates a Slider message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Slider
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Slider} Slider
         */
        Slider.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Slider)
                return object;
            let message = new $root.proto.Slider();
            if (object.text != null)
                message.text = String(object.text);
            if (object.min != null)
                message.min = Number(object.min);
            if (object.max != null)
                message.max = Number(object.max);
            if (object.interval != null)
                message.interval = Number(object.interval);
            if (object["default"] != null)
                message["default"] = Number(object["default"]);
            if (object.dpi != null)
                message.dpi = object.dpi | 0;
            return message;
        };

        /**
         * Creates a plain object from a Slider message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Slider
         * @static
         * @param {proto.Slider} message Slider
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Slider.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.text = "";
                object.min = 0;
                object.max = 0;
                object.interval = 0;
                object["default"] = 0;
                object.dpi = 0;
            }
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.min != null && message.hasOwnProperty("min"))
                object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;
            if (message.max != null && message.hasOwnProperty("max"))
                object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;
            if (message.interval != null && message.hasOwnProperty("interval"))
                object.interval = options.json && !isFinite(message.interval) ? String(message.interval) : message.interval;
            if (message["default"] != null && message.hasOwnProperty("default"))
                object["default"] = options.json && !isFinite(message["default"]) ? String(message["default"]) : message["default"];
            if (message.dpi != null && message.hasOwnProperty("dpi"))
                object.dpi = message.dpi;
            return object;
        };

        /**
         * Converts this Slider to JSON.
         * @function toJSON
         * @memberof proto.Slider
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Slider.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Slider
         * @function getTypeUrl
         * @memberof proto.Slider
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Slider.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Slider";
        };

        return Slider;
    })();

    proto.Checkbox = (function() {

        /**
         * Properties of a Checkbox.
         * @memberof proto
         * @interface ICheckbox
         * @property {string|null} [text] Checkbox text
         */

        /**
         * Constructs a new Checkbox.
         * @memberof proto
         * @classdesc Represents a Checkbox.
         * @implements ICheckbox
         * @constructor
         * @param {proto.ICheckbox=} [properties] Properties to set
         */
        function Checkbox(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Checkbox text.
         * @member {string} text
         * @memberof proto.Checkbox
         * @instance
         */
        Checkbox.prototype.text = "";

        /**
         * Creates a new Checkbox instance using the specified properties.
         * @function create
         * @memberof proto.Checkbox
         * @static
         * @param {proto.ICheckbox=} [properties] Properties to set
         * @returns {proto.Checkbox} Checkbox instance
         */
        Checkbox.create = function create(properties) {
            return new Checkbox(properties);
        };

        /**
         * Encodes the specified Checkbox message. Does not implicitly {@link proto.Checkbox.verify|verify} messages.
         * @function encode
         * @memberof proto.Checkbox
         * @static
         * @param {proto.ICheckbox} message Checkbox message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Checkbox.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            return writer;
        };

        /**
         * Encodes the specified Checkbox message, length delimited. Does not implicitly {@link proto.Checkbox.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Checkbox
         * @static
         * @param {proto.ICheckbox} message Checkbox message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Checkbox.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Checkbox message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Checkbox
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Checkbox} Checkbox
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Checkbox.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Checkbox();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.text = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Checkbox message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Checkbox
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Checkbox} Checkbox
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Checkbox.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Checkbox message.
         * @function verify
         * @memberof proto.Checkbox
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Checkbox.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            return null;
        };

        /**
         * Creates a Checkbox message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Checkbox
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Checkbox} Checkbox
         */
        Checkbox.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Checkbox)
                return object;
            let message = new $root.proto.Checkbox();
            if (object.text != null)
                message.text = String(object.text);
            return message;
        };

        /**
         * Creates a plain object from a Checkbox message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Checkbox
         * @static
         * @param {proto.Checkbox} message Checkbox
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Checkbox.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.text = "";
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            return object;
        };

        /**
         * Converts this Checkbox to JSON.
         * @function toJSON
         * @memberof proto.Checkbox
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Checkbox.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Checkbox
         * @function getTypeUrl
         * @memberof proto.Checkbox
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Checkbox.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Checkbox";
        };

        return Checkbox;
    })();

    proto.Dropdown = (function() {

        /**
         * Properties of a Dropdown.
         * @memberof proto
         * @interface IDropdown
         * @property {string|null} [text] Dropdown text
         * @property {Array.<string>|null} [options] Dropdown options
         */

        /**
         * Constructs a new Dropdown.
         * @memberof proto
         * @classdesc Represents a Dropdown.
         * @implements IDropdown
         * @constructor
         * @param {proto.IDropdown=} [properties] Properties to set
         */
        function Dropdown(properties) {
            this.options = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Dropdown text.
         * @member {string} text
         * @memberof proto.Dropdown
         * @instance
         */
        Dropdown.prototype.text = "";

        /**
         * Dropdown options.
         * @member {Array.<string>} options
         * @memberof proto.Dropdown
         * @instance
         */
        Dropdown.prototype.options = $util.emptyArray;

        /**
         * Creates a new Dropdown instance using the specified properties.
         * @function create
         * @memberof proto.Dropdown
         * @static
         * @param {proto.IDropdown=} [properties] Properties to set
         * @returns {proto.Dropdown} Dropdown instance
         */
        Dropdown.create = function create(properties) {
            return new Dropdown(properties);
        };

        /**
         * Encodes the specified Dropdown message. Does not implicitly {@link proto.Dropdown.verify|verify} messages.
         * @function encode
         * @memberof proto.Dropdown
         * @static
         * @param {proto.IDropdown} message Dropdown message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dropdown.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            if (message.options != null && message.options.length)
                for (let i = 0; i < message.options.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.options[i]);
            return writer;
        };

        /**
         * Encodes the specified Dropdown message, length delimited. Does not implicitly {@link proto.Dropdown.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Dropdown
         * @static
         * @param {proto.IDropdown} message Dropdown message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dropdown.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Dropdown message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Dropdown
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Dropdown} Dropdown
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dropdown.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Dropdown();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.text = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.options && message.options.length))
                            message.options = [];
                        message.options.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Dropdown message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Dropdown
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Dropdown} Dropdown
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dropdown.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Dropdown message.
         * @function verify
         * @memberof proto.Dropdown
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Dropdown.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                if (!Array.isArray(message.options))
                    return "options: array expected";
                for (let i = 0; i < message.options.length; ++i)
                    if (!$util.isString(message.options[i]))
                        return "options: string[] expected";
            }
            return null;
        };

        /**
         * Creates a Dropdown message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Dropdown
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Dropdown} Dropdown
         */
        Dropdown.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Dropdown)
                return object;
            let message = new $root.proto.Dropdown();
            if (object.text != null)
                message.text = String(object.text);
            if (object.options) {
                if (!Array.isArray(object.options))
                    throw TypeError(".proto.Dropdown.options: array expected");
                message.options = [];
                for (let i = 0; i < object.options.length; ++i)
                    message.options[i] = String(object.options[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a Dropdown message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Dropdown
         * @static
         * @param {proto.Dropdown} message Dropdown
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Dropdown.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.options = [];
            if (options.defaults)
                object.text = "";
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.options && message.options.length) {
                object.options = [];
                for (let j = 0; j < message.options.length; ++j)
                    object.options[j] = message.options[j];
            }
            return object;
        };

        /**
         * Converts this Dropdown to JSON.
         * @function toJSON
         * @memberof proto.Dropdown
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Dropdown.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Dropdown
         * @function getTypeUrl
         * @memberof proto.Dropdown
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Dropdown.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Dropdown";
        };

        return Dropdown;
    })();

    proto.RadioButton = (function() {

        /**
         * Properties of a RadioButton.
         * @memberof proto
         * @interface IRadioButton
         * @property {Array.<string>|null} [options] RadioButton options
         */

        /**
         * Constructs a new RadioButton.
         * @memberof proto
         * @classdesc Represents a RadioButton.
         * @implements IRadioButton
         * @constructor
         * @param {proto.IRadioButton=} [properties] Properties to set
         */
        function RadioButton(properties) {
            this.options = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RadioButton options.
         * @member {Array.<string>} options
         * @memberof proto.RadioButton
         * @instance
         */
        RadioButton.prototype.options = $util.emptyArray;

        /**
         * Creates a new RadioButton instance using the specified properties.
         * @function create
         * @memberof proto.RadioButton
         * @static
         * @param {proto.IRadioButton=} [properties] Properties to set
         * @returns {proto.RadioButton} RadioButton instance
         */
        RadioButton.create = function create(properties) {
            return new RadioButton(properties);
        };

        /**
         * Encodes the specified RadioButton message. Does not implicitly {@link proto.RadioButton.verify|verify} messages.
         * @function encode
         * @memberof proto.RadioButton
         * @static
         * @param {proto.IRadioButton} message RadioButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RadioButton.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && message.options.length)
                for (let i = 0; i < message.options.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.options[i]);
            return writer;
        };

        /**
         * Encodes the specified RadioButton message, length delimited. Does not implicitly {@link proto.RadioButton.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RadioButton
         * @static
         * @param {proto.IRadioButton} message RadioButton message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RadioButton.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RadioButton message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RadioButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RadioButton} RadioButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RadioButton.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RadioButton();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        if (!(message.options && message.options.length))
                            message.options = [];
                        message.options.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RadioButton message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RadioButton
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RadioButton} RadioButton
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RadioButton.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RadioButton message.
         * @function verify
         * @memberof proto.RadioButton
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RadioButton.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                if (!Array.isArray(message.options))
                    return "options: array expected";
                for (let i = 0; i < message.options.length; ++i)
                    if (!$util.isString(message.options[i]))
                        return "options: string[] expected";
            }
            return null;
        };

        /**
         * Creates a RadioButton message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RadioButton
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RadioButton} RadioButton
         */
        RadioButton.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RadioButton)
                return object;
            let message = new $root.proto.RadioButton();
            if (object.options) {
                if (!Array.isArray(object.options))
                    throw TypeError(".proto.RadioButton.options: array expected");
                message.options = [];
                for (let i = 0; i < object.options.length; ++i)
                    message.options[i] = String(object.options[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a RadioButton message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RadioButton
         * @static
         * @param {proto.RadioButton} message RadioButton
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RadioButton.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.options = [];
            if (message.options && message.options.length) {
                object.options = [];
                for (let j = 0; j < message.options.length; ++j)
                    object.options[j] = message.options[j];
            }
            return object;
        };

        /**
         * Converts this RadioButton to JSON.
         * @function toJSON
         * @memberof proto.RadioButton
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RadioButton.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RadioButton
         * @function getTypeUrl
         * @memberof proto.RadioButton
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RadioButton.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RadioButton";
        };

        return RadioButton;
    })();

    proto.TextField = (function() {

        /**
         * Properties of a TextField.
         * @memberof proto
         * @interface ITextField
         * @property {string|null} [text] TextField text
         */

        /**
         * Constructs a new TextField.
         * @memberof proto
         * @classdesc Represents a TextField.
         * @implements ITextField
         * @constructor
         * @param {proto.ITextField=} [properties] Properties to set
         */
        function TextField(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TextField text.
         * @member {string} text
         * @memberof proto.TextField
         * @instance
         */
        TextField.prototype.text = "";

        /**
         * Creates a new TextField instance using the specified properties.
         * @function create
         * @memberof proto.TextField
         * @static
         * @param {proto.ITextField=} [properties] Properties to set
         * @returns {proto.TextField} TextField instance
         */
        TextField.create = function create(properties) {
            return new TextField(properties);
        };

        /**
         * Encodes the specified TextField message. Does not implicitly {@link proto.TextField.verify|verify} messages.
         * @function encode
         * @memberof proto.TextField
         * @static
         * @param {proto.ITextField} message TextField message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextField.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
            return writer;
        };

        /**
         * Encodes the specified TextField message, length delimited. Does not implicitly {@link proto.TextField.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TextField
         * @static
         * @param {proto.ITextField} message TextField message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextField.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TextField message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TextField
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TextField} TextField
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextField.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TextField();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.text = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TextField message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TextField
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TextField} TextField
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextField.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TextField message.
         * @function verify
         * @memberof proto.TextField
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TextField.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            return null;
        };

        /**
         * Creates a TextField message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TextField
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TextField} TextField
         */
        TextField.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TextField)
                return object;
            let message = new $root.proto.TextField();
            if (object.text != null)
                message.text = String(object.text);
            return message;
        };

        /**
         * Creates a plain object from a TextField message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TextField
         * @static
         * @param {proto.TextField} message TextField
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TextField.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.text = "";
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            return object;
        };

        /**
         * Converts this TextField to JSON.
         * @function toJSON
         * @memberof proto.TextField
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TextField.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TextField
         * @function getTypeUrl
         * @memberof proto.TextField
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TextField.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TextField";
        };

        return TextField;
    })();

    proto.UiOptionDeclaration = (function() {

        /**
         * Properties of an UiOptionDeclaration.
         * @memberof proto
         * @interface IUiOptionDeclaration
         * @property {string|null} [path] UiOptionDeclaration path
         * @property {boolean|null} [isMutable] UiOptionDeclaration isMutable
         * @property {string|null} [description] UiOptionDeclaration description
         * @property {proto.ISlider|null} [slider] UiOptionDeclaration slider
         * @property {proto.ICheckbox|null} [checkbox] UiOptionDeclaration checkbox
         * @property {proto.IDropdown|null} [dropdown] UiOptionDeclaration dropdown
         * @property {proto.IRadioButton|null} [radiobutton] UiOptionDeclaration radiobutton
         * @property {proto.ITextField|null} [textfield] UiOptionDeclaration textfield
         * @property {proto.IUiValue|null} ["default"] UiOptionDeclaration default
         */

        /**
         * Constructs a new UiOptionDeclaration.
         * @memberof proto
         * @classdesc Represents an UiOptionDeclaration.
         * @implements IUiOptionDeclaration
         * @constructor
         * @param {proto.IUiOptionDeclaration=} [properties] Properties to set
         */
        function UiOptionDeclaration(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UiOptionDeclaration path.
         * @member {string} path
         * @memberof proto.UiOptionDeclaration
         * @instance
         */
        UiOptionDeclaration.prototype.path = "";

        /**
         * UiOptionDeclaration isMutable.
         * @member {boolean} isMutable
         * @memberof proto.UiOptionDeclaration
         * @instance
         */
        UiOptionDeclaration.prototype.isMutable = false;

        /**
         * UiOptionDeclaration description.
         * @member {string} description
         * @memberof proto.UiOptionDeclaration
         * @instance
         */
        UiOptionDeclaration.prototype.description = "";

        /**
         * UiOptionDeclaration slider.
         * @member {proto.ISlider|null|undefined} slider
         * @memberof proto.UiOptionDeclaration
         * @instance
         */
        UiOptionDeclaration.prototype.slider = null;

        /**
         * UiOptionDeclaration checkbox.
         * @member {proto.ICheckbox|null|undefined} checkbox
         * @memberof proto.UiOptionDeclaration
         * @instance
         */
        UiOptionDeclaration.prototype.checkbox = null;

        /**
         * UiOptionDeclaration dropdown.
         * @member {proto.IDropdown|null|undefined} dropdown
         * @memberof proto.UiOptionDeclaration
         * @instance
         */
        UiOptionDeclaration.prototype.dropdown = null;

        /**
         * UiOptionDeclaration radiobutton.
         * @member {proto.IRadioButton|null|undefined} radiobutton
         * @memberof proto.UiOptionDeclaration
         * @instance
         */
        UiOptionDeclaration.prototype.radiobutton = null;

        /**
         * UiOptionDeclaration textfield.
         * @member {proto.ITextField|null|undefined} textfield
         * @memberof proto.UiOptionDeclaration
         * @instance
         */
        UiOptionDeclaration.prototype.textfield = null;

        /**
         * UiOptionDeclaration default.
         * @member {proto.IUiValue|null|undefined} default
         * @memberof proto.UiOptionDeclaration
         * @instance
         */
        UiOptionDeclaration.prototype["default"] = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * UiOptionDeclaration uiElements.
         * @member {"slider"|"checkbox"|"dropdown"|"radiobutton"|"textfield"|undefined} uiElements
         * @memberof proto.UiOptionDeclaration
         * @instance
         */
        Object.defineProperty(UiOptionDeclaration.prototype, "uiElements", {
            get: $util.oneOfGetter($oneOfFields = ["slider", "checkbox", "dropdown", "radiobutton", "textfield"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new UiOptionDeclaration instance using the specified properties.
         * @function create
         * @memberof proto.UiOptionDeclaration
         * @static
         * @param {proto.IUiOptionDeclaration=} [properties] Properties to set
         * @returns {proto.UiOptionDeclaration} UiOptionDeclaration instance
         */
        UiOptionDeclaration.create = function create(properties) {
            return new UiOptionDeclaration(properties);
        };

        /**
         * Encodes the specified UiOptionDeclaration message. Does not implicitly {@link proto.UiOptionDeclaration.verify|verify} messages.
         * @function encode
         * @memberof proto.UiOptionDeclaration
         * @static
         * @param {proto.IUiOptionDeclaration} message UiOptionDeclaration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiOptionDeclaration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
            if (message.isMutable != null && Object.hasOwnProperty.call(message, "isMutable"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isMutable);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
            if (message.slider != null && Object.hasOwnProperty.call(message, "slider"))
                $root.proto.Slider.encode(message.slider, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.checkbox != null && Object.hasOwnProperty.call(message, "checkbox"))
                $root.proto.Checkbox.encode(message.checkbox, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.dropdown != null && Object.hasOwnProperty.call(message, "dropdown"))
                $root.proto.Dropdown.encode(message.dropdown, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.radiobutton != null && Object.hasOwnProperty.call(message, "radiobutton"))
                $root.proto.RadioButton.encode(message.radiobutton, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.textfield != null && Object.hasOwnProperty.call(message, "textfield"))
                $root.proto.TextField.encode(message.textfield, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message["default"] != null && Object.hasOwnProperty.call(message, "default"))
                $root.proto.UiValue.encode(message["default"], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UiOptionDeclaration message, length delimited. Does not implicitly {@link proto.UiOptionDeclaration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.UiOptionDeclaration
         * @static
         * @param {proto.IUiOptionDeclaration} message UiOptionDeclaration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiOptionDeclaration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UiOptionDeclaration message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UiOptionDeclaration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UiOptionDeclaration} UiOptionDeclaration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiOptionDeclaration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UiOptionDeclaration();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.path = reader.string();
                        break;
                    }
                case 2: {
                        message.isMutable = reader.bool();
                        break;
                    }
                case 3: {
                        message.description = reader.string();
                        break;
                    }
                case 4: {
                        message.slider = $root.proto.Slider.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.checkbox = $root.proto.Checkbox.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.dropdown = $root.proto.Dropdown.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.radiobutton = $root.proto.RadioButton.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.textfield = $root.proto.TextField.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message["default"] = $root.proto.UiValue.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UiOptionDeclaration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.UiOptionDeclaration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.UiOptionDeclaration} UiOptionDeclaration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiOptionDeclaration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UiOptionDeclaration message.
         * @function verify
         * @memberof proto.UiOptionDeclaration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UiOptionDeclaration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.path != null && message.hasOwnProperty("path"))
                if (!$util.isString(message.path))
                    return "path: string expected";
            if (message.isMutable != null && message.hasOwnProperty("isMutable"))
                if (typeof message.isMutable !== "boolean")
                    return "isMutable: boolean expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.slider != null && message.hasOwnProperty("slider")) {
                properties.uiElements = 1;
                {
                    let error = $root.proto.Slider.verify(message.slider);
                    if (error)
                        return "slider." + error;
                }
            }
            if (message.checkbox != null && message.hasOwnProperty("checkbox")) {
                if (properties.uiElements === 1)
                    return "uiElements: multiple values";
                properties.uiElements = 1;
                {
                    let error = $root.proto.Checkbox.verify(message.checkbox);
                    if (error)
                        return "checkbox." + error;
                }
            }
            if (message.dropdown != null && message.hasOwnProperty("dropdown")) {
                if (properties.uiElements === 1)
                    return "uiElements: multiple values";
                properties.uiElements = 1;
                {
                    let error = $root.proto.Dropdown.verify(message.dropdown);
                    if (error)
                        return "dropdown." + error;
                }
            }
            if (message.radiobutton != null && message.hasOwnProperty("radiobutton")) {
                if (properties.uiElements === 1)
                    return "uiElements: multiple values";
                properties.uiElements = 1;
                {
                    let error = $root.proto.RadioButton.verify(message.radiobutton);
                    if (error)
                        return "radiobutton." + error;
                }
            }
            if (message.textfield != null && message.hasOwnProperty("textfield")) {
                if (properties.uiElements === 1)
                    return "uiElements: multiple values";
                properties.uiElements = 1;
                {
                    let error = $root.proto.TextField.verify(message.textfield);
                    if (error)
                        return "textfield." + error;
                }
            }
            if (message["default"] != null && message.hasOwnProperty("default")) {
                let error = $root.proto.UiValue.verify(message["default"]);
                if (error)
                    return "default." + error;
            }
            return null;
        };

        /**
         * Creates an UiOptionDeclaration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.UiOptionDeclaration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.UiOptionDeclaration} UiOptionDeclaration
         */
        UiOptionDeclaration.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.UiOptionDeclaration)
                return object;
            let message = new $root.proto.UiOptionDeclaration();
            if (object.path != null)
                message.path = String(object.path);
            if (object.isMutable != null)
                message.isMutable = Boolean(object.isMutable);
            if (object.description != null)
                message.description = String(object.description);
            if (object.slider != null) {
                if (typeof object.slider !== "object")
                    throw TypeError(".proto.UiOptionDeclaration.slider: object expected");
                message.slider = $root.proto.Slider.fromObject(object.slider);
            }
            if (object.checkbox != null) {
                if (typeof object.checkbox !== "object")
                    throw TypeError(".proto.UiOptionDeclaration.checkbox: object expected");
                message.checkbox = $root.proto.Checkbox.fromObject(object.checkbox);
            }
            if (object.dropdown != null) {
                if (typeof object.dropdown !== "object")
                    throw TypeError(".proto.UiOptionDeclaration.dropdown: object expected");
                message.dropdown = $root.proto.Dropdown.fromObject(object.dropdown);
            }
            if (object.radiobutton != null) {
                if (typeof object.radiobutton !== "object")
                    throw TypeError(".proto.UiOptionDeclaration.radiobutton: object expected");
                message.radiobutton = $root.proto.RadioButton.fromObject(object.radiobutton);
            }
            if (object.textfield != null) {
                if (typeof object.textfield !== "object")
                    throw TypeError(".proto.UiOptionDeclaration.textfield: object expected");
                message.textfield = $root.proto.TextField.fromObject(object.textfield);
            }
            if (object["default"] != null) {
                if (typeof object["default"] !== "object")
                    throw TypeError(".proto.UiOptionDeclaration.default: object expected");
                message["default"] = $root.proto.UiValue.fromObject(object["default"]);
            }
            return message;
        };

        /**
         * Creates a plain object from an UiOptionDeclaration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.UiOptionDeclaration
         * @static
         * @param {proto.UiOptionDeclaration} message UiOptionDeclaration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UiOptionDeclaration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.path = "";
                object.isMutable = false;
                object.description = "";
                object["default"] = null;
            }
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = message.path;
            if (message.isMutable != null && message.hasOwnProperty("isMutable"))
                object.isMutable = message.isMutable;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.slider != null && message.hasOwnProperty("slider")) {
                object.slider = $root.proto.Slider.toObject(message.slider, options);
                if (options.oneofs)
                    object.uiElements = "slider";
            }
            if (message.checkbox != null && message.hasOwnProperty("checkbox")) {
                object.checkbox = $root.proto.Checkbox.toObject(message.checkbox, options);
                if (options.oneofs)
                    object.uiElements = "checkbox";
            }
            if (message.dropdown != null && message.hasOwnProperty("dropdown")) {
                object.dropdown = $root.proto.Dropdown.toObject(message.dropdown, options);
                if (options.oneofs)
                    object.uiElements = "dropdown";
            }
            if (message.radiobutton != null && message.hasOwnProperty("radiobutton")) {
                object.radiobutton = $root.proto.RadioButton.toObject(message.radiobutton, options);
                if (options.oneofs)
                    object.uiElements = "radiobutton";
            }
            if (message.textfield != null && message.hasOwnProperty("textfield")) {
                object.textfield = $root.proto.TextField.toObject(message.textfield, options);
                if (options.oneofs)
                    object.uiElements = "textfield";
            }
            if (message["default"] != null && message.hasOwnProperty("default"))
                object["default"] = $root.proto.UiValue.toObject(message["default"], options);
            return object;
        };

        /**
         * Converts this UiOptionDeclaration to JSON.
         * @function toJSON
         * @memberof proto.UiOptionDeclaration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UiOptionDeclaration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UiOptionDeclaration
         * @function getTypeUrl
         * @memberof proto.UiOptionDeclaration
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UiOptionDeclaration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.UiOptionDeclaration";
        };

        return UiOptionDeclaration;
    })();

    proto.UiOptionDeclarations = (function() {

        /**
         * Properties of an UiOptionDeclarations.
         * @memberof proto
         * @interface IUiOptionDeclarations
         * @property {Array.<proto.IUiOptionDeclaration>|null} [options] UiOptionDeclarations options
         */

        /**
         * Constructs a new UiOptionDeclarations.
         * @memberof proto
         * @classdesc Represents an UiOptionDeclarations.
         * @implements IUiOptionDeclarations
         * @constructor
         * @param {proto.IUiOptionDeclarations=} [properties] Properties to set
         */
        function UiOptionDeclarations(properties) {
            this.options = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UiOptionDeclarations options.
         * @member {Array.<proto.IUiOptionDeclaration>} options
         * @memberof proto.UiOptionDeclarations
         * @instance
         */
        UiOptionDeclarations.prototype.options = $util.emptyArray;

        /**
         * Creates a new UiOptionDeclarations instance using the specified properties.
         * @function create
         * @memberof proto.UiOptionDeclarations
         * @static
         * @param {proto.IUiOptionDeclarations=} [properties] Properties to set
         * @returns {proto.UiOptionDeclarations} UiOptionDeclarations instance
         */
        UiOptionDeclarations.create = function create(properties) {
            return new UiOptionDeclarations(properties);
        };

        /**
         * Encodes the specified UiOptionDeclarations message. Does not implicitly {@link proto.UiOptionDeclarations.verify|verify} messages.
         * @function encode
         * @memberof proto.UiOptionDeclarations
         * @static
         * @param {proto.IUiOptionDeclarations} message UiOptionDeclarations message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiOptionDeclarations.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.options != null && message.options.length)
                for (let i = 0; i < message.options.length; ++i)
                    $root.proto.UiOptionDeclaration.encode(message.options[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UiOptionDeclarations message, length delimited. Does not implicitly {@link proto.UiOptionDeclarations.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.UiOptionDeclarations
         * @static
         * @param {proto.IUiOptionDeclarations} message UiOptionDeclarations message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiOptionDeclarations.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UiOptionDeclarations message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UiOptionDeclarations
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UiOptionDeclarations} UiOptionDeclarations
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiOptionDeclarations.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UiOptionDeclarations();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.options && message.options.length))
                            message.options = [];
                        message.options.push($root.proto.UiOptionDeclaration.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UiOptionDeclarations message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.UiOptionDeclarations
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.UiOptionDeclarations} UiOptionDeclarations
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiOptionDeclarations.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UiOptionDeclarations message.
         * @function verify
         * @memberof proto.UiOptionDeclarations
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UiOptionDeclarations.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.options != null && message.hasOwnProperty("options")) {
                if (!Array.isArray(message.options))
                    return "options: array expected";
                for (let i = 0; i < message.options.length; ++i) {
                    let error = $root.proto.UiOptionDeclaration.verify(message.options[i]);
                    if (error)
                        return "options." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UiOptionDeclarations message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.UiOptionDeclarations
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.UiOptionDeclarations} UiOptionDeclarations
         */
        UiOptionDeclarations.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.UiOptionDeclarations)
                return object;
            let message = new $root.proto.UiOptionDeclarations();
            if (object.options) {
                if (!Array.isArray(object.options))
                    throw TypeError(".proto.UiOptionDeclarations.options: array expected");
                message.options = [];
                for (let i = 0; i < object.options.length; ++i) {
                    if (typeof object.options[i] !== "object")
                        throw TypeError(".proto.UiOptionDeclarations.options: object expected");
                    message.options[i] = $root.proto.UiOptionDeclaration.fromObject(object.options[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UiOptionDeclarations message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.UiOptionDeclarations
         * @static
         * @param {proto.UiOptionDeclarations} message UiOptionDeclarations
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UiOptionDeclarations.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.options = [];
            if (message.options && message.options.length) {
                object.options = [];
                for (let j = 0; j < message.options.length; ++j)
                    object.options[j] = $root.proto.UiOptionDeclaration.toObject(message.options[j], options);
            }
            return object;
        };

        /**
         * Converts this UiOptionDeclarations to JSON.
         * @function toJSON
         * @memberof proto.UiOptionDeclarations
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UiOptionDeclarations.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UiOptionDeclarations
         * @function getTypeUrl
         * @memberof proto.UiOptionDeclarations
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UiOptionDeclarations.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.UiOptionDeclarations";
        };

        return UiOptionDeclarations;
    })();

    proto.UiValue = (function() {

        /**
         * Properties of an UiValue.
         * @memberof proto
         * @interface IUiValue
         * @property {number|null} [floatValue] UiValue floatValue
         * @property {boolean|null} [boolValue] UiValue boolValue
         * @property {number|Long|null} [integerValue] UiValue integerValue
         * @property {string|null} [textValue] UiValue textValue
         */

        /**
         * Constructs a new UiValue.
         * @memberof proto
         * @classdesc Represents an UiValue.
         * @implements IUiValue
         * @constructor
         * @param {proto.IUiValue=} [properties] Properties to set
         */
        function UiValue(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UiValue floatValue.
         * @member {number|null|undefined} floatValue
         * @memberof proto.UiValue
         * @instance
         */
        UiValue.prototype.floatValue = null;

        /**
         * UiValue boolValue.
         * @member {boolean|null|undefined} boolValue
         * @memberof proto.UiValue
         * @instance
         */
        UiValue.prototype.boolValue = null;

        /**
         * UiValue integerValue.
         * @member {number|Long|null|undefined} integerValue
         * @memberof proto.UiValue
         * @instance
         */
        UiValue.prototype.integerValue = null;

        /**
         * UiValue textValue.
         * @member {string|null|undefined} textValue
         * @memberof proto.UiValue
         * @instance
         */
        UiValue.prototype.textValue = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * UiValue value.
         * @member {"floatValue"|"boolValue"|"integerValue"|"textValue"|undefined} value
         * @memberof proto.UiValue
         * @instance
         */
        Object.defineProperty(UiValue.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["floatValue", "boolValue", "integerValue", "textValue"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new UiValue instance using the specified properties.
         * @function create
         * @memberof proto.UiValue
         * @static
         * @param {proto.IUiValue=} [properties] Properties to set
         * @returns {proto.UiValue} UiValue instance
         */
        UiValue.create = function create(properties) {
            return new UiValue(properties);
        };

        /**
         * Encodes the specified UiValue message. Does not implicitly {@link proto.UiValue.verify|verify} messages.
         * @function encode
         * @memberof proto.UiValue
         * @static
         * @param {proto.IUiValue} message UiValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.floatValue != null && Object.hasOwnProperty.call(message, "floatValue"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.floatValue);
            if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.boolValue);
            if (message.integerValue != null && Object.hasOwnProperty.call(message, "integerValue"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.integerValue);
            if (message.textValue != null && Object.hasOwnProperty.call(message, "textValue"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.textValue);
            return writer;
        };

        /**
         * Encodes the specified UiValue message, length delimited. Does not implicitly {@link proto.UiValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.UiValue
         * @static
         * @param {proto.IUiValue} message UiValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UiValue message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UiValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UiValue} UiValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UiValue();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.floatValue = reader.float();
                        break;
                    }
                case 2: {
                        message.boolValue = reader.bool();
                        break;
                    }
                case 3: {
                        message.integerValue = reader.int64();
                        break;
                    }
                case 4: {
                        message.textValue = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UiValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.UiValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.UiValue} UiValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UiValue message.
         * @function verify
         * @memberof proto.UiValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UiValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                properties.value = 1;
                if (typeof message.floatValue !== "number")
                    return "floatValue: number expected";
            }
            if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (typeof message.boolValue !== "boolean")
                    return "boolValue: boolean expected";
            }
            if (message.integerValue != null && message.hasOwnProperty("integerValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.integerValue) && !(message.integerValue && $util.isInteger(message.integerValue.low) && $util.isInteger(message.integerValue.high)))
                    return "integerValue: integer|Long expected";
            }
            if (message.textValue != null && message.hasOwnProperty("textValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isString(message.textValue))
                    return "textValue: string expected";
            }
            return null;
        };

        /**
         * Creates an UiValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.UiValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.UiValue} UiValue
         */
        UiValue.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.UiValue)
                return object;
            let message = new $root.proto.UiValue();
            if (object.floatValue != null)
                message.floatValue = Number(object.floatValue);
            if (object.boolValue != null)
                message.boolValue = Boolean(object.boolValue);
            if (object.integerValue != null)
                if ($util.Long)
                    (message.integerValue = $util.Long.fromValue(object.integerValue)).unsigned = false;
                else if (typeof object.integerValue === "string")
                    message.integerValue = parseInt(object.integerValue, 10);
                else if (typeof object.integerValue === "number")
                    message.integerValue = object.integerValue;
                else if (typeof object.integerValue === "object")
                    message.integerValue = new $util.LongBits(object.integerValue.low >>> 0, object.integerValue.high >>> 0).toNumber();
            if (object.textValue != null)
                message.textValue = String(object.textValue);
            return message;
        };

        /**
         * Creates a plain object from an UiValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.UiValue
         * @static
         * @param {proto.UiValue} message UiValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UiValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                object.floatValue = options.json && !isFinite(message.floatValue) ? String(message.floatValue) : message.floatValue;
                if (options.oneofs)
                    object.value = "floatValue";
            }
            if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                object.boolValue = message.boolValue;
                if (options.oneofs)
                    object.value = "boolValue";
            }
            if (message.integerValue != null && message.hasOwnProperty("integerValue")) {
                if (typeof message.integerValue === "number")
                    object.integerValue = options.longs === String ? String(message.integerValue) : message.integerValue;
                else
                    object.integerValue = options.longs === String ? $util.Long.prototype.toString.call(message.integerValue) : options.longs === Number ? new $util.LongBits(message.integerValue.low >>> 0, message.integerValue.high >>> 0).toNumber() : message.integerValue;
                if (options.oneofs)
                    object.value = "integerValue";
            }
            if (message.textValue != null && message.hasOwnProperty("textValue")) {
                object.textValue = message.textValue;
                if (options.oneofs)
                    object.value = "textValue";
            }
            return object;
        };

        /**
         * Converts this UiValue to JSON.
         * @function toJSON
         * @memberof proto.UiValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UiValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UiValue
         * @function getTypeUrl
         * @memberof proto.UiValue
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UiValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.UiValue";
        };

        return UiValue;
    })();

    proto.UiValues = (function() {

        /**
         * Properties of an UiValues.
         * @memberof proto
         * @interface IUiValues
         * @property {Object.<string,proto.IUiValue>|null} [uiValues] UiValues uiValues
         */

        /**
         * Constructs a new UiValues.
         * @memberof proto
         * @classdesc Represents an UiValues.
         * @implements IUiValues
         * @constructor
         * @param {proto.IUiValues=} [properties] Properties to set
         */
        function UiValues(properties) {
            this.uiValues = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UiValues uiValues.
         * @member {Object.<string,proto.IUiValue>} uiValues
         * @memberof proto.UiValues
         * @instance
         */
        UiValues.prototype.uiValues = $util.emptyObject;

        /**
         * Creates a new UiValues instance using the specified properties.
         * @function create
         * @memberof proto.UiValues
         * @static
         * @param {proto.IUiValues=} [properties] Properties to set
         * @returns {proto.UiValues} UiValues instance
         */
        UiValues.create = function create(properties) {
            return new UiValues(properties);
        };

        /**
         * Encodes the specified UiValues message. Does not implicitly {@link proto.UiValues.verify|verify} messages.
         * @function encode
         * @memberof proto.UiValues
         * @static
         * @param {proto.IUiValues} message UiValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiValues.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uiValues != null && Object.hasOwnProperty.call(message, "uiValues"))
                for (let keys = Object.keys(message.uiValues), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.proto.UiValue.encode(message.uiValues[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };

        /**
         * Encodes the specified UiValues message, length delimited. Does not implicitly {@link proto.UiValues.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.UiValues
         * @static
         * @param {proto.IUiValues} message UiValues message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UiValues.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UiValues message from the specified reader or buffer.
         * @function decode
         * @memberof proto.UiValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.UiValues} UiValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiValues.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.UiValues(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (message.uiValues === $util.emptyObject)
                            message.uiValues = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.proto.UiValue.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.uiValues[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UiValues message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.UiValues
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.UiValues} UiValues
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UiValues.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UiValues message.
         * @function verify
         * @memberof proto.UiValues
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UiValues.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uiValues != null && message.hasOwnProperty("uiValues")) {
                if (!$util.isObject(message.uiValues))
                    return "uiValues: object expected";
                let key = Object.keys(message.uiValues);
                for (let i = 0; i < key.length; ++i) {
                    let error = $root.proto.UiValue.verify(message.uiValues[key[i]]);
                    if (error)
                        return "uiValues." + error;
                }
            }
            return null;
        };

        /**
         * Creates an UiValues message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.UiValues
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.UiValues} UiValues
         */
        UiValues.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.UiValues)
                return object;
            let message = new $root.proto.UiValues();
            if (object.uiValues) {
                if (typeof object.uiValues !== "object")
                    throw TypeError(".proto.UiValues.uiValues: object expected");
                message.uiValues = {};
                for (let keys = Object.keys(object.uiValues), i = 0; i < keys.length; ++i) {
                    if (typeof object.uiValues[keys[i]] !== "object")
                        throw TypeError(".proto.UiValues.uiValues: object expected");
                    message.uiValues[keys[i]] = $root.proto.UiValue.fromObject(object.uiValues[keys[i]]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an UiValues message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.UiValues
         * @static
         * @param {proto.UiValues} message UiValues
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UiValues.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.uiValues = {};
            let keys2;
            if (message.uiValues && (keys2 = Object.keys(message.uiValues)).length) {
                object.uiValues = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.uiValues[keys2[j]] = $root.proto.UiValue.toObject(message.uiValues[keys2[j]], options);
            }
            return object;
        };

        /**
         * Converts this UiValues to JSON.
         * @function toJSON
         * @memberof proto.UiValues
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UiValues.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UiValues
         * @function getTypeUrl
         * @memberof proto.UiValues
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UiValues.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.UiValues";
        };

        return UiValues;
    })();

    proto.SSL_DetectionBall = (function() {

        /**
         * Properties of a SSL_DetectionBall.
         * @memberof proto
         * @interface ISSL_DetectionBall
         * @property {number} confidence SSL_DetectionBall confidence
         * @property {number|null} [area] SSL_DetectionBall area
         * @property {number} x SSL_DetectionBall x
         * @property {number} y SSL_DetectionBall y
         * @property {number|null} [z] SSL_DetectionBall z
         * @property {number} pixelX SSL_DetectionBall pixelX
         * @property {number} pixelY SSL_DetectionBall pixelY
         */

        /**
         * Constructs a new SSL_DetectionBall.
         * @memberof proto
         * @classdesc Represents a SSL_DetectionBall.
         * @implements ISSL_DetectionBall
         * @constructor
         * @param {proto.ISSL_DetectionBall=} [properties] Properties to set
         */
        function SSL_DetectionBall(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SSL_DetectionBall confidence.
         * @member {number} confidence
         * @memberof proto.SSL_DetectionBall
         * @instance
         */
        SSL_DetectionBall.prototype.confidence = 0;

        /**
         * SSL_DetectionBall area.
         * @member {number} area
         * @memberof proto.SSL_DetectionBall
         * @instance
         */
        SSL_DetectionBall.prototype.area = 0;

        /**
         * SSL_DetectionBall x.
         * @member {number} x
         * @memberof proto.SSL_DetectionBall
         * @instance
         */
        SSL_DetectionBall.prototype.x = 0;

        /**
         * SSL_DetectionBall y.
         * @member {number} y
         * @memberof proto.SSL_DetectionBall
         * @instance
         */
        SSL_DetectionBall.prototype.y = 0;

        /**
         * SSL_DetectionBall z.
         * @member {number} z
         * @memberof proto.SSL_DetectionBall
         * @instance
         */
        SSL_DetectionBall.prototype.z = 0;

        /**
         * SSL_DetectionBall pixelX.
         * @member {number} pixelX
         * @memberof proto.SSL_DetectionBall
         * @instance
         */
        SSL_DetectionBall.prototype.pixelX = 0;

        /**
         * SSL_DetectionBall pixelY.
         * @member {number} pixelY
         * @memberof proto.SSL_DetectionBall
         * @instance
         */
        SSL_DetectionBall.prototype.pixelY = 0;

        /**
         * Creates a new SSL_DetectionBall instance using the specified properties.
         * @function create
         * @memberof proto.SSL_DetectionBall
         * @static
         * @param {proto.ISSL_DetectionBall=} [properties] Properties to set
         * @returns {proto.SSL_DetectionBall} SSL_DetectionBall instance
         */
        SSL_DetectionBall.create = function create(properties) {
            return new SSL_DetectionBall(properties);
        };

        /**
         * Encodes the specified SSL_DetectionBall message. Does not implicitly {@link proto.SSL_DetectionBall.verify|verify} messages.
         * @function encode
         * @memberof proto.SSL_DetectionBall
         * @static
         * @param {proto.ISSL_DetectionBall} message SSL_DetectionBall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_DetectionBall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.confidence);
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.area);
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.x);
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.z);
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.pixelX);
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.pixelY);
            return writer;
        };

        /**
         * Encodes the specified SSL_DetectionBall message, length delimited. Does not implicitly {@link proto.SSL_DetectionBall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SSL_DetectionBall
         * @static
         * @param {proto.ISSL_DetectionBall} message SSL_DetectionBall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_DetectionBall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SSL_DetectionBall message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SSL_DetectionBall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SSL_DetectionBall} SSL_DetectionBall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_DetectionBall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SSL_DetectionBall();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.confidence = reader.float();
                        break;
                    }
                case 2: {
                        message.area = reader.uint32();
                        break;
                    }
                case 3: {
                        message.x = reader.float();
                        break;
                    }
                case 4: {
                        message.y = reader.float();
                        break;
                    }
                case 5: {
                        message.z = reader.float();
                        break;
                    }
                case 6: {
                        message.pixelX = reader.float();
                        break;
                    }
                case 7: {
                        message.pixelY = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("confidence"))
                throw $util.ProtocolError("missing required 'confidence'", { instance: message });
            if (!message.hasOwnProperty("x"))
                throw $util.ProtocolError("missing required 'x'", { instance: message });
            if (!message.hasOwnProperty("y"))
                throw $util.ProtocolError("missing required 'y'", { instance: message });
            if (!message.hasOwnProperty("pixelX"))
                throw $util.ProtocolError("missing required 'pixelX'", { instance: message });
            if (!message.hasOwnProperty("pixelY"))
                throw $util.ProtocolError("missing required 'pixelY'", { instance: message });
            return message;
        };

        /**
         * Decodes a SSL_DetectionBall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SSL_DetectionBall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SSL_DetectionBall} SSL_DetectionBall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_DetectionBall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SSL_DetectionBall message.
         * @function verify
         * @memberof proto.SSL_DetectionBall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SSL_DetectionBall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.confidence !== "number")
                return "confidence: number expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (typeof message.x !== "number")
                return "x: number expected";
            if (typeof message.y !== "number")
                return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            if (typeof message.pixelX !== "number")
                return "pixelX: number expected";
            if (typeof message.pixelY !== "number")
                return "pixelY: number expected";
            return null;
        };

        /**
         * Creates a SSL_DetectionBall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SSL_DetectionBall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SSL_DetectionBall} SSL_DetectionBall
         */
        SSL_DetectionBall.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SSL_DetectionBall)
                return object;
            let message = new $root.proto.SSL_DetectionBall();
            if (object.confidence != null)
                message.confidence = Number(object.confidence);
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            if (object.pixelX != null)
                message.pixelX = Number(object.pixelX);
            if (object.pixelY != null)
                message.pixelY = Number(object.pixelY);
            return message;
        };

        /**
         * Creates a plain object from a SSL_DetectionBall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SSL_DetectionBall
         * @static
         * @param {proto.SSL_DetectionBall} message SSL_DetectionBall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SSL_DetectionBall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.confidence = 0;
                object.area = 0;
                object.x = 0;
                object.y = 0;
                object.z = 0;
                object.pixelX = 0;
                object.pixelY = 0;
            }
            if (message.confidence != null && message.hasOwnProperty("confidence"))
                object.confidence = options.json && !isFinite(message.confidence) ? String(message.confidence) : message.confidence;
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            if (message.pixelX != null && message.hasOwnProperty("pixelX"))
                object.pixelX = options.json && !isFinite(message.pixelX) ? String(message.pixelX) : message.pixelX;
            if (message.pixelY != null && message.hasOwnProperty("pixelY"))
                object.pixelY = options.json && !isFinite(message.pixelY) ? String(message.pixelY) : message.pixelY;
            return object;
        };

        /**
         * Converts this SSL_DetectionBall to JSON.
         * @function toJSON
         * @memberof proto.SSL_DetectionBall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SSL_DetectionBall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SSL_DetectionBall
         * @function getTypeUrl
         * @memberof proto.SSL_DetectionBall
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SSL_DetectionBall.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SSL_DetectionBall";
        };

        return SSL_DetectionBall;
    })();

    proto.SSL_DetectionRobot = (function() {

        /**
         * Properties of a SSL_DetectionRobot.
         * @memberof proto
         * @interface ISSL_DetectionRobot
         * @property {number} confidence SSL_DetectionRobot confidence
         * @property {number|null} [robotId] SSL_DetectionRobot robotId
         * @property {number} x SSL_DetectionRobot x
         * @property {number} y SSL_DetectionRobot y
         * @property {number|null} [orientation] SSL_DetectionRobot orientation
         * @property {number} pixelX SSL_DetectionRobot pixelX
         * @property {number} pixelY SSL_DetectionRobot pixelY
         * @property {number|null} [height] SSL_DetectionRobot height
         */

        /**
         * Constructs a new SSL_DetectionRobot.
         * @memberof proto
         * @classdesc Represents a SSL_DetectionRobot.
         * @implements ISSL_DetectionRobot
         * @constructor
         * @param {proto.ISSL_DetectionRobot=} [properties] Properties to set
         */
        function SSL_DetectionRobot(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SSL_DetectionRobot confidence.
         * @member {number} confidence
         * @memberof proto.SSL_DetectionRobot
         * @instance
         */
        SSL_DetectionRobot.prototype.confidence = 0;

        /**
         * SSL_DetectionRobot robotId.
         * @member {number} robotId
         * @memberof proto.SSL_DetectionRobot
         * @instance
         */
        SSL_DetectionRobot.prototype.robotId = 0;

        /**
         * SSL_DetectionRobot x.
         * @member {number} x
         * @memberof proto.SSL_DetectionRobot
         * @instance
         */
        SSL_DetectionRobot.prototype.x = 0;

        /**
         * SSL_DetectionRobot y.
         * @member {number} y
         * @memberof proto.SSL_DetectionRobot
         * @instance
         */
        SSL_DetectionRobot.prototype.y = 0;

        /**
         * SSL_DetectionRobot orientation.
         * @member {number} orientation
         * @memberof proto.SSL_DetectionRobot
         * @instance
         */
        SSL_DetectionRobot.prototype.orientation = 0;

        /**
         * SSL_DetectionRobot pixelX.
         * @member {number} pixelX
         * @memberof proto.SSL_DetectionRobot
         * @instance
         */
        SSL_DetectionRobot.prototype.pixelX = 0;

        /**
         * SSL_DetectionRobot pixelY.
         * @member {number} pixelY
         * @memberof proto.SSL_DetectionRobot
         * @instance
         */
        SSL_DetectionRobot.prototype.pixelY = 0;

        /**
         * SSL_DetectionRobot height.
         * @member {number} height
         * @memberof proto.SSL_DetectionRobot
         * @instance
         */
        SSL_DetectionRobot.prototype.height = 0;

        /**
         * Creates a new SSL_DetectionRobot instance using the specified properties.
         * @function create
         * @memberof proto.SSL_DetectionRobot
         * @static
         * @param {proto.ISSL_DetectionRobot=} [properties] Properties to set
         * @returns {proto.SSL_DetectionRobot} SSL_DetectionRobot instance
         */
        SSL_DetectionRobot.create = function create(properties) {
            return new SSL_DetectionRobot(properties);
        };

        /**
         * Encodes the specified SSL_DetectionRobot message. Does not implicitly {@link proto.SSL_DetectionRobot.verify|verify} messages.
         * @function encode
         * @memberof proto.SSL_DetectionRobot
         * @static
         * @param {proto.ISSL_DetectionRobot} message SSL_DetectionRobot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_DetectionRobot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.confidence);
            if (message.robotId != null && Object.hasOwnProperty.call(message, "robotId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.robotId);
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.x);
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.y);
            if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.orientation);
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.pixelX);
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.pixelY);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.height);
            return writer;
        };

        /**
         * Encodes the specified SSL_DetectionRobot message, length delimited. Does not implicitly {@link proto.SSL_DetectionRobot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SSL_DetectionRobot
         * @static
         * @param {proto.ISSL_DetectionRobot} message SSL_DetectionRobot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_DetectionRobot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SSL_DetectionRobot message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SSL_DetectionRobot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SSL_DetectionRobot} SSL_DetectionRobot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_DetectionRobot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SSL_DetectionRobot();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.confidence = reader.float();
                        break;
                    }
                case 2: {
                        message.robotId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.x = reader.float();
                        break;
                    }
                case 4: {
                        message.y = reader.float();
                        break;
                    }
                case 5: {
                        message.orientation = reader.float();
                        break;
                    }
                case 6: {
                        message.pixelX = reader.float();
                        break;
                    }
                case 7: {
                        message.pixelY = reader.float();
                        break;
                    }
                case 8: {
                        message.height = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("confidence"))
                throw $util.ProtocolError("missing required 'confidence'", { instance: message });
            if (!message.hasOwnProperty("x"))
                throw $util.ProtocolError("missing required 'x'", { instance: message });
            if (!message.hasOwnProperty("y"))
                throw $util.ProtocolError("missing required 'y'", { instance: message });
            if (!message.hasOwnProperty("pixelX"))
                throw $util.ProtocolError("missing required 'pixelX'", { instance: message });
            if (!message.hasOwnProperty("pixelY"))
                throw $util.ProtocolError("missing required 'pixelY'", { instance: message });
            return message;
        };

        /**
         * Decodes a SSL_DetectionRobot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SSL_DetectionRobot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SSL_DetectionRobot} SSL_DetectionRobot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_DetectionRobot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SSL_DetectionRobot message.
         * @function verify
         * @memberof proto.SSL_DetectionRobot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SSL_DetectionRobot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.confidence !== "number")
                return "confidence: number expected";
            if (message.robotId != null && message.hasOwnProperty("robotId"))
                if (!$util.isInteger(message.robotId))
                    return "robotId: integer expected";
            if (typeof message.x !== "number")
                return "x: number expected";
            if (typeof message.y !== "number")
                return "y: number expected";
            if (message.orientation != null && message.hasOwnProperty("orientation"))
                if (typeof message.orientation !== "number")
                    return "orientation: number expected";
            if (typeof message.pixelX !== "number")
                return "pixelX: number expected";
            if (typeof message.pixelY !== "number")
                return "pixelY: number expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (typeof message.height !== "number")
                    return "height: number expected";
            return null;
        };

        /**
         * Creates a SSL_DetectionRobot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SSL_DetectionRobot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SSL_DetectionRobot} SSL_DetectionRobot
         */
        SSL_DetectionRobot.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SSL_DetectionRobot)
                return object;
            let message = new $root.proto.SSL_DetectionRobot();
            if (object.confidence != null)
                message.confidence = Number(object.confidence);
            if (object.robotId != null)
                message.robotId = object.robotId >>> 0;
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.orientation != null)
                message.orientation = Number(object.orientation);
            if (object.pixelX != null)
                message.pixelX = Number(object.pixelX);
            if (object.pixelY != null)
                message.pixelY = Number(object.pixelY);
            if (object.height != null)
                message.height = Number(object.height);
            return message;
        };

        /**
         * Creates a plain object from a SSL_DetectionRobot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SSL_DetectionRobot
         * @static
         * @param {proto.SSL_DetectionRobot} message SSL_DetectionRobot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SSL_DetectionRobot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.confidence = 0;
                object.robotId = 0;
                object.x = 0;
                object.y = 0;
                object.orientation = 0;
                object.pixelX = 0;
                object.pixelY = 0;
                object.height = 0;
            }
            if (message.confidence != null && message.hasOwnProperty("confidence"))
                object.confidence = options.json && !isFinite(message.confidence) ? String(message.confidence) : message.confidence;
            if (message.robotId != null && message.hasOwnProperty("robotId"))
                object.robotId = message.robotId;
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.orientation != null && message.hasOwnProperty("orientation"))
                object.orientation = options.json && !isFinite(message.orientation) ? String(message.orientation) : message.orientation;
            if (message.pixelX != null && message.hasOwnProperty("pixelX"))
                object.pixelX = options.json && !isFinite(message.pixelX) ? String(message.pixelX) : message.pixelX;
            if (message.pixelY != null && message.hasOwnProperty("pixelY"))
                object.pixelY = options.json && !isFinite(message.pixelY) ? String(message.pixelY) : message.pixelY;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = options.json && !isFinite(message.height) ? String(message.height) : message.height;
            return object;
        };

        /**
         * Converts this SSL_DetectionRobot to JSON.
         * @function toJSON
         * @memberof proto.SSL_DetectionRobot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SSL_DetectionRobot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SSL_DetectionRobot
         * @function getTypeUrl
         * @memberof proto.SSL_DetectionRobot
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SSL_DetectionRobot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SSL_DetectionRobot";
        };

        return SSL_DetectionRobot;
    })();

    proto.SSL_DetectionFrame = (function() {

        /**
         * Properties of a SSL_DetectionFrame.
         * @memberof proto
         * @interface ISSL_DetectionFrame
         * @property {number} frameNumber SSL_DetectionFrame frameNumber
         * @property {number} tCapture SSL_DetectionFrame tCapture
         * @property {number} tSent SSL_DetectionFrame tSent
         * @property {number} cameraId SSL_DetectionFrame cameraId
         * @property {Array.<proto.ISSL_DetectionBall>|null} [balls] SSL_DetectionFrame balls
         * @property {Array.<proto.ISSL_DetectionRobot>|null} [robotsYellow] SSL_DetectionFrame robotsYellow
         * @property {Array.<proto.ISSL_DetectionRobot>|null} [robotsBlue] SSL_DetectionFrame robotsBlue
         */

        /**
         * Constructs a new SSL_DetectionFrame.
         * @memberof proto
         * @classdesc Represents a SSL_DetectionFrame.
         * @implements ISSL_DetectionFrame
         * @constructor
         * @param {proto.ISSL_DetectionFrame=} [properties] Properties to set
         */
        function SSL_DetectionFrame(properties) {
            this.balls = [];
            this.robotsYellow = [];
            this.robotsBlue = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SSL_DetectionFrame frameNumber.
         * @member {number} frameNumber
         * @memberof proto.SSL_DetectionFrame
         * @instance
         */
        SSL_DetectionFrame.prototype.frameNumber = 0;

        /**
         * SSL_DetectionFrame tCapture.
         * @member {number} tCapture
         * @memberof proto.SSL_DetectionFrame
         * @instance
         */
        SSL_DetectionFrame.prototype.tCapture = 0;

        /**
         * SSL_DetectionFrame tSent.
         * @member {number} tSent
         * @memberof proto.SSL_DetectionFrame
         * @instance
         */
        SSL_DetectionFrame.prototype.tSent = 0;

        /**
         * SSL_DetectionFrame cameraId.
         * @member {number} cameraId
         * @memberof proto.SSL_DetectionFrame
         * @instance
         */
        SSL_DetectionFrame.prototype.cameraId = 0;

        /**
         * SSL_DetectionFrame balls.
         * @member {Array.<proto.ISSL_DetectionBall>} balls
         * @memberof proto.SSL_DetectionFrame
         * @instance
         */
        SSL_DetectionFrame.prototype.balls = $util.emptyArray;

        /**
         * SSL_DetectionFrame robotsYellow.
         * @member {Array.<proto.ISSL_DetectionRobot>} robotsYellow
         * @memberof proto.SSL_DetectionFrame
         * @instance
         */
        SSL_DetectionFrame.prototype.robotsYellow = $util.emptyArray;

        /**
         * SSL_DetectionFrame robotsBlue.
         * @member {Array.<proto.ISSL_DetectionRobot>} robotsBlue
         * @memberof proto.SSL_DetectionFrame
         * @instance
         */
        SSL_DetectionFrame.prototype.robotsBlue = $util.emptyArray;

        /**
         * Creates a new SSL_DetectionFrame instance using the specified properties.
         * @function create
         * @memberof proto.SSL_DetectionFrame
         * @static
         * @param {proto.ISSL_DetectionFrame=} [properties] Properties to set
         * @returns {proto.SSL_DetectionFrame} SSL_DetectionFrame instance
         */
        SSL_DetectionFrame.create = function create(properties) {
            return new SSL_DetectionFrame(properties);
        };

        /**
         * Encodes the specified SSL_DetectionFrame message. Does not implicitly {@link proto.SSL_DetectionFrame.verify|verify} messages.
         * @function encode
         * @memberof proto.SSL_DetectionFrame
         * @static
         * @param {proto.ISSL_DetectionFrame} message SSL_DetectionFrame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_DetectionFrame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.frameNumber);
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.tCapture);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.tSent);
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.cameraId);
            if (message.balls != null && message.balls.length)
                for (let i = 0; i < message.balls.length; ++i)
                    $root.proto.SSL_DetectionBall.encode(message.balls[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.robotsYellow != null && message.robotsYellow.length)
                for (let i = 0; i < message.robotsYellow.length; ++i)
                    $root.proto.SSL_DetectionRobot.encode(message.robotsYellow[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.robotsBlue != null && message.robotsBlue.length)
                for (let i = 0; i < message.robotsBlue.length; ++i)
                    $root.proto.SSL_DetectionRobot.encode(message.robotsBlue[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SSL_DetectionFrame message, length delimited. Does not implicitly {@link proto.SSL_DetectionFrame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SSL_DetectionFrame
         * @static
         * @param {proto.ISSL_DetectionFrame} message SSL_DetectionFrame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_DetectionFrame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SSL_DetectionFrame message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SSL_DetectionFrame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SSL_DetectionFrame} SSL_DetectionFrame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_DetectionFrame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SSL_DetectionFrame();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.frameNumber = reader.uint32();
                        break;
                    }
                case 2: {
                        message.tCapture = reader.double();
                        break;
                    }
                case 3: {
                        message.tSent = reader.double();
                        break;
                    }
                case 4: {
                        message.cameraId = reader.uint32();
                        break;
                    }
                case 5: {
                        if (!(message.balls && message.balls.length))
                            message.balls = [];
                        message.balls.push($root.proto.SSL_DetectionBall.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        if (!(message.robotsYellow && message.robotsYellow.length))
                            message.robotsYellow = [];
                        message.robotsYellow.push($root.proto.SSL_DetectionRobot.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        if (!(message.robotsBlue && message.robotsBlue.length))
                            message.robotsBlue = [];
                        message.robotsBlue.push($root.proto.SSL_DetectionRobot.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("frameNumber"))
                throw $util.ProtocolError("missing required 'frameNumber'", { instance: message });
            if (!message.hasOwnProperty("tCapture"))
                throw $util.ProtocolError("missing required 'tCapture'", { instance: message });
            if (!message.hasOwnProperty("tSent"))
                throw $util.ProtocolError("missing required 'tSent'", { instance: message });
            if (!message.hasOwnProperty("cameraId"))
                throw $util.ProtocolError("missing required 'cameraId'", { instance: message });
            return message;
        };

        /**
         * Decodes a SSL_DetectionFrame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SSL_DetectionFrame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SSL_DetectionFrame} SSL_DetectionFrame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_DetectionFrame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SSL_DetectionFrame message.
         * @function verify
         * @memberof proto.SSL_DetectionFrame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SSL_DetectionFrame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.frameNumber))
                return "frameNumber: integer expected";
            if (typeof message.tCapture !== "number")
                return "tCapture: number expected";
            if (typeof message.tSent !== "number")
                return "tSent: number expected";
            if (!$util.isInteger(message.cameraId))
                return "cameraId: integer expected";
            if (message.balls != null && message.hasOwnProperty("balls")) {
                if (!Array.isArray(message.balls))
                    return "balls: array expected";
                for (let i = 0; i < message.balls.length; ++i) {
                    let error = $root.proto.SSL_DetectionBall.verify(message.balls[i]);
                    if (error)
                        return "balls." + error;
                }
            }
            if (message.robotsYellow != null && message.hasOwnProperty("robotsYellow")) {
                if (!Array.isArray(message.robotsYellow))
                    return "robotsYellow: array expected";
                for (let i = 0; i < message.robotsYellow.length; ++i) {
                    let error = $root.proto.SSL_DetectionRobot.verify(message.robotsYellow[i]);
                    if (error)
                        return "robotsYellow." + error;
                }
            }
            if (message.robotsBlue != null && message.hasOwnProperty("robotsBlue")) {
                if (!Array.isArray(message.robotsBlue))
                    return "robotsBlue: array expected";
                for (let i = 0; i < message.robotsBlue.length; ++i) {
                    let error = $root.proto.SSL_DetectionRobot.verify(message.robotsBlue[i]);
                    if (error)
                        return "robotsBlue." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SSL_DetectionFrame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SSL_DetectionFrame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SSL_DetectionFrame} SSL_DetectionFrame
         */
        SSL_DetectionFrame.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SSL_DetectionFrame)
                return object;
            let message = new $root.proto.SSL_DetectionFrame();
            if (object.frameNumber != null)
                message.frameNumber = object.frameNumber >>> 0;
            if (object.tCapture != null)
                message.tCapture = Number(object.tCapture);
            if (object.tSent != null)
                message.tSent = Number(object.tSent);
            if (object.cameraId != null)
                message.cameraId = object.cameraId >>> 0;
            if (object.balls) {
                if (!Array.isArray(object.balls))
                    throw TypeError(".proto.SSL_DetectionFrame.balls: array expected");
                message.balls = [];
                for (let i = 0; i < object.balls.length; ++i) {
                    if (typeof object.balls[i] !== "object")
                        throw TypeError(".proto.SSL_DetectionFrame.balls: object expected");
                    message.balls[i] = $root.proto.SSL_DetectionBall.fromObject(object.balls[i]);
                }
            }
            if (object.robotsYellow) {
                if (!Array.isArray(object.robotsYellow))
                    throw TypeError(".proto.SSL_DetectionFrame.robotsYellow: array expected");
                message.robotsYellow = [];
                for (let i = 0; i < object.robotsYellow.length; ++i) {
                    if (typeof object.robotsYellow[i] !== "object")
                        throw TypeError(".proto.SSL_DetectionFrame.robotsYellow: object expected");
                    message.robotsYellow[i] = $root.proto.SSL_DetectionRobot.fromObject(object.robotsYellow[i]);
                }
            }
            if (object.robotsBlue) {
                if (!Array.isArray(object.robotsBlue))
                    throw TypeError(".proto.SSL_DetectionFrame.robotsBlue: array expected");
                message.robotsBlue = [];
                for (let i = 0; i < object.robotsBlue.length; ++i) {
                    if (typeof object.robotsBlue[i] !== "object")
                        throw TypeError(".proto.SSL_DetectionFrame.robotsBlue: object expected");
                    message.robotsBlue[i] = $root.proto.SSL_DetectionRobot.fromObject(object.robotsBlue[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SSL_DetectionFrame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SSL_DetectionFrame
         * @static
         * @param {proto.SSL_DetectionFrame} message SSL_DetectionFrame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SSL_DetectionFrame.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.balls = [];
                object.robotsYellow = [];
                object.robotsBlue = [];
            }
            if (options.defaults) {
                object.frameNumber = 0;
                object.tCapture = 0;
                object.tSent = 0;
                object.cameraId = 0;
            }
            if (message.frameNumber != null && message.hasOwnProperty("frameNumber"))
                object.frameNumber = message.frameNumber;
            if (message.tCapture != null && message.hasOwnProperty("tCapture"))
                object.tCapture = options.json && !isFinite(message.tCapture) ? String(message.tCapture) : message.tCapture;
            if (message.tSent != null && message.hasOwnProperty("tSent"))
                object.tSent = options.json && !isFinite(message.tSent) ? String(message.tSent) : message.tSent;
            if (message.cameraId != null && message.hasOwnProperty("cameraId"))
                object.cameraId = message.cameraId;
            if (message.balls && message.balls.length) {
                object.balls = [];
                for (let j = 0; j < message.balls.length; ++j)
                    object.balls[j] = $root.proto.SSL_DetectionBall.toObject(message.balls[j], options);
            }
            if (message.robotsYellow && message.robotsYellow.length) {
                object.robotsYellow = [];
                for (let j = 0; j < message.robotsYellow.length; ++j)
                    object.robotsYellow[j] = $root.proto.SSL_DetectionRobot.toObject(message.robotsYellow[j], options);
            }
            if (message.robotsBlue && message.robotsBlue.length) {
                object.robotsBlue = [];
                for (let j = 0; j < message.robotsBlue.length; ++j)
                    object.robotsBlue[j] = $root.proto.SSL_DetectionRobot.toObject(message.robotsBlue[j], options);
            }
            return object;
        };

        /**
         * Converts this SSL_DetectionFrame to JSON.
         * @function toJSON
         * @memberof proto.SSL_DetectionFrame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SSL_DetectionFrame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SSL_DetectionFrame
         * @function getTypeUrl
         * @memberof proto.SSL_DetectionFrame
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SSL_DetectionFrame.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SSL_DetectionFrame";
        };

        return SSL_DetectionFrame;
    })();

    /**
     * Team enum.
     * @name proto.Team
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} YELLOW=1 YELLOW value
     * @property {number} BLUE=2 BLUE value
     */
    proto.Team = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "YELLOW"] = 1;
        values[valuesById[2] = "BLUE"] = 2;
        return values;
    })();

    proto.RobotId = (function() {

        /**
         * Properties of a RobotId.
         * @memberof proto
         * @interface IRobotId
         * @property {number|null} [id] RobotId id
         * @property {proto.Team|null} [team] RobotId team
         */

        /**
         * Constructs a new RobotId.
         * @memberof proto
         * @classdesc Represents a RobotId.
         * @implements IRobotId
         * @constructor
         * @param {proto.IRobotId=} [properties] Properties to set
         */
        function RobotId(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RobotId id.
         * @member {number} id
         * @memberof proto.RobotId
         * @instance
         */
        RobotId.prototype.id = 0;

        /**
         * RobotId team.
         * @member {proto.Team} team
         * @memberof proto.RobotId
         * @instance
         */
        RobotId.prototype.team = 0;

        /**
         * Creates a new RobotId instance using the specified properties.
         * @function create
         * @memberof proto.RobotId
         * @static
         * @param {proto.IRobotId=} [properties] Properties to set
         * @returns {proto.RobotId} RobotId instance
         */
        RobotId.create = function create(properties) {
            return new RobotId(properties);
        };

        /**
         * Encodes the specified RobotId message. Does not implicitly {@link proto.RobotId.verify|verify} messages.
         * @function encode
         * @memberof proto.RobotId
         * @static
         * @param {proto.IRobotId} message RobotId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.team);
            return writer;
        };

        /**
         * Encodes the specified RobotId message, length delimited. Does not implicitly {@link proto.RobotId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RobotId
         * @static
         * @param {proto.IRobotId} message RobotId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotId.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RobotId message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RobotId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RobotId} RobotId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RobotId();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.team = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RobotId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RobotId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RobotId} RobotId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotId.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RobotId message.
         * @function verify
         * @memberof proto.RobotId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RobotId.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.team != null && message.hasOwnProperty("team"))
                switch (message.team) {
                default:
                    return "team: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a RobotId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RobotId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RobotId} RobotId
         */
        RobotId.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RobotId)
                return object;
            let message = new $root.proto.RobotId();
            if (object.id != null)
                message.id = object.id >>> 0;
            switch (object.team) {
            default:
                if (typeof object.team === "number") {
                    message.team = object.team;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.team = 0;
                break;
            case "YELLOW":
            case 1:
                message.team = 1;
                break;
            case "BLUE":
            case 2:
                message.team = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a RobotId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RobotId
         * @static
         * @param {proto.RobotId} message RobotId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RobotId.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = 0;
                object.team = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.team != null && message.hasOwnProperty("team"))
                object.team = options.enums === String ? $root.proto.Team[message.team] === undefined ? message.team : $root.proto.Team[message.team] : message.team;
            return object;
        };

        /**
         * Converts this RobotId to JSON.
         * @function toJSON
         * @memberof proto.RobotId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RobotId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RobotId
         * @function getTypeUrl
         * @memberof proto.RobotId
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RobotId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RobotId";
        };

        return RobotId;
    })();

    /**
     * Division enum.
     * @name proto.Division
     * @enum {number}
     * @property {number} DIV_UNKNOWN=0 DIV_UNKNOWN value
     * @property {number} DIV_A=1 DIV_A value
     * @property {number} DIV_B=2 DIV_B value
     */
    proto.Division = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DIV_UNKNOWN"] = 0;
        values[valuesById[1] = "DIV_A"] = 1;
        values[valuesById[2] = "DIV_B"] = 2;
        return values;
    })();

    proto.Vector2 = (function() {

        /**
         * Properties of a Vector2.
         * @memberof proto
         * @interface IVector2
         * @property {number} x Vector2 x
         * @property {number} y Vector2 y
         */

        /**
         * Constructs a new Vector2.
         * @memberof proto
         * @classdesc Represents a Vector2.
         * @implements IVector2
         * @constructor
         * @param {proto.IVector2=} [properties] Properties to set
         */
        function Vector2(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vector2 x.
         * @member {number} x
         * @memberof proto.Vector2
         * @instance
         */
        Vector2.prototype.x = 0;

        /**
         * Vector2 y.
         * @member {number} y
         * @memberof proto.Vector2
         * @instance
         */
        Vector2.prototype.y = 0;

        /**
         * Creates a new Vector2 instance using the specified properties.
         * @function create
         * @memberof proto.Vector2
         * @static
         * @param {proto.IVector2=} [properties] Properties to set
         * @returns {proto.Vector2} Vector2 instance
         */
        Vector2.create = function create(properties) {
            return new Vector2(properties);
        };

        /**
         * Encodes the specified Vector2 message. Does not implicitly {@link proto.Vector2.verify|verify} messages.
         * @function encode
         * @memberof proto.Vector2
         * @static
         * @param {proto.IVector2} message Vector2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vector2.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };

        /**
         * Encodes the specified Vector2 message, length delimited. Does not implicitly {@link proto.Vector2.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Vector2
         * @static
         * @param {proto.IVector2} message Vector2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vector2.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vector2 message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Vector2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Vector2} Vector2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vector2.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Vector2();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("x"))
                throw $util.ProtocolError("missing required 'x'", { instance: message });
            if (!message.hasOwnProperty("y"))
                throw $util.ProtocolError("missing required 'y'", { instance: message });
            return message;
        };

        /**
         * Decodes a Vector2 message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Vector2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Vector2} Vector2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vector2.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vector2 message.
         * @function verify
         * @memberof proto.Vector2
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vector2.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.x !== "number")
                return "x: number expected";
            if (typeof message.y !== "number")
                return "y: number expected";
            return null;
        };

        /**
         * Creates a Vector2 message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Vector2
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Vector2} Vector2
         */
        Vector2.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Vector2)
                return object;
            let message = new $root.proto.Vector2();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };

        /**
         * Creates a plain object from a Vector2 message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Vector2
         * @static
         * @param {proto.Vector2} message Vector2
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vector2.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };

        /**
         * Converts this Vector2 to JSON.
         * @function toJSON
         * @memberof proto.Vector2
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vector2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Vector2
         * @function getTypeUrl
         * @memberof proto.Vector2
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Vector2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Vector2";
        };

        return Vector2;
    })();

    proto.Vector3 = (function() {

        /**
         * Properties of a Vector3.
         * @memberof proto
         * @interface IVector3
         * @property {number} x Vector3 x
         * @property {number} y Vector3 y
         * @property {number} z Vector3 z
         */

        /**
         * Constructs a new Vector3.
         * @memberof proto
         * @classdesc Represents a Vector3.
         * @implements IVector3
         * @constructor
         * @param {proto.IVector3=} [properties] Properties to set
         */
        function Vector3(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vector3 x.
         * @member {number} x
         * @memberof proto.Vector3
         * @instance
         */
        Vector3.prototype.x = 0;

        /**
         * Vector3 y.
         * @member {number} y
         * @memberof proto.Vector3
         * @instance
         */
        Vector3.prototype.y = 0;

        /**
         * Vector3 z.
         * @member {number} z
         * @memberof proto.Vector3
         * @instance
         */
        Vector3.prototype.z = 0;

        /**
         * Creates a new Vector3 instance using the specified properties.
         * @function create
         * @memberof proto.Vector3
         * @static
         * @param {proto.IVector3=} [properties] Properties to set
         * @returns {proto.Vector3} Vector3 instance
         */
        Vector3.create = function create(properties) {
            return new Vector3(properties);
        };

        /**
         * Encodes the specified Vector3 message. Does not implicitly {@link proto.Vector3.verify|verify} messages.
         * @function encode
         * @memberof proto.Vector3
         * @static
         * @param {proto.IVector3} message Vector3 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vector3.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            return writer;
        };

        /**
         * Encodes the specified Vector3 message, length delimited. Does not implicitly {@link proto.Vector3.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Vector3
         * @static
         * @param {proto.IVector3} message Vector3 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vector3.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vector3 message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Vector3
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Vector3} Vector3
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vector3.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Vector3();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                case 3: {
                        message.z = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("x"))
                throw $util.ProtocolError("missing required 'x'", { instance: message });
            if (!message.hasOwnProperty("y"))
                throw $util.ProtocolError("missing required 'y'", { instance: message });
            if (!message.hasOwnProperty("z"))
                throw $util.ProtocolError("missing required 'z'", { instance: message });
            return message;
        };

        /**
         * Decodes a Vector3 message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Vector3
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Vector3} Vector3
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vector3.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vector3 message.
         * @function verify
         * @memberof proto.Vector3
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vector3.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (typeof message.x !== "number")
                return "x: number expected";
            if (typeof message.y !== "number")
                return "y: number expected";
            if (typeof message.z !== "number")
                return "z: number expected";
            return null;
        };

        /**
         * Creates a Vector3 message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Vector3
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Vector3} Vector3
         */
        Vector3.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Vector3)
                return object;
            let message = new $root.proto.Vector3();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };

        /**
         * Creates a plain object from a Vector3 message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Vector3
         * @static
         * @param {proto.Vector3} message Vector3
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vector3.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };

        /**
         * Converts this Vector3 to JSON.
         * @function toJSON
         * @memberof proto.Vector3
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vector3.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Vector3
         * @function getTypeUrl
         * @memberof proto.Vector3
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Vector3.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Vector3";
        };

        return Vector3;
    })();

    proto.GameEvent = (function() {

        /**
         * Properties of a GameEvent.
         * @memberof proto
         * @interface IGameEvent
         * @property {proto.GameEvent.Type|null} [type] GameEvent type
         * @property {Array.<string>|null} [origin] GameEvent origin
         * @property {proto.GameEvent.IBallLeftField|null} [ballLeftFieldTouchLine] GameEvent ballLeftFieldTouchLine
         * @property {proto.GameEvent.IBallLeftField|null} [ballLeftFieldGoalLine] GameEvent ballLeftFieldGoalLine
         * @property {proto.GameEvent.IAimlessKick|null} [aimlessKick] GameEvent aimlessKick
         * @property {proto.GameEvent.IAttackerTooCloseToDefenseArea|null} [attackerTooCloseToDefenseArea] GameEvent attackerTooCloseToDefenseArea
         * @property {proto.GameEvent.IDefenderInDefenseArea|null} [defenderInDefenseArea] GameEvent defenderInDefenseArea
         * @property {proto.GameEvent.IBoundaryCrossing|null} [boundaryCrossing] GameEvent boundaryCrossing
         * @property {proto.GameEvent.IKeeperHeldBall|null} [keeperHeldBall] GameEvent keeperHeldBall
         * @property {proto.GameEvent.IBotDribbledBallTooFar|null} [botDribbledBallTooFar] GameEvent botDribbledBallTooFar
         * @property {proto.GameEvent.IBotPushedBot|null} [botPushedBot] GameEvent botPushedBot
         * @property {proto.GameEvent.IBotHeldBallDeliberately|null} [botHeldBallDeliberately] GameEvent botHeldBallDeliberately
         * @property {proto.GameEvent.IBotTippedOver|null} [botTippedOver] GameEvent botTippedOver
         * @property {proto.GameEvent.IAttackerTouchedBallInDefenseArea|null} [attackerTouchedBallInDefenseArea] GameEvent attackerTouchedBallInDefenseArea
         * @property {proto.GameEvent.IBotKickedBallTooFast|null} [botKickedBallTooFast] GameEvent botKickedBallTooFast
         * @property {proto.GameEvent.IBotCrashUnique|null} [botCrashUnique] GameEvent botCrashUnique
         * @property {proto.GameEvent.IBotCrashDrawn|null} [botCrashDrawn] GameEvent botCrashDrawn
         * @property {proto.GameEvent.IDefenderTooCloseToKickPoint|null} [defenderTooCloseToKickPoint] GameEvent defenderTooCloseToKickPoint
         * @property {proto.GameEvent.IBotTooFastInStop|null} [botTooFastInStop] GameEvent botTooFastInStop
         * @property {proto.GameEvent.IBotInterferedPlacement|null} [botInterferedPlacement] GameEvent botInterferedPlacement
         * @property {proto.GameEvent.IGoal|null} [possibleGoal] GameEvent possibleGoal
         * @property {proto.GameEvent.IGoal|null} [goal] GameEvent goal
         * @property {proto.GameEvent.IGoal|null} [invalidGoal] GameEvent invalidGoal
         * @property {proto.GameEvent.IAttackerDoubleTouchedBall|null} [attackerDoubleTouchedBall] GameEvent attackerDoubleTouchedBall
         * @property {proto.GameEvent.IPlacementSucceeded|null} [placementSucceeded] GameEvent placementSucceeded
         * @property {proto.GameEvent.IPenaltyKickFailed|null} [penaltyKickFailed] GameEvent penaltyKickFailed
         * @property {proto.GameEvent.INoProgressInGame|null} [noProgressInGame] GameEvent noProgressInGame
         * @property {proto.GameEvent.IPlacementFailed|null} [placementFailed] GameEvent placementFailed
         * @property {proto.GameEvent.IMultipleCards|null} [multipleCards] GameEvent multipleCards
         * @property {proto.GameEvent.IMultipleFouls|null} [multipleFouls] GameEvent multipleFouls
         * @property {proto.GameEvent.IBotSubstitution|null} [botSubstitution] GameEvent botSubstitution
         * @property {proto.GameEvent.ITooManyRobots|null} [tooManyRobots] GameEvent tooManyRobots
         * @property {proto.GameEvent.IChallengeFlag|null} [challengeFlag] GameEvent challengeFlag
         * @property {proto.GameEvent.IEmergencyStop|null} [emergencyStop] GameEvent emergencyStop
         * @property {proto.GameEvent.IUnsportingBehaviorMinor|null} [unsportingBehaviorMinor] GameEvent unsportingBehaviorMinor
         * @property {proto.GameEvent.IUnsportingBehaviorMajor|null} [unsportingBehaviorMajor] GameEvent unsportingBehaviorMajor
         */

        /**
         * Constructs a new GameEvent.
         * @memberof proto
         * @classdesc Represents a GameEvent.
         * @implements IGameEvent
         * @constructor
         * @param {proto.IGameEvent=} [properties] Properties to set
         */
        function GameEvent(properties) {
            this.origin = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameEvent type.
         * @member {proto.GameEvent.Type} type
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.type = 0;

        /**
         * GameEvent origin.
         * @member {Array.<string>} origin
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.origin = $util.emptyArray;

        /**
         * GameEvent ballLeftFieldTouchLine.
         * @member {proto.GameEvent.IBallLeftField|null|undefined} ballLeftFieldTouchLine
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.ballLeftFieldTouchLine = null;

        /**
         * GameEvent ballLeftFieldGoalLine.
         * @member {proto.GameEvent.IBallLeftField|null|undefined} ballLeftFieldGoalLine
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.ballLeftFieldGoalLine = null;

        /**
         * GameEvent aimlessKick.
         * @member {proto.GameEvent.IAimlessKick|null|undefined} aimlessKick
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.aimlessKick = null;

        /**
         * GameEvent attackerTooCloseToDefenseArea.
         * @member {proto.GameEvent.IAttackerTooCloseToDefenseArea|null|undefined} attackerTooCloseToDefenseArea
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.attackerTooCloseToDefenseArea = null;

        /**
         * GameEvent defenderInDefenseArea.
         * @member {proto.GameEvent.IDefenderInDefenseArea|null|undefined} defenderInDefenseArea
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.defenderInDefenseArea = null;

        /**
         * GameEvent boundaryCrossing.
         * @member {proto.GameEvent.IBoundaryCrossing|null|undefined} boundaryCrossing
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.boundaryCrossing = null;

        /**
         * GameEvent keeperHeldBall.
         * @member {proto.GameEvent.IKeeperHeldBall|null|undefined} keeperHeldBall
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.keeperHeldBall = null;

        /**
         * GameEvent botDribbledBallTooFar.
         * @member {proto.GameEvent.IBotDribbledBallTooFar|null|undefined} botDribbledBallTooFar
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.botDribbledBallTooFar = null;

        /**
         * GameEvent botPushedBot.
         * @member {proto.GameEvent.IBotPushedBot|null|undefined} botPushedBot
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.botPushedBot = null;

        /**
         * GameEvent botHeldBallDeliberately.
         * @member {proto.GameEvent.IBotHeldBallDeliberately|null|undefined} botHeldBallDeliberately
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.botHeldBallDeliberately = null;

        /**
         * GameEvent botTippedOver.
         * @member {proto.GameEvent.IBotTippedOver|null|undefined} botTippedOver
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.botTippedOver = null;

        /**
         * GameEvent attackerTouchedBallInDefenseArea.
         * @member {proto.GameEvent.IAttackerTouchedBallInDefenseArea|null|undefined} attackerTouchedBallInDefenseArea
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.attackerTouchedBallInDefenseArea = null;

        /**
         * GameEvent botKickedBallTooFast.
         * @member {proto.GameEvent.IBotKickedBallTooFast|null|undefined} botKickedBallTooFast
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.botKickedBallTooFast = null;

        /**
         * GameEvent botCrashUnique.
         * @member {proto.GameEvent.IBotCrashUnique|null|undefined} botCrashUnique
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.botCrashUnique = null;

        /**
         * GameEvent botCrashDrawn.
         * @member {proto.GameEvent.IBotCrashDrawn|null|undefined} botCrashDrawn
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.botCrashDrawn = null;

        /**
         * GameEvent defenderTooCloseToKickPoint.
         * @member {proto.GameEvent.IDefenderTooCloseToKickPoint|null|undefined} defenderTooCloseToKickPoint
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.defenderTooCloseToKickPoint = null;

        /**
         * GameEvent botTooFastInStop.
         * @member {proto.GameEvent.IBotTooFastInStop|null|undefined} botTooFastInStop
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.botTooFastInStop = null;

        /**
         * GameEvent botInterferedPlacement.
         * @member {proto.GameEvent.IBotInterferedPlacement|null|undefined} botInterferedPlacement
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.botInterferedPlacement = null;

        /**
         * GameEvent possibleGoal.
         * @member {proto.GameEvent.IGoal|null|undefined} possibleGoal
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.possibleGoal = null;

        /**
         * GameEvent goal.
         * @member {proto.GameEvent.IGoal|null|undefined} goal
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.goal = null;

        /**
         * GameEvent invalidGoal.
         * @member {proto.GameEvent.IGoal|null|undefined} invalidGoal
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.invalidGoal = null;

        /**
         * GameEvent attackerDoubleTouchedBall.
         * @member {proto.GameEvent.IAttackerDoubleTouchedBall|null|undefined} attackerDoubleTouchedBall
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.attackerDoubleTouchedBall = null;

        /**
         * GameEvent placementSucceeded.
         * @member {proto.GameEvent.IPlacementSucceeded|null|undefined} placementSucceeded
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.placementSucceeded = null;

        /**
         * GameEvent penaltyKickFailed.
         * @member {proto.GameEvent.IPenaltyKickFailed|null|undefined} penaltyKickFailed
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.penaltyKickFailed = null;

        /**
         * GameEvent noProgressInGame.
         * @member {proto.GameEvent.INoProgressInGame|null|undefined} noProgressInGame
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.noProgressInGame = null;

        /**
         * GameEvent placementFailed.
         * @member {proto.GameEvent.IPlacementFailed|null|undefined} placementFailed
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.placementFailed = null;

        /**
         * GameEvent multipleCards.
         * @member {proto.GameEvent.IMultipleCards|null|undefined} multipleCards
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.multipleCards = null;

        /**
         * GameEvent multipleFouls.
         * @member {proto.GameEvent.IMultipleFouls|null|undefined} multipleFouls
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.multipleFouls = null;

        /**
         * GameEvent botSubstitution.
         * @member {proto.GameEvent.IBotSubstitution|null|undefined} botSubstitution
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.botSubstitution = null;

        /**
         * GameEvent tooManyRobots.
         * @member {proto.GameEvent.ITooManyRobots|null|undefined} tooManyRobots
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.tooManyRobots = null;

        /**
         * GameEvent challengeFlag.
         * @member {proto.GameEvent.IChallengeFlag|null|undefined} challengeFlag
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.challengeFlag = null;

        /**
         * GameEvent emergencyStop.
         * @member {proto.GameEvent.IEmergencyStop|null|undefined} emergencyStop
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.emergencyStop = null;

        /**
         * GameEvent unsportingBehaviorMinor.
         * @member {proto.GameEvent.IUnsportingBehaviorMinor|null|undefined} unsportingBehaviorMinor
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.unsportingBehaviorMinor = null;

        /**
         * GameEvent unsportingBehaviorMajor.
         * @member {proto.GameEvent.IUnsportingBehaviorMajor|null|undefined} unsportingBehaviorMajor
         * @memberof proto.GameEvent
         * @instance
         */
        GameEvent.prototype.unsportingBehaviorMajor = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * GameEvent event.
         * @member {"ballLeftFieldTouchLine"|"ballLeftFieldGoalLine"|"aimlessKick"|"attackerTooCloseToDefenseArea"|"defenderInDefenseArea"|"boundaryCrossing"|"keeperHeldBall"|"botDribbledBallTooFar"|"botPushedBot"|"botHeldBallDeliberately"|"botTippedOver"|"attackerTouchedBallInDefenseArea"|"botKickedBallTooFast"|"botCrashUnique"|"botCrashDrawn"|"defenderTooCloseToKickPoint"|"botTooFastInStop"|"botInterferedPlacement"|"possibleGoal"|"goal"|"invalidGoal"|"attackerDoubleTouchedBall"|"placementSucceeded"|"penaltyKickFailed"|"noProgressInGame"|"placementFailed"|"multipleCards"|"multipleFouls"|"botSubstitution"|"tooManyRobots"|"challengeFlag"|"emergencyStop"|"unsportingBehaviorMinor"|"unsportingBehaviorMajor"|undefined} event
         * @memberof proto.GameEvent
         * @instance
         */
        Object.defineProperty(GameEvent.prototype, "event", {
            get: $util.oneOfGetter($oneOfFields = ["ballLeftFieldTouchLine", "ballLeftFieldGoalLine", "aimlessKick", "attackerTooCloseToDefenseArea", "defenderInDefenseArea", "boundaryCrossing", "keeperHeldBall", "botDribbledBallTooFar", "botPushedBot", "botHeldBallDeliberately", "botTippedOver", "attackerTouchedBallInDefenseArea", "botKickedBallTooFast", "botCrashUnique", "botCrashDrawn", "defenderTooCloseToKickPoint", "botTooFastInStop", "botInterferedPlacement", "possibleGoal", "goal", "invalidGoal", "attackerDoubleTouchedBall", "placementSucceeded", "penaltyKickFailed", "noProgressInGame", "placementFailed", "multipleCards", "multipleFouls", "botSubstitution", "tooManyRobots", "challengeFlag", "emergencyStop", "unsportingBehaviorMinor", "unsportingBehaviorMajor"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new GameEvent instance using the specified properties.
         * @function create
         * @memberof proto.GameEvent
         * @static
         * @param {proto.IGameEvent=} [properties] Properties to set
         * @returns {proto.GameEvent} GameEvent instance
         */
        GameEvent.create = function create(properties) {
            return new GameEvent(properties);
        };

        /**
         * Encodes the specified GameEvent message. Does not implicitly {@link proto.GameEvent.verify|verify} messages.
         * @function encode
         * @memberof proto.GameEvent
         * @static
         * @param {proto.IGameEvent} message GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.noProgressInGame != null && Object.hasOwnProperty.call(message, "noProgressInGame"))
                $root.proto.GameEvent.NoProgressInGame.encode(message.noProgressInGame, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.placementFailed != null && Object.hasOwnProperty.call(message, "placementFailed"))
                $root.proto.GameEvent.PlacementFailed.encode(message.placementFailed, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.placementSucceeded != null && Object.hasOwnProperty.call(message, "placementSucceeded"))
                $root.proto.GameEvent.PlacementSucceeded.encode(message.placementSucceeded, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.ballLeftFieldTouchLine != null && Object.hasOwnProperty.call(message, "ballLeftFieldTouchLine"))
                $root.proto.GameEvent.BallLeftField.encode(message.ballLeftFieldTouchLine, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.ballLeftFieldGoalLine != null && Object.hasOwnProperty.call(message, "ballLeftFieldGoalLine"))
                $root.proto.GameEvent.BallLeftField.encode(message.ballLeftFieldGoalLine, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.goal != null && Object.hasOwnProperty.call(message, "goal"))
                $root.proto.GameEvent.Goal.encode(message.goal, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.aimlessKick != null && Object.hasOwnProperty.call(message, "aimlessKick"))
                $root.proto.GameEvent.AimlessKick.encode(message.aimlessKick, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.keeperHeldBall != null && Object.hasOwnProperty.call(message, "keeperHeldBall"))
                $root.proto.GameEvent.KeeperHeldBall.encode(message.keeperHeldBall, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.attackerDoubleTouchedBall != null && Object.hasOwnProperty.call(message, "attackerDoubleTouchedBall"))
                $root.proto.GameEvent.AttackerDoubleTouchedBall.encode(message.attackerDoubleTouchedBall, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.attackerTouchedBallInDefenseArea != null && Object.hasOwnProperty.call(message, "attackerTouchedBallInDefenseArea"))
                $root.proto.GameEvent.AttackerTouchedBallInDefenseArea.encode(message.attackerTouchedBallInDefenseArea, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.botDribbledBallTooFar != null && Object.hasOwnProperty.call(message, "botDribbledBallTooFar"))
                $root.proto.GameEvent.BotDribbledBallTooFar.encode(message.botDribbledBallTooFar, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.botKickedBallTooFast != null && Object.hasOwnProperty.call(message, "botKickedBallTooFast"))
                $root.proto.GameEvent.BotKickedBallTooFast.encode(message.botKickedBallTooFast, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.attackerTooCloseToDefenseArea != null && Object.hasOwnProperty.call(message, "attackerTooCloseToDefenseArea"))
                $root.proto.GameEvent.AttackerTooCloseToDefenseArea.encode(message.attackerTooCloseToDefenseArea, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.botInterferedPlacement != null && Object.hasOwnProperty.call(message, "botInterferedPlacement"))
                $root.proto.GameEvent.BotInterferedPlacement.encode(message.botInterferedPlacement, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.botCrashDrawn != null && Object.hasOwnProperty.call(message, "botCrashDrawn"))
                $root.proto.GameEvent.BotCrashDrawn.encode(message.botCrashDrawn, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.botCrashUnique != null && Object.hasOwnProperty.call(message, "botCrashUnique"))
                $root.proto.GameEvent.BotCrashUnique.encode(message.botCrashUnique, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.botPushedBot != null && Object.hasOwnProperty.call(message, "botPushedBot"))
                $root.proto.GameEvent.BotPushedBot.encode(message.botPushedBot, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.botHeldBallDeliberately != null && Object.hasOwnProperty.call(message, "botHeldBallDeliberately"))
                $root.proto.GameEvent.BotHeldBallDeliberately.encode(message.botHeldBallDeliberately, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.botTippedOver != null && Object.hasOwnProperty.call(message, "botTippedOver"))
                $root.proto.GameEvent.BotTippedOver.encode(message.botTippedOver, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.botTooFastInStop != null && Object.hasOwnProperty.call(message, "botTooFastInStop"))
                $root.proto.GameEvent.BotTooFastInStop.encode(message.botTooFastInStop, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.defenderTooCloseToKickPoint != null && Object.hasOwnProperty.call(message, "defenderTooCloseToKickPoint"))
                $root.proto.GameEvent.DefenderTooCloseToKickPoint.encode(message.defenderTooCloseToKickPoint, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
            if (message.defenderInDefenseArea != null && Object.hasOwnProperty.call(message, "defenderInDefenseArea"))
                $root.proto.GameEvent.DefenderInDefenseArea.encode(message.defenderInDefenseArea, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.multipleCards != null && Object.hasOwnProperty.call(message, "multipleCards"))
                $root.proto.GameEvent.MultipleCards.encode(message.multipleCards, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.multipleFouls != null && Object.hasOwnProperty.call(message, "multipleFouls"))
                $root.proto.GameEvent.MultipleFouls.encode(message.multipleFouls, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
            if (message.unsportingBehaviorMinor != null && Object.hasOwnProperty.call(message, "unsportingBehaviorMinor"))
                $root.proto.GameEvent.UnsportingBehaviorMinor.encode(message.unsportingBehaviorMinor, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
            if (message.unsportingBehaviorMajor != null && Object.hasOwnProperty.call(message, "unsportingBehaviorMajor"))
                $root.proto.GameEvent.UnsportingBehaviorMajor.encode(message.unsportingBehaviorMajor, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
            if (message.botSubstitution != null && Object.hasOwnProperty.call(message, "botSubstitution"))
                $root.proto.GameEvent.BotSubstitution.encode(message.botSubstitution, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
            if (message.tooManyRobots != null && Object.hasOwnProperty.call(message, "tooManyRobots"))
                $root.proto.GameEvent.TooManyRobots.encode(message.tooManyRobots, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
            if (message.possibleGoal != null && Object.hasOwnProperty.call(message, "possibleGoal"))
                $root.proto.GameEvent.Goal.encode(message.possibleGoal, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 40, wireType 0 =*/320).int32(message.type);
            if (message.origin != null && message.origin.length)
                for (let i = 0; i < message.origin.length; ++i)
                    writer.uint32(/* id 41, wireType 2 =*/330).string(message.origin[i]);
            if (message.boundaryCrossing != null && Object.hasOwnProperty.call(message, "boundaryCrossing"))
                $root.proto.GameEvent.BoundaryCrossing.encode(message.boundaryCrossing, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
            if (message.invalidGoal != null && Object.hasOwnProperty.call(message, "invalidGoal"))
                $root.proto.GameEvent.Goal.encode(message.invalidGoal, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
            if (message.penaltyKickFailed != null && Object.hasOwnProperty.call(message, "penaltyKickFailed"))
                $root.proto.GameEvent.PenaltyKickFailed.encode(message.penaltyKickFailed, writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
            if (message.challengeFlag != null && Object.hasOwnProperty.call(message, "challengeFlag"))
                $root.proto.GameEvent.ChallengeFlag.encode(message.challengeFlag, writer.uint32(/* id 46, wireType 2 =*/370).fork()).ldelim();
            if (message.emergencyStop != null && Object.hasOwnProperty.call(message, "emergencyStop"))
                $root.proto.GameEvent.EmergencyStop.encode(message.emergencyStop, writer.uint32(/* id 47, wireType 2 =*/378).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GameEvent message, length delimited. Does not implicitly {@link proto.GameEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.GameEvent
         * @static
         * @param {proto.IGameEvent} message GameEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GameEvent message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GameEvent} GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 40: {
                        message.type = reader.int32();
                        break;
                    }
                case 41: {
                        if (!(message.origin && message.origin.length))
                            message.origin = [];
                        message.origin.push(reader.string());
                        break;
                    }
                case 6: {
                        message.ballLeftFieldTouchLine = $root.proto.GameEvent.BallLeftField.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.ballLeftFieldGoalLine = $root.proto.GameEvent.BallLeftField.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.aimlessKick = $root.proto.GameEvent.AimlessKick.decode(reader, reader.uint32());
                        break;
                    }
                case 19: {
                        message.attackerTooCloseToDefenseArea = $root.proto.GameEvent.AttackerTooCloseToDefenseArea.decode(reader, reader.uint32());
                        break;
                    }
                case 31: {
                        message.defenderInDefenseArea = $root.proto.GameEvent.DefenderInDefenseArea.decode(reader, reader.uint32());
                        break;
                    }
                case 43: {
                        message.boundaryCrossing = $root.proto.GameEvent.BoundaryCrossing.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.keeperHeldBall = $root.proto.GameEvent.KeeperHeldBall.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.botDribbledBallTooFar = $root.proto.GameEvent.BotDribbledBallTooFar.decode(reader, reader.uint32());
                        break;
                    }
                case 24: {
                        message.botPushedBot = $root.proto.GameEvent.BotPushedBot.decode(reader, reader.uint32());
                        break;
                    }
                case 26: {
                        message.botHeldBallDeliberately = $root.proto.GameEvent.BotHeldBallDeliberately.decode(reader, reader.uint32());
                        break;
                    }
                case 27: {
                        message.botTippedOver = $root.proto.GameEvent.BotTippedOver.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.attackerTouchedBallInDefenseArea = $root.proto.GameEvent.AttackerTouchedBallInDefenseArea.decode(reader, reader.uint32());
                        break;
                    }
                case 18: {
                        message.botKickedBallTooFast = $root.proto.GameEvent.BotKickedBallTooFast.decode(reader, reader.uint32());
                        break;
                    }
                case 22: {
                        message.botCrashUnique = $root.proto.GameEvent.BotCrashUnique.decode(reader, reader.uint32());
                        break;
                    }
                case 21: {
                        message.botCrashDrawn = $root.proto.GameEvent.BotCrashDrawn.decode(reader, reader.uint32());
                        break;
                    }
                case 29: {
                        message.defenderTooCloseToKickPoint = $root.proto.GameEvent.DefenderTooCloseToKickPoint.decode(reader, reader.uint32());
                        break;
                    }
                case 28: {
                        message.botTooFastInStop = $root.proto.GameEvent.BotTooFastInStop.decode(reader, reader.uint32());
                        break;
                    }
                case 20: {
                        message.botInterferedPlacement = $root.proto.GameEvent.BotInterferedPlacement.decode(reader, reader.uint32());
                        break;
                    }
                case 39: {
                        message.possibleGoal = $root.proto.GameEvent.Goal.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.goal = $root.proto.GameEvent.Goal.decode(reader, reader.uint32());
                        break;
                    }
                case 44: {
                        message.invalidGoal = $root.proto.GameEvent.Goal.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.attackerDoubleTouchedBall = $root.proto.GameEvent.AttackerDoubleTouchedBall.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.placementSucceeded = $root.proto.GameEvent.PlacementSucceeded.decode(reader, reader.uint32());
                        break;
                    }
                case 45: {
                        message.penaltyKickFailed = $root.proto.GameEvent.PenaltyKickFailed.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.noProgressInGame = $root.proto.GameEvent.NoProgressInGame.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.placementFailed = $root.proto.GameEvent.PlacementFailed.decode(reader, reader.uint32());
                        break;
                    }
                case 32: {
                        message.multipleCards = $root.proto.GameEvent.MultipleCards.decode(reader, reader.uint32());
                        break;
                    }
                case 34: {
                        message.multipleFouls = $root.proto.GameEvent.MultipleFouls.decode(reader, reader.uint32());
                        break;
                    }
                case 37: {
                        message.botSubstitution = $root.proto.GameEvent.BotSubstitution.decode(reader, reader.uint32());
                        break;
                    }
                case 38: {
                        message.tooManyRobots = $root.proto.GameEvent.TooManyRobots.decode(reader, reader.uint32());
                        break;
                    }
                case 46: {
                        message.challengeFlag = $root.proto.GameEvent.ChallengeFlag.decode(reader, reader.uint32());
                        break;
                    }
                case 47: {
                        message.emergencyStop = $root.proto.GameEvent.EmergencyStop.decode(reader, reader.uint32());
                        break;
                    }
                case 35: {
                        message.unsportingBehaviorMinor = $root.proto.GameEvent.UnsportingBehaviorMinor.decode(reader, reader.uint32());
                        break;
                    }
                case 36: {
                        message.unsportingBehaviorMajor = $root.proto.GameEvent.UnsportingBehaviorMajor.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GameEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.GameEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.GameEvent} GameEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GameEvent message.
         * @function verify
         * @memberof proto.GameEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GameEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 6:
                case 7:
                case 11:
                case 19:
                case 31:
                case 41:
                case 13:
                case 17:
                case 24:
                case 26:
                case 27:
                case 15:
                case 18:
                case 22:
                case 21:
                case 29:
                case 28:
                case 20:
                case 39:
                case 8:
                case 42:
                case 14:
                case 5:
                case 43:
                case 2:
                case 3:
                case 32:
                case 34:
                case 37:
                case 38:
                case 44:
                case 45:
                case 35:
                case 36:
                    break;
                }
            if (message.origin != null && message.hasOwnProperty("origin")) {
                if (!Array.isArray(message.origin))
                    return "origin: array expected";
                for (let i = 0; i < message.origin.length; ++i)
                    if (!$util.isString(message.origin[i]))
                        return "origin: string[] expected";
            }
            if (message.ballLeftFieldTouchLine != null && message.hasOwnProperty("ballLeftFieldTouchLine")) {
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.BallLeftField.verify(message.ballLeftFieldTouchLine);
                    if (error)
                        return "ballLeftFieldTouchLine." + error;
                }
            }
            if (message.ballLeftFieldGoalLine != null && message.hasOwnProperty("ballLeftFieldGoalLine")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.BallLeftField.verify(message.ballLeftFieldGoalLine);
                    if (error)
                        return "ballLeftFieldGoalLine." + error;
                }
            }
            if (message.aimlessKick != null && message.hasOwnProperty("aimlessKick")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.AimlessKick.verify(message.aimlessKick);
                    if (error)
                        return "aimlessKick." + error;
                }
            }
            if (message.attackerTooCloseToDefenseArea != null && message.hasOwnProperty("attackerTooCloseToDefenseArea")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.AttackerTooCloseToDefenseArea.verify(message.attackerTooCloseToDefenseArea);
                    if (error)
                        return "attackerTooCloseToDefenseArea." + error;
                }
            }
            if (message.defenderInDefenseArea != null && message.hasOwnProperty("defenderInDefenseArea")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.DefenderInDefenseArea.verify(message.defenderInDefenseArea);
                    if (error)
                        return "defenderInDefenseArea." + error;
                }
            }
            if (message.boundaryCrossing != null && message.hasOwnProperty("boundaryCrossing")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.BoundaryCrossing.verify(message.boundaryCrossing);
                    if (error)
                        return "boundaryCrossing." + error;
                }
            }
            if (message.keeperHeldBall != null && message.hasOwnProperty("keeperHeldBall")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.KeeperHeldBall.verify(message.keeperHeldBall);
                    if (error)
                        return "keeperHeldBall." + error;
                }
            }
            if (message.botDribbledBallTooFar != null && message.hasOwnProperty("botDribbledBallTooFar")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.BotDribbledBallTooFar.verify(message.botDribbledBallTooFar);
                    if (error)
                        return "botDribbledBallTooFar." + error;
                }
            }
            if (message.botPushedBot != null && message.hasOwnProperty("botPushedBot")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.BotPushedBot.verify(message.botPushedBot);
                    if (error)
                        return "botPushedBot." + error;
                }
            }
            if (message.botHeldBallDeliberately != null && message.hasOwnProperty("botHeldBallDeliberately")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.BotHeldBallDeliberately.verify(message.botHeldBallDeliberately);
                    if (error)
                        return "botHeldBallDeliberately." + error;
                }
            }
            if (message.botTippedOver != null && message.hasOwnProperty("botTippedOver")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.BotTippedOver.verify(message.botTippedOver);
                    if (error)
                        return "botTippedOver." + error;
                }
            }
            if (message.attackerTouchedBallInDefenseArea != null && message.hasOwnProperty("attackerTouchedBallInDefenseArea")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.AttackerTouchedBallInDefenseArea.verify(message.attackerTouchedBallInDefenseArea);
                    if (error)
                        return "attackerTouchedBallInDefenseArea." + error;
                }
            }
            if (message.botKickedBallTooFast != null && message.hasOwnProperty("botKickedBallTooFast")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.BotKickedBallTooFast.verify(message.botKickedBallTooFast);
                    if (error)
                        return "botKickedBallTooFast." + error;
                }
            }
            if (message.botCrashUnique != null && message.hasOwnProperty("botCrashUnique")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.BotCrashUnique.verify(message.botCrashUnique);
                    if (error)
                        return "botCrashUnique." + error;
                }
            }
            if (message.botCrashDrawn != null && message.hasOwnProperty("botCrashDrawn")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.BotCrashDrawn.verify(message.botCrashDrawn);
                    if (error)
                        return "botCrashDrawn." + error;
                }
            }
            if (message.defenderTooCloseToKickPoint != null && message.hasOwnProperty("defenderTooCloseToKickPoint")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.DefenderTooCloseToKickPoint.verify(message.defenderTooCloseToKickPoint);
                    if (error)
                        return "defenderTooCloseToKickPoint." + error;
                }
            }
            if (message.botTooFastInStop != null && message.hasOwnProperty("botTooFastInStop")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.BotTooFastInStop.verify(message.botTooFastInStop);
                    if (error)
                        return "botTooFastInStop." + error;
                }
            }
            if (message.botInterferedPlacement != null && message.hasOwnProperty("botInterferedPlacement")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.BotInterferedPlacement.verify(message.botInterferedPlacement);
                    if (error)
                        return "botInterferedPlacement." + error;
                }
            }
            if (message.possibleGoal != null && message.hasOwnProperty("possibleGoal")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.Goal.verify(message.possibleGoal);
                    if (error)
                        return "possibleGoal." + error;
                }
            }
            if (message.goal != null && message.hasOwnProperty("goal")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.Goal.verify(message.goal);
                    if (error)
                        return "goal." + error;
                }
            }
            if (message.invalidGoal != null && message.hasOwnProperty("invalidGoal")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.Goal.verify(message.invalidGoal);
                    if (error)
                        return "invalidGoal." + error;
                }
            }
            if (message.attackerDoubleTouchedBall != null && message.hasOwnProperty("attackerDoubleTouchedBall")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.AttackerDoubleTouchedBall.verify(message.attackerDoubleTouchedBall);
                    if (error)
                        return "attackerDoubleTouchedBall." + error;
                }
            }
            if (message.placementSucceeded != null && message.hasOwnProperty("placementSucceeded")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.PlacementSucceeded.verify(message.placementSucceeded);
                    if (error)
                        return "placementSucceeded." + error;
                }
            }
            if (message.penaltyKickFailed != null && message.hasOwnProperty("penaltyKickFailed")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.PenaltyKickFailed.verify(message.penaltyKickFailed);
                    if (error)
                        return "penaltyKickFailed." + error;
                }
            }
            if (message.noProgressInGame != null && message.hasOwnProperty("noProgressInGame")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.NoProgressInGame.verify(message.noProgressInGame);
                    if (error)
                        return "noProgressInGame." + error;
                }
            }
            if (message.placementFailed != null && message.hasOwnProperty("placementFailed")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.PlacementFailed.verify(message.placementFailed);
                    if (error)
                        return "placementFailed." + error;
                }
            }
            if (message.multipleCards != null && message.hasOwnProperty("multipleCards")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.MultipleCards.verify(message.multipleCards);
                    if (error)
                        return "multipleCards." + error;
                }
            }
            if (message.multipleFouls != null && message.hasOwnProperty("multipleFouls")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.MultipleFouls.verify(message.multipleFouls);
                    if (error)
                        return "multipleFouls." + error;
                }
            }
            if (message.botSubstitution != null && message.hasOwnProperty("botSubstitution")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.BotSubstitution.verify(message.botSubstitution);
                    if (error)
                        return "botSubstitution." + error;
                }
            }
            if (message.tooManyRobots != null && message.hasOwnProperty("tooManyRobots")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.TooManyRobots.verify(message.tooManyRobots);
                    if (error)
                        return "tooManyRobots." + error;
                }
            }
            if (message.challengeFlag != null && message.hasOwnProperty("challengeFlag")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.ChallengeFlag.verify(message.challengeFlag);
                    if (error)
                        return "challengeFlag." + error;
                }
            }
            if (message.emergencyStop != null && message.hasOwnProperty("emergencyStop")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.EmergencyStop.verify(message.emergencyStop);
                    if (error)
                        return "emergencyStop." + error;
                }
            }
            if (message.unsportingBehaviorMinor != null && message.hasOwnProperty("unsportingBehaviorMinor")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.UnsportingBehaviorMinor.verify(message.unsportingBehaviorMinor);
                    if (error)
                        return "unsportingBehaviorMinor." + error;
                }
            }
            if (message.unsportingBehaviorMajor != null && message.hasOwnProperty("unsportingBehaviorMajor")) {
                if (properties.event === 1)
                    return "event: multiple values";
                properties.event = 1;
                {
                    let error = $root.proto.GameEvent.UnsportingBehaviorMajor.verify(message.unsportingBehaviorMajor);
                    if (error)
                        return "unsportingBehaviorMajor." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GameEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.GameEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.GameEvent} GameEvent
         */
        GameEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.GameEvent)
                return object;
            let message = new $root.proto.GameEvent();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNKNOWN_GAME_EVENT_TYPE":
            case 0:
                message.type = 0;
                break;
            case "BALL_LEFT_FIELD_TOUCH_LINE":
            case 6:
                message.type = 6;
                break;
            case "BALL_LEFT_FIELD_GOAL_LINE":
            case 7:
                message.type = 7;
                break;
            case "AIMLESS_KICK":
            case 11:
                message.type = 11;
                break;
            case "ATTACKER_TOO_CLOSE_TO_DEFENSE_AREA":
            case 19:
                message.type = 19;
                break;
            case "DEFENDER_IN_DEFENSE_AREA":
            case 31:
                message.type = 31;
                break;
            case "BOUNDARY_CROSSING":
            case 41:
                message.type = 41;
                break;
            case "KEEPER_HELD_BALL":
            case 13:
                message.type = 13;
                break;
            case "BOT_DRIBBLED_BALL_TOO_FAR":
            case 17:
                message.type = 17;
                break;
            case "BOT_PUSHED_BOT":
            case 24:
                message.type = 24;
                break;
            case "BOT_HELD_BALL_DELIBERATELY":
            case 26:
                message.type = 26;
                break;
            case "BOT_TIPPED_OVER":
            case 27:
                message.type = 27;
                break;
            case "ATTACKER_TOUCHED_BALL_IN_DEFENSE_AREA":
            case 15:
                message.type = 15;
                break;
            case "BOT_KICKED_BALL_TOO_FAST":
            case 18:
                message.type = 18;
                break;
            case "BOT_CRASH_UNIQUE":
            case 22:
                message.type = 22;
                break;
            case "BOT_CRASH_DRAWN":
            case 21:
                message.type = 21;
                break;
            case "DEFENDER_TOO_CLOSE_TO_KICK_POINT":
            case 29:
                message.type = 29;
                break;
            case "BOT_TOO_FAST_IN_STOP":
            case 28:
                message.type = 28;
                break;
            case "BOT_INTERFERED_PLACEMENT":
            case 20:
                message.type = 20;
                break;
            case "POSSIBLE_GOAL":
            case 39:
                message.type = 39;
                break;
            case "GOAL":
            case 8:
                message.type = 8;
                break;
            case "INVALID_GOAL":
            case 42:
                message.type = 42;
                break;
            case "ATTACKER_DOUBLE_TOUCHED_BALL":
            case 14:
                message.type = 14;
                break;
            case "PLACEMENT_SUCCEEDED":
            case 5:
                message.type = 5;
                break;
            case "PENALTY_KICK_FAILED":
            case 43:
                message.type = 43;
                break;
            case "NO_PROGRESS_IN_GAME":
            case 2:
                message.type = 2;
                break;
            case "PLACEMENT_FAILED":
            case 3:
                message.type = 3;
                break;
            case "MULTIPLE_CARDS":
            case 32:
                message.type = 32;
                break;
            case "MULTIPLE_FOULS":
            case 34:
                message.type = 34;
                break;
            case "BOT_SUBSTITUTION":
            case 37:
                message.type = 37;
                break;
            case "TOO_MANY_ROBOTS":
            case 38:
                message.type = 38;
                break;
            case "CHALLENGE_FLAG":
            case 44:
                message.type = 44;
                break;
            case "EMERGENCY_STOP":
            case 45:
                message.type = 45;
                break;
            case "UNSPORTING_BEHAVIOR_MINOR":
            case 35:
                message.type = 35;
                break;
            case "UNSPORTING_BEHAVIOR_MAJOR":
            case 36:
                message.type = 36;
                break;
            }
            if (object.origin) {
                if (!Array.isArray(object.origin))
                    throw TypeError(".proto.GameEvent.origin: array expected");
                message.origin = [];
                for (let i = 0; i < object.origin.length; ++i)
                    message.origin[i] = String(object.origin[i]);
            }
            if (object.ballLeftFieldTouchLine != null) {
                if (typeof object.ballLeftFieldTouchLine !== "object")
                    throw TypeError(".proto.GameEvent.ballLeftFieldTouchLine: object expected");
                message.ballLeftFieldTouchLine = $root.proto.GameEvent.BallLeftField.fromObject(object.ballLeftFieldTouchLine);
            }
            if (object.ballLeftFieldGoalLine != null) {
                if (typeof object.ballLeftFieldGoalLine !== "object")
                    throw TypeError(".proto.GameEvent.ballLeftFieldGoalLine: object expected");
                message.ballLeftFieldGoalLine = $root.proto.GameEvent.BallLeftField.fromObject(object.ballLeftFieldGoalLine);
            }
            if (object.aimlessKick != null) {
                if (typeof object.aimlessKick !== "object")
                    throw TypeError(".proto.GameEvent.aimlessKick: object expected");
                message.aimlessKick = $root.proto.GameEvent.AimlessKick.fromObject(object.aimlessKick);
            }
            if (object.attackerTooCloseToDefenseArea != null) {
                if (typeof object.attackerTooCloseToDefenseArea !== "object")
                    throw TypeError(".proto.GameEvent.attackerTooCloseToDefenseArea: object expected");
                message.attackerTooCloseToDefenseArea = $root.proto.GameEvent.AttackerTooCloseToDefenseArea.fromObject(object.attackerTooCloseToDefenseArea);
            }
            if (object.defenderInDefenseArea != null) {
                if (typeof object.defenderInDefenseArea !== "object")
                    throw TypeError(".proto.GameEvent.defenderInDefenseArea: object expected");
                message.defenderInDefenseArea = $root.proto.GameEvent.DefenderInDefenseArea.fromObject(object.defenderInDefenseArea);
            }
            if (object.boundaryCrossing != null) {
                if (typeof object.boundaryCrossing !== "object")
                    throw TypeError(".proto.GameEvent.boundaryCrossing: object expected");
                message.boundaryCrossing = $root.proto.GameEvent.BoundaryCrossing.fromObject(object.boundaryCrossing);
            }
            if (object.keeperHeldBall != null) {
                if (typeof object.keeperHeldBall !== "object")
                    throw TypeError(".proto.GameEvent.keeperHeldBall: object expected");
                message.keeperHeldBall = $root.proto.GameEvent.KeeperHeldBall.fromObject(object.keeperHeldBall);
            }
            if (object.botDribbledBallTooFar != null) {
                if (typeof object.botDribbledBallTooFar !== "object")
                    throw TypeError(".proto.GameEvent.botDribbledBallTooFar: object expected");
                message.botDribbledBallTooFar = $root.proto.GameEvent.BotDribbledBallTooFar.fromObject(object.botDribbledBallTooFar);
            }
            if (object.botPushedBot != null) {
                if (typeof object.botPushedBot !== "object")
                    throw TypeError(".proto.GameEvent.botPushedBot: object expected");
                message.botPushedBot = $root.proto.GameEvent.BotPushedBot.fromObject(object.botPushedBot);
            }
            if (object.botHeldBallDeliberately != null) {
                if (typeof object.botHeldBallDeliberately !== "object")
                    throw TypeError(".proto.GameEvent.botHeldBallDeliberately: object expected");
                message.botHeldBallDeliberately = $root.proto.GameEvent.BotHeldBallDeliberately.fromObject(object.botHeldBallDeliberately);
            }
            if (object.botTippedOver != null) {
                if (typeof object.botTippedOver !== "object")
                    throw TypeError(".proto.GameEvent.botTippedOver: object expected");
                message.botTippedOver = $root.proto.GameEvent.BotTippedOver.fromObject(object.botTippedOver);
            }
            if (object.attackerTouchedBallInDefenseArea != null) {
                if (typeof object.attackerTouchedBallInDefenseArea !== "object")
                    throw TypeError(".proto.GameEvent.attackerTouchedBallInDefenseArea: object expected");
                message.attackerTouchedBallInDefenseArea = $root.proto.GameEvent.AttackerTouchedBallInDefenseArea.fromObject(object.attackerTouchedBallInDefenseArea);
            }
            if (object.botKickedBallTooFast != null) {
                if (typeof object.botKickedBallTooFast !== "object")
                    throw TypeError(".proto.GameEvent.botKickedBallTooFast: object expected");
                message.botKickedBallTooFast = $root.proto.GameEvent.BotKickedBallTooFast.fromObject(object.botKickedBallTooFast);
            }
            if (object.botCrashUnique != null) {
                if (typeof object.botCrashUnique !== "object")
                    throw TypeError(".proto.GameEvent.botCrashUnique: object expected");
                message.botCrashUnique = $root.proto.GameEvent.BotCrashUnique.fromObject(object.botCrashUnique);
            }
            if (object.botCrashDrawn != null) {
                if (typeof object.botCrashDrawn !== "object")
                    throw TypeError(".proto.GameEvent.botCrashDrawn: object expected");
                message.botCrashDrawn = $root.proto.GameEvent.BotCrashDrawn.fromObject(object.botCrashDrawn);
            }
            if (object.defenderTooCloseToKickPoint != null) {
                if (typeof object.defenderTooCloseToKickPoint !== "object")
                    throw TypeError(".proto.GameEvent.defenderTooCloseToKickPoint: object expected");
                message.defenderTooCloseToKickPoint = $root.proto.GameEvent.DefenderTooCloseToKickPoint.fromObject(object.defenderTooCloseToKickPoint);
            }
            if (object.botTooFastInStop != null) {
                if (typeof object.botTooFastInStop !== "object")
                    throw TypeError(".proto.GameEvent.botTooFastInStop: object expected");
                message.botTooFastInStop = $root.proto.GameEvent.BotTooFastInStop.fromObject(object.botTooFastInStop);
            }
            if (object.botInterferedPlacement != null) {
                if (typeof object.botInterferedPlacement !== "object")
                    throw TypeError(".proto.GameEvent.botInterferedPlacement: object expected");
                message.botInterferedPlacement = $root.proto.GameEvent.BotInterferedPlacement.fromObject(object.botInterferedPlacement);
            }
            if (object.possibleGoal != null) {
                if (typeof object.possibleGoal !== "object")
                    throw TypeError(".proto.GameEvent.possibleGoal: object expected");
                message.possibleGoal = $root.proto.GameEvent.Goal.fromObject(object.possibleGoal);
            }
            if (object.goal != null) {
                if (typeof object.goal !== "object")
                    throw TypeError(".proto.GameEvent.goal: object expected");
                message.goal = $root.proto.GameEvent.Goal.fromObject(object.goal);
            }
            if (object.invalidGoal != null) {
                if (typeof object.invalidGoal !== "object")
                    throw TypeError(".proto.GameEvent.invalidGoal: object expected");
                message.invalidGoal = $root.proto.GameEvent.Goal.fromObject(object.invalidGoal);
            }
            if (object.attackerDoubleTouchedBall != null) {
                if (typeof object.attackerDoubleTouchedBall !== "object")
                    throw TypeError(".proto.GameEvent.attackerDoubleTouchedBall: object expected");
                message.attackerDoubleTouchedBall = $root.proto.GameEvent.AttackerDoubleTouchedBall.fromObject(object.attackerDoubleTouchedBall);
            }
            if (object.placementSucceeded != null) {
                if (typeof object.placementSucceeded !== "object")
                    throw TypeError(".proto.GameEvent.placementSucceeded: object expected");
                message.placementSucceeded = $root.proto.GameEvent.PlacementSucceeded.fromObject(object.placementSucceeded);
            }
            if (object.penaltyKickFailed != null) {
                if (typeof object.penaltyKickFailed !== "object")
                    throw TypeError(".proto.GameEvent.penaltyKickFailed: object expected");
                message.penaltyKickFailed = $root.proto.GameEvent.PenaltyKickFailed.fromObject(object.penaltyKickFailed);
            }
            if (object.noProgressInGame != null) {
                if (typeof object.noProgressInGame !== "object")
                    throw TypeError(".proto.GameEvent.noProgressInGame: object expected");
                message.noProgressInGame = $root.proto.GameEvent.NoProgressInGame.fromObject(object.noProgressInGame);
            }
            if (object.placementFailed != null) {
                if (typeof object.placementFailed !== "object")
                    throw TypeError(".proto.GameEvent.placementFailed: object expected");
                message.placementFailed = $root.proto.GameEvent.PlacementFailed.fromObject(object.placementFailed);
            }
            if (object.multipleCards != null) {
                if (typeof object.multipleCards !== "object")
                    throw TypeError(".proto.GameEvent.multipleCards: object expected");
                message.multipleCards = $root.proto.GameEvent.MultipleCards.fromObject(object.multipleCards);
            }
            if (object.multipleFouls != null) {
                if (typeof object.multipleFouls !== "object")
                    throw TypeError(".proto.GameEvent.multipleFouls: object expected");
                message.multipleFouls = $root.proto.GameEvent.MultipleFouls.fromObject(object.multipleFouls);
            }
            if (object.botSubstitution != null) {
                if (typeof object.botSubstitution !== "object")
                    throw TypeError(".proto.GameEvent.botSubstitution: object expected");
                message.botSubstitution = $root.proto.GameEvent.BotSubstitution.fromObject(object.botSubstitution);
            }
            if (object.tooManyRobots != null) {
                if (typeof object.tooManyRobots !== "object")
                    throw TypeError(".proto.GameEvent.tooManyRobots: object expected");
                message.tooManyRobots = $root.proto.GameEvent.TooManyRobots.fromObject(object.tooManyRobots);
            }
            if (object.challengeFlag != null) {
                if (typeof object.challengeFlag !== "object")
                    throw TypeError(".proto.GameEvent.challengeFlag: object expected");
                message.challengeFlag = $root.proto.GameEvent.ChallengeFlag.fromObject(object.challengeFlag);
            }
            if (object.emergencyStop != null) {
                if (typeof object.emergencyStop !== "object")
                    throw TypeError(".proto.GameEvent.emergencyStop: object expected");
                message.emergencyStop = $root.proto.GameEvent.EmergencyStop.fromObject(object.emergencyStop);
            }
            if (object.unsportingBehaviorMinor != null) {
                if (typeof object.unsportingBehaviorMinor !== "object")
                    throw TypeError(".proto.GameEvent.unsportingBehaviorMinor: object expected");
                message.unsportingBehaviorMinor = $root.proto.GameEvent.UnsportingBehaviorMinor.fromObject(object.unsportingBehaviorMinor);
            }
            if (object.unsportingBehaviorMajor != null) {
                if (typeof object.unsportingBehaviorMajor !== "object")
                    throw TypeError(".proto.GameEvent.unsportingBehaviorMajor: object expected");
                message.unsportingBehaviorMajor = $root.proto.GameEvent.UnsportingBehaviorMajor.fromObject(object.unsportingBehaviorMajor);
            }
            return message;
        };

        /**
         * Creates a plain object from a GameEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.GameEvent
         * @static
         * @param {proto.GameEvent} message GameEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GameEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.origin = [];
            if (options.defaults)
                object.type = options.enums === String ? "UNKNOWN_GAME_EVENT_TYPE" : 0;
            if (message.noProgressInGame != null && message.hasOwnProperty("noProgressInGame")) {
                object.noProgressInGame = $root.proto.GameEvent.NoProgressInGame.toObject(message.noProgressInGame, options);
                if (options.oneofs)
                    object.event = "noProgressInGame";
            }
            if (message.placementFailed != null && message.hasOwnProperty("placementFailed")) {
                object.placementFailed = $root.proto.GameEvent.PlacementFailed.toObject(message.placementFailed, options);
                if (options.oneofs)
                    object.event = "placementFailed";
            }
            if (message.placementSucceeded != null && message.hasOwnProperty("placementSucceeded")) {
                object.placementSucceeded = $root.proto.GameEvent.PlacementSucceeded.toObject(message.placementSucceeded, options);
                if (options.oneofs)
                    object.event = "placementSucceeded";
            }
            if (message.ballLeftFieldTouchLine != null && message.hasOwnProperty("ballLeftFieldTouchLine")) {
                object.ballLeftFieldTouchLine = $root.proto.GameEvent.BallLeftField.toObject(message.ballLeftFieldTouchLine, options);
                if (options.oneofs)
                    object.event = "ballLeftFieldTouchLine";
            }
            if (message.ballLeftFieldGoalLine != null && message.hasOwnProperty("ballLeftFieldGoalLine")) {
                object.ballLeftFieldGoalLine = $root.proto.GameEvent.BallLeftField.toObject(message.ballLeftFieldGoalLine, options);
                if (options.oneofs)
                    object.event = "ballLeftFieldGoalLine";
            }
            if (message.goal != null && message.hasOwnProperty("goal")) {
                object.goal = $root.proto.GameEvent.Goal.toObject(message.goal, options);
                if (options.oneofs)
                    object.event = "goal";
            }
            if (message.aimlessKick != null && message.hasOwnProperty("aimlessKick")) {
                object.aimlessKick = $root.proto.GameEvent.AimlessKick.toObject(message.aimlessKick, options);
                if (options.oneofs)
                    object.event = "aimlessKick";
            }
            if (message.keeperHeldBall != null && message.hasOwnProperty("keeperHeldBall")) {
                object.keeperHeldBall = $root.proto.GameEvent.KeeperHeldBall.toObject(message.keeperHeldBall, options);
                if (options.oneofs)
                    object.event = "keeperHeldBall";
            }
            if (message.attackerDoubleTouchedBall != null && message.hasOwnProperty("attackerDoubleTouchedBall")) {
                object.attackerDoubleTouchedBall = $root.proto.GameEvent.AttackerDoubleTouchedBall.toObject(message.attackerDoubleTouchedBall, options);
                if (options.oneofs)
                    object.event = "attackerDoubleTouchedBall";
            }
            if (message.attackerTouchedBallInDefenseArea != null && message.hasOwnProperty("attackerTouchedBallInDefenseArea")) {
                object.attackerTouchedBallInDefenseArea = $root.proto.GameEvent.AttackerTouchedBallInDefenseArea.toObject(message.attackerTouchedBallInDefenseArea, options);
                if (options.oneofs)
                    object.event = "attackerTouchedBallInDefenseArea";
            }
            if (message.botDribbledBallTooFar != null && message.hasOwnProperty("botDribbledBallTooFar")) {
                object.botDribbledBallTooFar = $root.proto.GameEvent.BotDribbledBallTooFar.toObject(message.botDribbledBallTooFar, options);
                if (options.oneofs)
                    object.event = "botDribbledBallTooFar";
            }
            if (message.botKickedBallTooFast != null && message.hasOwnProperty("botKickedBallTooFast")) {
                object.botKickedBallTooFast = $root.proto.GameEvent.BotKickedBallTooFast.toObject(message.botKickedBallTooFast, options);
                if (options.oneofs)
                    object.event = "botKickedBallTooFast";
            }
            if (message.attackerTooCloseToDefenseArea != null && message.hasOwnProperty("attackerTooCloseToDefenseArea")) {
                object.attackerTooCloseToDefenseArea = $root.proto.GameEvent.AttackerTooCloseToDefenseArea.toObject(message.attackerTooCloseToDefenseArea, options);
                if (options.oneofs)
                    object.event = "attackerTooCloseToDefenseArea";
            }
            if (message.botInterferedPlacement != null && message.hasOwnProperty("botInterferedPlacement")) {
                object.botInterferedPlacement = $root.proto.GameEvent.BotInterferedPlacement.toObject(message.botInterferedPlacement, options);
                if (options.oneofs)
                    object.event = "botInterferedPlacement";
            }
            if (message.botCrashDrawn != null && message.hasOwnProperty("botCrashDrawn")) {
                object.botCrashDrawn = $root.proto.GameEvent.BotCrashDrawn.toObject(message.botCrashDrawn, options);
                if (options.oneofs)
                    object.event = "botCrashDrawn";
            }
            if (message.botCrashUnique != null && message.hasOwnProperty("botCrashUnique")) {
                object.botCrashUnique = $root.proto.GameEvent.BotCrashUnique.toObject(message.botCrashUnique, options);
                if (options.oneofs)
                    object.event = "botCrashUnique";
            }
            if (message.botPushedBot != null && message.hasOwnProperty("botPushedBot")) {
                object.botPushedBot = $root.proto.GameEvent.BotPushedBot.toObject(message.botPushedBot, options);
                if (options.oneofs)
                    object.event = "botPushedBot";
            }
            if (message.botHeldBallDeliberately != null && message.hasOwnProperty("botHeldBallDeliberately")) {
                object.botHeldBallDeliberately = $root.proto.GameEvent.BotHeldBallDeliberately.toObject(message.botHeldBallDeliberately, options);
                if (options.oneofs)
                    object.event = "botHeldBallDeliberately";
            }
            if (message.botTippedOver != null && message.hasOwnProperty("botTippedOver")) {
                object.botTippedOver = $root.proto.GameEvent.BotTippedOver.toObject(message.botTippedOver, options);
                if (options.oneofs)
                    object.event = "botTippedOver";
            }
            if (message.botTooFastInStop != null && message.hasOwnProperty("botTooFastInStop")) {
                object.botTooFastInStop = $root.proto.GameEvent.BotTooFastInStop.toObject(message.botTooFastInStop, options);
                if (options.oneofs)
                    object.event = "botTooFastInStop";
            }
            if (message.defenderTooCloseToKickPoint != null && message.hasOwnProperty("defenderTooCloseToKickPoint")) {
                object.defenderTooCloseToKickPoint = $root.proto.GameEvent.DefenderTooCloseToKickPoint.toObject(message.defenderTooCloseToKickPoint, options);
                if (options.oneofs)
                    object.event = "defenderTooCloseToKickPoint";
            }
            if (message.defenderInDefenseArea != null && message.hasOwnProperty("defenderInDefenseArea")) {
                object.defenderInDefenseArea = $root.proto.GameEvent.DefenderInDefenseArea.toObject(message.defenderInDefenseArea, options);
                if (options.oneofs)
                    object.event = "defenderInDefenseArea";
            }
            if (message.multipleCards != null && message.hasOwnProperty("multipleCards")) {
                object.multipleCards = $root.proto.GameEvent.MultipleCards.toObject(message.multipleCards, options);
                if (options.oneofs)
                    object.event = "multipleCards";
            }
            if (message.multipleFouls != null && message.hasOwnProperty("multipleFouls")) {
                object.multipleFouls = $root.proto.GameEvent.MultipleFouls.toObject(message.multipleFouls, options);
                if (options.oneofs)
                    object.event = "multipleFouls";
            }
            if (message.unsportingBehaviorMinor != null && message.hasOwnProperty("unsportingBehaviorMinor")) {
                object.unsportingBehaviorMinor = $root.proto.GameEvent.UnsportingBehaviorMinor.toObject(message.unsportingBehaviorMinor, options);
                if (options.oneofs)
                    object.event = "unsportingBehaviorMinor";
            }
            if (message.unsportingBehaviorMajor != null && message.hasOwnProperty("unsportingBehaviorMajor")) {
                object.unsportingBehaviorMajor = $root.proto.GameEvent.UnsportingBehaviorMajor.toObject(message.unsportingBehaviorMajor, options);
                if (options.oneofs)
                    object.event = "unsportingBehaviorMajor";
            }
            if (message.botSubstitution != null && message.hasOwnProperty("botSubstitution")) {
                object.botSubstitution = $root.proto.GameEvent.BotSubstitution.toObject(message.botSubstitution, options);
                if (options.oneofs)
                    object.event = "botSubstitution";
            }
            if (message.tooManyRobots != null && message.hasOwnProperty("tooManyRobots")) {
                object.tooManyRobots = $root.proto.GameEvent.TooManyRobots.toObject(message.tooManyRobots, options);
                if (options.oneofs)
                    object.event = "tooManyRobots";
            }
            if (message.possibleGoal != null && message.hasOwnProperty("possibleGoal")) {
                object.possibleGoal = $root.proto.GameEvent.Goal.toObject(message.possibleGoal, options);
                if (options.oneofs)
                    object.event = "possibleGoal";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.proto.GameEvent.Type[message.type] === undefined ? message.type : $root.proto.GameEvent.Type[message.type] : message.type;
            if (message.origin && message.origin.length) {
                object.origin = [];
                for (let j = 0; j < message.origin.length; ++j)
                    object.origin[j] = message.origin[j];
            }
            if (message.boundaryCrossing != null && message.hasOwnProperty("boundaryCrossing")) {
                object.boundaryCrossing = $root.proto.GameEvent.BoundaryCrossing.toObject(message.boundaryCrossing, options);
                if (options.oneofs)
                    object.event = "boundaryCrossing";
            }
            if (message.invalidGoal != null && message.hasOwnProperty("invalidGoal")) {
                object.invalidGoal = $root.proto.GameEvent.Goal.toObject(message.invalidGoal, options);
                if (options.oneofs)
                    object.event = "invalidGoal";
            }
            if (message.penaltyKickFailed != null && message.hasOwnProperty("penaltyKickFailed")) {
                object.penaltyKickFailed = $root.proto.GameEvent.PenaltyKickFailed.toObject(message.penaltyKickFailed, options);
                if (options.oneofs)
                    object.event = "penaltyKickFailed";
            }
            if (message.challengeFlag != null && message.hasOwnProperty("challengeFlag")) {
                object.challengeFlag = $root.proto.GameEvent.ChallengeFlag.toObject(message.challengeFlag, options);
                if (options.oneofs)
                    object.event = "challengeFlag";
            }
            if (message.emergencyStop != null && message.hasOwnProperty("emergencyStop")) {
                object.emergencyStop = $root.proto.GameEvent.EmergencyStop.toObject(message.emergencyStop, options);
                if (options.oneofs)
                    object.event = "emergencyStop";
            }
            return object;
        };

        /**
         * Converts this GameEvent to JSON.
         * @function toJSON
         * @memberof proto.GameEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GameEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GameEvent
         * @function getTypeUrl
         * @memberof proto.GameEvent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GameEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GameEvent";
        };

        GameEvent.BallLeftField = (function() {

            /**
             * Properties of a BallLeftField.
             * @memberof proto.GameEvent
             * @interface IBallLeftField
             * @property {proto.Team} byTeam BallLeftField byTeam
             * @property {number|null} [byBot] BallLeftField byBot
             * @property {proto.IVector2|null} [location] BallLeftField location
             */

            /**
             * Constructs a new BallLeftField.
             * @memberof proto.GameEvent
             * @classdesc Represents a BallLeftField.
             * @implements IBallLeftField
             * @constructor
             * @param {proto.GameEvent.IBallLeftField=} [properties] Properties to set
             */
            function BallLeftField(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BallLeftField byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.BallLeftField
             * @instance
             */
            BallLeftField.prototype.byTeam = 0;

            /**
             * BallLeftField byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.BallLeftField
             * @instance
             */
            BallLeftField.prototype.byBot = 0;

            /**
             * BallLeftField location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.BallLeftField
             * @instance
             */
            BallLeftField.prototype.location = null;

            /**
             * Creates a new BallLeftField instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.BallLeftField
             * @static
             * @param {proto.GameEvent.IBallLeftField=} [properties] Properties to set
             * @returns {proto.GameEvent.BallLeftField} BallLeftField instance
             */
            BallLeftField.create = function create(properties) {
                return new BallLeftField(properties);
            };

            /**
             * Encodes the specified BallLeftField message. Does not implicitly {@link proto.GameEvent.BallLeftField.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.BallLeftField
             * @static
             * @param {proto.GameEvent.IBallLeftField} message BallLeftField message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BallLeftField.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BallLeftField message, length delimited. Does not implicitly {@link proto.GameEvent.BallLeftField.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.BallLeftField
             * @static
             * @param {proto.GameEvent.IBallLeftField} message BallLeftField message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BallLeftField.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BallLeftField message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.BallLeftField
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.BallLeftField} BallLeftField
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BallLeftField.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.BallLeftField();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a BallLeftField message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.BallLeftField
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.BallLeftField} BallLeftField
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BallLeftField.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BallLeftField message.
             * @function verify
             * @memberof proto.GameEvent.BallLeftField
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BallLeftField.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                return null;
            };

            /**
             * Creates a BallLeftField message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.BallLeftField
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.BallLeftField} BallLeftField
             */
            BallLeftField.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.BallLeftField)
                    return object;
                let message = new $root.proto.GameEvent.BallLeftField();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.BallLeftField.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                return message;
            };

            /**
             * Creates a plain object from a BallLeftField message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.BallLeftField
             * @static
             * @param {proto.GameEvent.BallLeftField} message BallLeftField
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BallLeftField.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                return object;
            };

            /**
             * Converts this BallLeftField to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.BallLeftField
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BallLeftField.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BallLeftField
             * @function getTypeUrl
             * @memberof proto.GameEvent.BallLeftField
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BallLeftField.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.BallLeftField";
            };

            return BallLeftField;
        })();

        GameEvent.AimlessKick = (function() {

            /**
             * Properties of an AimlessKick.
             * @memberof proto.GameEvent
             * @interface IAimlessKick
             * @property {proto.Team} byTeam AimlessKick byTeam
             * @property {number|null} [byBot] AimlessKick byBot
             * @property {proto.IVector2|null} [location] AimlessKick location
             * @property {proto.IVector2|null} [kickLocation] AimlessKick kickLocation
             */

            /**
             * Constructs a new AimlessKick.
             * @memberof proto.GameEvent
             * @classdesc Represents an AimlessKick.
             * @implements IAimlessKick
             * @constructor
             * @param {proto.GameEvent.IAimlessKick=} [properties] Properties to set
             */
            function AimlessKick(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AimlessKick byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.AimlessKick
             * @instance
             */
            AimlessKick.prototype.byTeam = 0;

            /**
             * AimlessKick byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.AimlessKick
             * @instance
             */
            AimlessKick.prototype.byBot = 0;

            /**
             * AimlessKick location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.AimlessKick
             * @instance
             */
            AimlessKick.prototype.location = null;

            /**
             * AimlessKick kickLocation.
             * @member {proto.IVector2|null|undefined} kickLocation
             * @memberof proto.GameEvent.AimlessKick
             * @instance
             */
            AimlessKick.prototype.kickLocation = null;

            /**
             * Creates a new AimlessKick instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.AimlessKick
             * @static
             * @param {proto.GameEvent.IAimlessKick=} [properties] Properties to set
             * @returns {proto.GameEvent.AimlessKick} AimlessKick instance
             */
            AimlessKick.create = function create(properties) {
                return new AimlessKick(properties);
            };

            /**
             * Encodes the specified AimlessKick message. Does not implicitly {@link proto.GameEvent.AimlessKick.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.AimlessKick
             * @static
             * @param {proto.GameEvent.IAimlessKick} message AimlessKick message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AimlessKick.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.kickLocation != null && Object.hasOwnProperty.call(message, "kickLocation"))
                    $root.proto.Vector2.encode(message.kickLocation, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AimlessKick message, length delimited. Does not implicitly {@link proto.GameEvent.AimlessKick.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.AimlessKick
             * @static
             * @param {proto.GameEvent.IAimlessKick} message AimlessKick message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AimlessKick.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AimlessKick message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.AimlessKick
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.AimlessKick} AimlessKick
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AimlessKick.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.AimlessKick();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.kickLocation = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes an AimlessKick message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.AimlessKick
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.AimlessKick} AimlessKick
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AimlessKick.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AimlessKick message.
             * @function verify
             * @memberof proto.GameEvent.AimlessKick
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AimlessKick.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.kickLocation != null && message.hasOwnProperty("kickLocation")) {
                    let error = $root.proto.Vector2.verify(message.kickLocation);
                    if (error)
                        return "kickLocation." + error;
                }
                return null;
            };

            /**
             * Creates an AimlessKick message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.AimlessKick
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.AimlessKick} AimlessKick
             */
            AimlessKick.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.AimlessKick)
                    return object;
                let message = new $root.proto.GameEvent.AimlessKick();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.AimlessKick.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.kickLocation != null) {
                    if (typeof object.kickLocation !== "object")
                        throw TypeError(".proto.GameEvent.AimlessKick.kickLocation: object expected");
                    message.kickLocation = $root.proto.Vector2.fromObject(object.kickLocation);
                }
                return message;
            };

            /**
             * Creates a plain object from an AimlessKick message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.AimlessKick
             * @static
             * @param {proto.GameEvent.AimlessKick} message AimlessKick
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AimlessKick.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                    object.kickLocation = null;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.kickLocation != null && message.hasOwnProperty("kickLocation"))
                    object.kickLocation = $root.proto.Vector2.toObject(message.kickLocation, options);
                return object;
            };

            /**
             * Converts this AimlessKick to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.AimlessKick
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AimlessKick.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AimlessKick
             * @function getTypeUrl
             * @memberof proto.GameEvent.AimlessKick
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AimlessKick.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.AimlessKick";
            };

            return AimlessKick;
        })();

        GameEvent.Goal = (function() {

            /**
             * Properties of a Goal.
             * @memberof proto.GameEvent
             * @interface IGoal
             * @property {proto.Team} byTeam Goal byTeam
             * @property {proto.Team|null} [kickingTeam] Goal kickingTeam
             * @property {number|null} [kickingBot] Goal kickingBot
             * @property {proto.IVector2|null} [location] Goal location
             * @property {proto.IVector2|null} [kickLocation] Goal kickLocation
             * @property {number|null} [maxBallHeight] Goal maxBallHeight
             * @property {number|null} [numRobotsByTeam] Goal numRobotsByTeam
             * @property {number|Long|null} [lastTouchByTeam] Goal lastTouchByTeam
             * @property {string|null} [message] Goal message
             */

            /**
             * Constructs a new Goal.
             * @memberof proto.GameEvent
             * @classdesc Represents a Goal.
             * @implements IGoal
             * @constructor
             * @param {proto.GameEvent.IGoal=} [properties] Properties to set
             */
            function Goal(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Goal byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.Goal
             * @instance
             */
            Goal.prototype.byTeam = 0;

            /**
             * Goal kickingTeam.
             * @member {proto.Team} kickingTeam
             * @memberof proto.GameEvent.Goal
             * @instance
             */
            Goal.prototype.kickingTeam = 0;

            /**
             * Goal kickingBot.
             * @member {number} kickingBot
             * @memberof proto.GameEvent.Goal
             * @instance
             */
            Goal.prototype.kickingBot = 0;

            /**
             * Goal location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.Goal
             * @instance
             */
            Goal.prototype.location = null;

            /**
             * Goal kickLocation.
             * @member {proto.IVector2|null|undefined} kickLocation
             * @memberof proto.GameEvent.Goal
             * @instance
             */
            Goal.prototype.kickLocation = null;

            /**
             * Goal maxBallHeight.
             * @member {number} maxBallHeight
             * @memberof proto.GameEvent.Goal
             * @instance
             */
            Goal.prototype.maxBallHeight = 0;

            /**
             * Goal numRobotsByTeam.
             * @member {number} numRobotsByTeam
             * @memberof proto.GameEvent.Goal
             * @instance
             */
            Goal.prototype.numRobotsByTeam = 0;

            /**
             * Goal lastTouchByTeam.
             * @member {number|Long} lastTouchByTeam
             * @memberof proto.GameEvent.Goal
             * @instance
             */
            Goal.prototype.lastTouchByTeam = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Goal message.
             * @member {string} message
             * @memberof proto.GameEvent.Goal
             * @instance
             */
            Goal.prototype.message = "";

            /**
             * Creates a new Goal instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.Goal
             * @static
             * @param {proto.GameEvent.IGoal=} [properties] Properties to set
             * @returns {proto.GameEvent.Goal} Goal instance
             */
            Goal.create = function create(properties) {
                return new Goal(properties);
            };

            /**
             * Encodes the specified Goal message. Does not implicitly {@link proto.GameEvent.Goal.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.Goal
             * @static
             * @param {proto.GameEvent.IGoal} message Goal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Goal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.kickingBot != null && Object.hasOwnProperty.call(message, "kickingBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.kickingBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.kickLocation != null && Object.hasOwnProperty.call(message, "kickLocation"))
                    $root.proto.Vector2.encode(message.kickLocation, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.maxBallHeight != null && Object.hasOwnProperty.call(message, "maxBallHeight"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.maxBallHeight);
                if (message.kickingTeam != null && Object.hasOwnProperty.call(message, "kickingTeam"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.kickingTeam);
                if (message.numRobotsByTeam != null && Object.hasOwnProperty.call(message, "numRobotsByTeam"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.numRobotsByTeam);
                if (message.lastTouchByTeam != null && Object.hasOwnProperty.call(message, "lastTouchByTeam"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.lastTouchByTeam);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.message);
                return writer;
            };

            /**
             * Encodes the specified Goal message, length delimited. Does not implicitly {@link proto.GameEvent.Goal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.Goal
             * @static
             * @param {proto.GameEvent.IGoal} message Goal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Goal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Goal message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.Goal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.Goal} Goal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Goal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.Goal();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 6: {
                            message.kickingTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.kickingBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.kickLocation = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.maxBallHeight = reader.float();
                            break;
                        }
                    case 7: {
                            message.numRobotsByTeam = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.lastTouchByTeam = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.message = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a Goal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.Goal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.Goal} Goal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Goal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Goal message.
             * @function verify
             * @memberof proto.GameEvent.Goal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Goal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.kickingTeam != null && message.hasOwnProperty("kickingTeam"))
                    switch (message.kickingTeam) {
                    default:
                        return "kickingTeam: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.kickingBot != null && message.hasOwnProperty("kickingBot"))
                    if (!$util.isInteger(message.kickingBot))
                        return "kickingBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.kickLocation != null && message.hasOwnProperty("kickLocation")) {
                    let error = $root.proto.Vector2.verify(message.kickLocation);
                    if (error)
                        return "kickLocation." + error;
                }
                if (message.maxBallHeight != null && message.hasOwnProperty("maxBallHeight"))
                    if (typeof message.maxBallHeight !== "number")
                        return "maxBallHeight: number expected";
                if (message.numRobotsByTeam != null && message.hasOwnProperty("numRobotsByTeam"))
                    if (!$util.isInteger(message.numRobotsByTeam))
                        return "numRobotsByTeam: integer expected";
                if (message.lastTouchByTeam != null && message.hasOwnProperty("lastTouchByTeam"))
                    if (!$util.isInteger(message.lastTouchByTeam) && !(message.lastTouchByTeam && $util.isInteger(message.lastTouchByTeam.low) && $util.isInteger(message.lastTouchByTeam.high)))
                        return "lastTouchByTeam: integer|Long expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                return null;
            };

            /**
             * Creates a Goal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.Goal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.Goal} Goal
             */
            Goal.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.Goal)
                    return object;
                let message = new $root.proto.GameEvent.Goal();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                switch (object.kickingTeam) {
                default:
                    if (typeof object.kickingTeam === "number") {
                        message.kickingTeam = object.kickingTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.kickingTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.kickingTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.kickingTeam = 2;
                    break;
                }
                if (object.kickingBot != null)
                    message.kickingBot = object.kickingBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.Goal.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.kickLocation != null) {
                    if (typeof object.kickLocation !== "object")
                        throw TypeError(".proto.GameEvent.Goal.kickLocation: object expected");
                    message.kickLocation = $root.proto.Vector2.fromObject(object.kickLocation);
                }
                if (object.maxBallHeight != null)
                    message.maxBallHeight = Number(object.maxBallHeight);
                if (object.numRobotsByTeam != null)
                    message.numRobotsByTeam = object.numRobotsByTeam >>> 0;
                if (object.lastTouchByTeam != null)
                    if ($util.Long)
                        (message.lastTouchByTeam = $util.Long.fromValue(object.lastTouchByTeam)).unsigned = true;
                    else if (typeof object.lastTouchByTeam === "string")
                        message.lastTouchByTeam = parseInt(object.lastTouchByTeam, 10);
                    else if (typeof object.lastTouchByTeam === "number")
                        message.lastTouchByTeam = object.lastTouchByTeam;
                    else if (typeof object.lastTouchByTeam === "object")
                        message.lastTouchByTeam = new $util.LongBits(object.lastTouchByTeam.low >>> 0, object.lastTouchByTeam.high >>> 0).toNumber(true);
                if (object.message != null)
                    message.message = String(object.message);
                return message;
            };

            /**
             * Creates a plain object from a Goal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.Goal
             * @static
             * @param {proto.GameEvent.Goal} message Goal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Goal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.kickingBot = 0;
                    object.location = null;
                    object.kickLocation = null;
                    object.maxBallHeight = 0;
                    object.kickingTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.numRobotsByTeam = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.lastTouchByTeam = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastTouchByTeam = options.longs === String ? "0" : 0;
                    object.message = "";
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.kickingBot != null && message.hasOwnProperty("kickingBot"))
                    object.kickingBot = message.kickingBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.kickLocation != null && message.hasOwnProperty("kickLocation"))
                    object.kickLocation = $root.proto.Vector2.toObject(message.kickLocation, options);
                if (message.maxBallHeight != null && message.hasOwnProperty("maxBallHeight"))
                    object.maxBallHeight = options.json && !isFinite(message.maxBallHeight) ? String(message.maxBallHeight) : message.maxBallHeight;
                if (message.kickingTeam != null && message.hasOwnProperty("kickingTeam"))
                    object.kickingTeam = options.enums === String ? $root.proto.Team[message.kickingTeam] === undefined ? message.kickingTeam : $root.proto.Team[message.kickingTeam] : message.kickingTeam;
                if (message.numRobotsByTeam != null && message.hasOwnProperty("numRobotsByTeam"))
                    object.numRobotsByTeam = message.numRobotsByTeam;
                if (message.lastTouchByTeam != null && message.hasOwnProperty("lastTouchByTeam"))
                    if (typeof message.lastTouchByTeam === "number")
                        object.lastTouchByTeam = options.longs === String ? String(message.lastTouchByTeam) : message.lastTouchByTeam;
                    else
                        object.lastTouchByTeam = options.longs === String ? $util.Long.prototype.toString.call(message.lastTouchByTeam) : options.longs === Number ? new $util.LongBits(message.lastTouchByTeam.low >>> 0, message.lastTouchByTeam.high >>> 0).toNumber(true) : message.lastTouchByTeam;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                return object;
            };

            /**
             * Converts this Goal to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.Goal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Goal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Goal
             * @function getTypeUrl
             * @memberof proto.GameEvent.Goal
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Goal.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.Goal";
            };

            return Goal;
        })();

        GameEvent.IndirectGoal = (function() {

            /**
             * Properties of an IndirectGoal.
             * @memberof proto.GameEvent
             * @interface IIndirectGoal
             * @property {proto.Team} byTeam IndirectGoal byTeam
             * @property {number|null} [byBot] IndirectGoal byBot
             * @property {proto.IVector2|null} [location] IndirectGoal location
             * @property {proto.IVector2|null} [kickLocation] IndirectGoal kickLocation
             */

            /**
             * Constructs a new IndirectGoal.
             * @memberof proto.GameEvent
             * @classdesc Represents an IndirectGoal.
             * @implements IIndirectGoal
             * @constructor
             * @param {proto.GameEvent.IIndirectGoal=} [properties] Properties to set
             */
            function IndirectGoal(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IndirectGoal byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.IndirectGoal
             * @instance
             */
            IndirectGoal.prototype.byTeam = 0;

            /**
             * IndirectGoal byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.IndirectGoal
             * @instance
             */
            IndirectGoal.prototype.byBot = 0;

            /**
             * IndirectGoal location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.IndirectGoal
             * @instance
             */
            IndirectGoal.prototype.location = null;

            /**
             * IndirectGoal kickLocation.
             * @member {proto.IVector2|null|undefined} kickLocation
             * @memberof proto.GameEvent.IndirectGoal
             * @instance
             */
            IndirectGoal.prototype.kickLocation = null;

            /**
             * Creates a new IndirectGoal instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.IndirectGoal
             * @static
             * @param {proto.GameEvent.IIndirectGoal=} [properties] Properties to set
             * @returns {proto.GameEvent.IndirectGoal} IndirectGoal instance
             */
            IndirectGoal.create = function create(properties) {
                return new IndirectGoal(properties);
            };

            /**
             * Encodes the specified IndirectGoal message. Does not implicitly {@link proto.GameEvent.IndirectGoal.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.IndirectGoal
             * @static
             * @param {proto.GameEvent.IIndirectGoal} message IndirectGoal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndirectGoal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.kickLocation != null && Object.hasOwnProperty.call(message, "kickLocation"))
                    $root.proto.Vector2.encode(message.kickLocation, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified IndirectGoal message, length delimited. Does not implicitly {@link proto.GameEvent.IndirectGoal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.IndirectGoal
             * @static
             * @param {proto.GameEvent.IIndirectGoal} message IndirectGoal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndirectGoal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IndirectGoal message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.IndirectGoal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.IndirectGoal} IndirectGoal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndirectGoal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.IndirectGoal();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.kickLocation = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes an IndirectGoal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.IndirectGoal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.IndirectGoal} IndirectGoal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndirectGoal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IndirectGoal message.
             * @function verify
             * @memberof proto.GameEvent.IndirectGoal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IndirectGoal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.kickLocation != null && message.hasOwnProperty("kickLocation")) {
                    let error = $root.proto.Vector2.verify(message.kickLocation);
                    if (error)
                        return "kickLocation." + error;
                }
                return null;
            };

            /**
             * Creates an IndirectGoal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.IndirectGoal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.IndirectGoal} IndirectGoal
             */
            IndirectGoal.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.IndirectGoal)
                    return object;
                let message = new $root.proto.GameEvent.IndirectGoal();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.IndirectGoal.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.kickLocation != null) {
                    if (typeof object.kickLocation !== "object")
                        throw TypeError(".proto.GameEvent.IndirectGoal.kickLocation: object expected");
                    message.kickLocation = $root.proto.Vector2.fromObject(object.kickLocation);
                }
                return message;
            };

            /**
             * Creates a plain object from an IndirectGoal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.IndirectGoal
             * @static
             * @param {proto.GameEvent.IndirectGoal} message IndirectGoal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IndirectGoal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                    object.kickLocation = null;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.kickLocation != null && message.hasOwnProperty("kickLocation"))
                    object.kickLocation = $root.proto.Vector2.toObject(message.kickLocation, options);
                return object;
            };

            /**
             * Converts this IndirectGoal to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.IndirectGoal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IndirectGoal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for IndirectGoal
             * @function getTypeUrl
             * @memberof proto.GameEvent.IndirectGoal
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            IndirectGoal.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.IndirectGoal";
            };

            return IndirectGoal;
        })();

        GameEvent.ChippedGoal = (function() {

            /**
             * Properties of a ChippedGoal.
             * @memberof proto.GameEvent
             * @interface IChippedGoal
             * @property {proto.Team} byTeam ChippedGoal byTeam
             * @property {number|null} [byBot] ChippedGoal byBot
             * @property {proto.IVector2|null} [location] ChippedGoal location
             * @property {proto.IVector2|null} [kickLocation] ChippedGoal kickLocation
             * @property {number|null} [maxBallHeight] ChippedGoal maxBallHeight
             */

            /**
             * Constructs a new ChippedGoal.
             * @memberof proto.GameEvent
             * @classdesc Represents a ChippedGoal.
             * @implements IChippedGoal
             * @constructor
             * @param {proto.GameEvent.IChippedGoal=} [properties] Properties to set
             */
            function ChippedGoal(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChippedGoal byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.ChippedGoal
             * @instance
             */
            ChippedGoal.prototype.byTeam = 0;

            /**
             * ChippedGoal byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.ChippedGoal
             * @instance
             */
            ChippedGoal.prototype.byBot = 0;

            /**
             * ChippedGoal location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.ChippedGoal
             * @instance
             */
            ChippedGoal.prototype.location = null;

            /**
             * ChippedGoal kickLocation.
             * @member {proto.IVector2|null|undefined} kickLocation
             * @memberof proto.GameEvent.ChippedGoal
             * @instance
             */
            ChippedGoal.prototype.kickLocation = null;

            /**
             * ChippedGoal maxBallHeight.
             * @member {number} maxBallHeight
             * @memberof proto.GameEvent.ChippedGoal
             * @instance
             */
            ChippedGoal.prototype.maxBallHeight = 0;

            /**
             * Creates a new ChippedGoal instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.ChippedGoal
             * @static
             * @param {proto.GameEvent.IChippedGoal=} [properties] Properties to set
             * @returns {proto.GameEvent.ChippedGoal} ChippedGoal instance
             */
            ChippedGoal.create = function create(properties) {
                return new ChippedGoal(properties);
            };

            /**
             * Encodes the specified ChippedGoal message. Does not implicitly {@link proto.GameEvent.ChippedGoal.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.ChippedGoal
             * @static
             * @param {proto.GameEvent.IChippedGoal} message ChippedGoal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChippedGoal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.kickLocation != null && Object.hasOwnProperty.call(message, "kickLocation"))
                    $root.proto.Vector2.encode(message.kickLocation, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.maxBallHeight != null && Object.hasOwnProperty.call(message, "maxBallHeight"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.maxBallHeight);
                return writer;
            };

            /**
             * Encodes the specified ChippedGoal message, length delimited. Does not implicitly {@link proto.GameEvent.ChippedGoal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.ChippedGoal
             * @static
             * @param {proto.GameEvent.IChippedGoal} message ChippedGoal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChippedGoal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChippedGoal message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.ChippedGoal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.ChippedGoal} ChippedGoal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChippedGoal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.ChippedGoal();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.kickLocation = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.maxBallHeight = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a ChippedGoal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.ChippedGoal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.ChippedGoal} ChippedGoal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChippedGoal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChippedGoal message.
             * @function verify
             * @memberof proto.GameEvent.ChippedGoal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChippedGoal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.kickLocation != null && message.hasOwnProperty("kickLocation")) {
                    let error = $root.proto.Vector2.verify(message.kickLocation);
                    if (error)
                        return "kickLocation." + error;
                }
                if (message.maxBallHeight != null && message.hasOwnProperty("maxBallHeight"))
                    if (typeof message.maxBallHeight !== "number")
                        return "maxBallHeight: number expected";
                return null;
            };

            /**
             * Creates a ChippedGoal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.ChippedGoal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.ChippedGoal} ChippedGoal
             */
            ChippedGoal.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.ChippedGoal)
                    return object;
                let message = new $root.proto.GameEvent.ChippedGoal();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.ChippedGoal.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.kickLocation != null) {
                    if (typeof object.kickLocation !== "object")
                        throw TypeError(".proto.GameEvent.ChippedGoal.kickLocation: object expected");
                    message.kickLocation = $root.proto.Vector2.fromObject(object.kickLocation);
                }
                if (object.maxBallHeight != null)
                    message.maxBallHeight = Number(object.maxBallHeight);
                return message;
            };

            /**
             * Creates a plain object from a ChippedGoal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.ChippedGoal
             * @static
             * @param {proto.GameEvent.ChippedGoal} message ChippedGoal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChippedGoal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                    object.kickLocation = null;
                    object.maxBallHeight = 0;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.kickLocation != null && message.hasOwnProperty("kickLocation"))
                    object.kickLocation = $root.proto.Vector2.toObject(message.kickLocation, options);
                if (message.maxBallHeight != null && message.hasOwnProperty("maxBallHeight"))
                    object.maxBallHeight = options.json && !isFinite(message.maxBallHeight) ? String(message.maxBallHeight) : message.maxBallHeight;
                return object;
            };

            /**
             * Converts this ChippedGoal to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.ChippedGoal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChippedGoal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ChippedGoal
             * @function getTypeUrl
             * @memberof proto.GameEvent.ChippedGoal
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ChippedGoal.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.ChippedGoal";
            };

            return ChippedGoal;
        })();

        GameEvent.BotTooFastInStop = (function() {

            /**
             * Properties of a BotTooFastInStop.
             * @memberof proto.GameEvent
             * @interface IBotTooFastInStop
             * @property {proto.Team} byTeam BotTooFastInStop byTeam
             * @property {number|null} [byBot] BotTooFastInStop byBot
             * @property {proto.IVector2|null} [location] BotTooFastInStop location
             * @property {number|null} [speed] BotTooFastInStop speed
             */

            /**
             * Constructs a new BotTooFastInStop.
             * @memberof proto.GameEvent
             * @classdesc Represents a BotTooFastInStop.
             * @implements IBotTooFastInStop
             * @constructor
             * @param {proto.GameEvent.IBotTooFastInStop=} [properties] Properties to set
             */
            function BotTooFastInStop(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BotTooFastInStop byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.BotTooFastInStop
             * @instance
             */
            BotTooFastInStop.prototype.byTeam = 0;

            /**
             * BotTooFastInStop byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.BotTooFastInStop
             * @instance
             */
            BotTooFastInStop.prototype.byBot = 0;

            /**
             * BotTooFastInStop location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.BotTooFastInStop
             * @instance
             */
            BotTooFastInStop.prototype.location = null;

            /**
             * BotTooFastInStop speed.
             * @member {number} speed
             * @memberof proto.GameEvent.BotTooFastInStop
             * @instance
             */
            BotTooFastInStop.prototype.speed = 0;

            /**
             * Creates a new BotTooFastInStop instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.BotTooFastInStop
             * @static
             * @param {proto.GameEvent.IBotTooFastInStop=} [properties] Properties to set
             * @returns {proto.GameEvent.BotTooFastInStop} BotTooFastInStop instance
             */
            BotTooFastInStop.create = function create(properties) {
                return new BotTooFastInStop(properties);
            };

            /**
             * Encodes the specified BotTooFastInStop message. Does not implicitly {@link proto.GameEvent.BotTooFastInStop.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.BotTooFastInStop
             * @static
             * @param {proto.GameEvent.IBotTooFastInStop} message BotTooFastInStop message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotTooFastInStop.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.speed);
                return writer;
            };

            /**
             * Encodes the specified BotTooFastInStop message, length delimited. Does not implicitly {@link proto.GameEvent.BotTooFastInStop.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.BotTooFastInStop
             * @static
             * @param {proto.GameEvent.IBotTooFastInStop} message BotTooFastInStop message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotTooFastInStop.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BotTooFastInStop message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.BotTooFastInStop
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.BotTooFastInStop} BotTooFastInStop
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotTooFastInStop.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.BotTooFastInStop();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.speed = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a BotTooFastInStop message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.BotTooFastInStop
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.BotTooFastInStop} BotTooFastInStop
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotTooFastInStop.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BotTooFastInStop message.
             * @function verify
             * @memberof proto.GameEvent.BotTooFastInStop
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BotTooFastInStop.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.speed != null && message.hasOwnProperty("speed"))
                    if (typeof message.speed !== "number")
                        return "speed: number expected";
                return null;
            };

            /**
             * Creates a BotTooFastInStop message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.BotTooFastInStop
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.BotTooFastInStop} BotTooFastInStop
             */
            BotTooFastInStop.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.BotTooFastInStop)
                    return object;
                let message = new $root.proto.GameEvent.BotTooFastInStop();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.BotTooFastInStop.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.speed != null)
                    message.speed = Number(object.speed);
                return message;
            };

            /**
             * Creates a plain object from a BotTooFastInStop message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.BotTooFastInStop
             * @static
             * @param {proto.GameEvent.BotTooFastInStop} message BotTooFastInStop
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BotTooFastInStop.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                    object.speed = 0;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.speed != null && message.hasOwnProperty("speed"))
                    object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
                return object;
            };

            /**
             * Converts this BotTooFastInStop to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.BotTooFastInStop
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BotTooFastInStop.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BotTooFastInStop
             * @function getTypeUrl
             * @memberof proto.GameEvent.BotTooFastInStop
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BotTooFastInStop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.BotTooFastInStop";
            };

            return BotTooFastInStop;
        })();

        GameEvent.DefenderTooCloseToKickPoint = (function() {

            /**
             * Properties of a DefenderTooCloseToKickPoint.
             * @memberof proto.GameEvent
             * @interface IDefenderTooCloseToKickPoint
             * @property {proto.Team} byTeam DefenderTooCloseToKickPoint byTeam
             * @property {number|null} [byBot] DefenderTooCloseToKickPoint byBot
             * @property {proto.IVector2|null} [location] DefenderTooCloseToKickPoint location
             * @property {number|null} [distance] DefenderTooCloseToKickPoint distance
             */

            /**
             * Constructs a new DefenderTooCloseToKickPoint.
             * @memberof proto.GameEvent
             * @classdesc Represents a DefenderTooCloseToKickPoint.
             * @implements IDefenderTooCloseToKickPoint
             * @constructor
             * @param {proto.GameEvent.IDefenderTooCloseToKickPoint=} [properties] Properties to set
             */
            function DefenderTooCloseToKickPoint(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DefenderTooCloseToKickPoint byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @instance
             */
            DefenderTooCloseToKickPoint.prototype.byTeam = 0;

            /**
             * DefenderTooCloseToKickPoint byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @instance
             */
            DefenderTooCloseToKickPoint.prototype.byBot = 0;

            /**
             * DefenderTooCloseToKickPoint location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @instance
             */
            DefenderTooCloseToKickPoint.prototype.location = null;

            /**
             * DefenderTooCloseToKickPoint distance.
             * @member {number} distance
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @instance
             */
            DefenderTooCloseToKickPoint.prototype.distance = 0;

            /**
             * Creates a new DefenderTooCloseToKickPoint instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @static
             * @param {proto.GameEvent.IDefenderTooCloseToKickPoint=} [properties] Properties to set
             * @returns {proto.GameEvent.DefenderTooCloseToKickPoint} DefenderTooCloseToKickPoint instance
             */
            DefenderTooCloseToKickPoint.create = function create(properties) {
                return new DefenderTooCloseToKickPoint(properties);
            };

            /**
             * Encodes the specified DefenderTooCloseToKickPoint message. Does not implicitly {@link proto.GameEvent.DefenderTooCloseToKickPoint.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @static
             * @param {proto.GameEvent.IDefenderTooCloseToKickPoint} message DefenderTooCloseToKickPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DefenderTooCloseToKickPoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.distance);
                return writer;
            };

            /**
             * Encodes the specified DefenderTooCloseToKickPoint message, length delimited. Does not implicitly {@link proto.GameEvent.DefenderTooCloseToKickPoint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @static
             * @param {proto.GameEvent.IDefenderTooCloseToKickPoint} message DefenderTooCloseToKickPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DefenderTooCloseToKickPoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DefenderTooCloseToKickPoint message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.DefenderTooCloseToKickPoint} DefenderTooCloseToKickPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DefenderTooCloseToKickPoint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.DefenderTooCloseToKickPoint();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.distance = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a DefenderTooCloseToKickPoint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.DefenderTooCloseToKickPoint} DefenderTooCloseToKickPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DefenderTooCloseToKickPoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DefenderTooCloseToKickPoint message.
             * @function verify
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DefenderTooCloseToKickPoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.distance != null && message.hasOwnProperty("distance"))
                    if (typeof message.distance !== "number")
                        return "distance: number expected";
                return null;
            };

            /**
             * Creates a DefenderTooCloseToKickPoint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.DefenderTooCloseToKickPoint} DefenderTooCloseToKickPoint
             */
            DefenderTooCloseToKickPoint.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.DefenderTooCloseToKickPoint)
                    return object;
                let message = new $root.proto.GameEvent.DefenderTooCloseToKickPoint();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.DefenderTooCloseToKickPoint.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.distance != null)
                    message.distance = Number(object.distance);
                return message;
            };

            /**
             * Creates a plain object from a DefenderTooCloseToKickPoint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @static
             * @param {proto.GameEvent.DefenderTooCloseToKickPoint} message DefenderTooCloseToKickPoint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DefenderTooCloseToKickPoint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                    object.distance = 0;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.distance != null && message.hasOwnProperty("distance"))
                    object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
                return object;
            };

            /**
             * Converts this DefenderTooCloseToKickPoint to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DefenderTooCloseToKickPoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DefenderTooCloseToKickPoint
             * @function getTypeUrl
             * @memberof proto.GameEvent.DefenderTooCloseToKickPoint
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DefenderTooCloseToKickPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.DefenderTooCloseToKickPoint";
            };

            return DefenderTooCloseToKickPoint;
        })();

        GameEvent.BotCrashDrawn = (function() {

            /**
             * Properties of a BotCrashDrawn.
             * @memberof proto.GameEvent
             * @interface IBotCrashDrawn
             * @property {number|null} [botYellow] BotCrashDrawn botYellow
             * @property {number|null} [botBlue] BotCrashDrawn botBlue
             * @property {proto.IVector2|null} [location] BotCrashDrawn location
             * @property {number|null} [crashSpeed] BotCrashDrawn crashSpeed
             * @property {number|null} [speedDiff] BotCrashDrawn speedDiff
             * @property {number|null} [crashAngle] BotCrashDrawn crashAngle
             */

            /**
             * Constructs a new BotCrashDrawn.
             * @memberof proto.GameEvent
             * @classdesc Represents a BotCrashDrawn.
             * @implements IBotCrashDrawn
             * @constructor
             * @param {proto.GameEvent.IBotCrashDrawn=} [properties] Properties to set
             */
            function BotCrashDrawn(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BotCrashDrawn botYellow.
             * @member {number} botYellow
             * @memberof proto.GameEvent.BotCrashDrawn
             * @instance
             */
            BotCrashDrawn.prototype.botYellow = 0;

            /**
             * BotCrashDrawn botBlue.
             * @member {number} botBlue
             * @memberof proto.GameEvent.BotCrashDrawn
             * @instance
             */
            BotCrashDrawn.prototype.botBlue = 0;

            /**
             * BotCrashDrawn location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.BotCrashDrawn
             * @instance
             */
            BotCrashDrawn.prototype.location = null;

            /**
             * BotCrashDrawn crashSpeed.
             * @member {number} crashSpeed
             * @memberof proto.GameEvent.BotCrashDrawn
             * @instance
             */
            BotCrashDrawn.prototype.crashSpeed = 0;

            /**
             * BotCrashDrawn speedDiff.
             * @member {number} speedDiff
             * @memberof proto.GameEvent.BotCrashDrawn
             * @instance
             */
            BotCrashDrawn.prototype.speedDiff = 0;

            /**
             * BotCrashDrawn crashAngle.
             * @member {number} crashAngle
             * @memberof proto.GameEvent.BotCrashDrawn
             * @instance
             */
            BotCrashDrawn.prototype.crashAngle = 0;

            /**
             * Creates a new BotCrashDrawn instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.BotCrashDrawn
             * @static
             * @param {proto.GameEvent.IBotCrashDrawn=} [properties] Properties to set
             * @returns {proto.GameEvent.BotCrashDrawn} BotCrashDrawn instance
             */
            BotCrashDrawn.create = function create(properties) {
                return new BotCrashDrawn(properties);
            };

            /**
             * Encodes the specified BotCrashDrawn message. Does not implicitly {@link proto.GameEvent.BotCrashDrawn.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.BotCrashDrawn
             * @static
             * @param {proto.GameEvent.IBotCrashDrawn} message BotCrashDrawn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotCrashDrawn.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.botYellow != null && Object.hasOwnProperty.call(message, "botYellow"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.botYellow);
                if (message.botBlue != null && Object.hasOwnProperty.call(message, "botBlue"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.botBlue);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.crashSpeed != null && Object.hasOwnProperty.call(message, "crashSpeed"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.crashSpeed);
                if (message.speedDiff != null && Object.hasOwnProperty.call(message, "speedDiff"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.speedDiff);
                if (message.crashAngle != null && Object.hasOwnProperty.call(message, "crashAngle"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.crashAngle);
                return writer;
            };

            /**
             * Encodes the specified BotCrashDrawn message, length delimited. Does not implicitly {@link proto.GameEvent.BotCrashDrawn.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.BotCrashDrawn
             * @static
             * @param {proto.GameEvent.IBotCrashDrawn} message BotCrashDrawn message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotCrashDrawn.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BotCrashDrawn message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.BotCrashDrawn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.BotCrashDrawn} BotCrashDrawn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotCrashDrawn.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.BotCrashDrawn();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.botYellow = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.botBlue = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.crashSpeed = reader.float();
                            break;
                        }
                    case 5: {
                            message.speedDiff = reader.float();
                            break;
                        }
                    case 6: {
                            message.crashAngle = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BotCrashDrawn message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.BotCrashDrawn
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.BotCrashDrawn} BotCrashDrawn
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotCrashDrawn.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BotCrashDrawn message.
             * @function verify
             * @memberof proto.GameEvent.BotCrashDrawn
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BotCrashDrawn.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.botYellow != null && message.hasOwnProperty("botYellow"))
                    if (!$util.isInteger(message.botYellow))
                        return "botYellow: integer expected";
                if (message.botBlue != null && message.hasOwnProperty("botBlue"))
                    if (!$util.isInteger(message.botBlue))
                        return "botBlue: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.crashSpeed != null && message.hasOwnProperty("crashSpeed"))
                    if (typeof message.crashSpeed !== "number")
                        return "crashSpeed: number expected";
                if (message.speedDiff != null && message.hasOwnProperty("speedDiff"))
                    if (typeof message.speedDiff !== "number")
                        return "speedDiff: number expected";
                if (message.crashAngle != null && message.hasOwnProperty("crashAngle"))
                    if (typeof message.crashAngle !== "number")
                        return "crashAngle: number expected";
                return null;
            };

            /**
             * Creates a BotCrashDrawn message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.BotCrashDrawn
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.BotCrashDrawn} BotCrashDrawn
             */
            BotCrashDrawn.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.BotCrashDrawn)
                    return object;
                let message = new $root.proto.GameEvent.BotCrashDrawn();
                if (object.botYellow != null)
                    message.botYellow = object.botYellow >>> 0;
                if (object.botBlue != null)
                    message.botBlue = object.botBlue >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.BotCrashDrawn.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.crashSpeed != null)
                    message.crashSpeed = Number(object.crashSpeed);
                if (object.speedDiff != null)
                    message.speedDiff = Number(object.speedDiff);
                if (object.crashAngle != null)
                    message.crashAngle = Number(object.crashAngle);
                return message;
            };

            /**
             * Creates a plain object from a BotCrashDrawn message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.BotCrashDrawn
             * @static
             * @param {proto.GameEvent.BotCrashDrawn} message BotCrashDrawn
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BotCrashDrawn.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.botYellow = 0;
                    object.botBlue = 0;
                    object.location = null;
                    object.crashSpeed = 0;
                    object.speedDiff = 0;
                    object.crashAngle = 0;
                }
                if (message.botYellow != null && message.hasOwnProperty("botYellow"))
                    object.botYellow = message.botYellow;
                if (message.botBlue != null && message.hasOwnProperty("botBlue"))
                    object.botBlue = message.botBlue;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.crashSpeed != null && message.hasOwnProperty("crashSpeed"))
                    object.crashSpeed = options.json && !isFinite(message.crashSpeed) ? String(message.crashSpeed) : message.crashSpeed;
                if (message.speedDiff != null && message.hasOwnProperty("speedDiff"))
                    object.speedDiff = options.json && !isFinite(message.speedDiff) ? String(message.speedDiff) : message.speedDiff;
                if (message.crashAngle != null && message.hasOwnProperty("crashAngle"))
                    object.crashAngle = options.json && !isFinite(message.crashAngle) ? String(message.crashAngle) : message.crashAngle;
                return object;
            };

            /**
             * Converts this BotCrashDrawn to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.BotCrashDrawn
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BotCrashDrawn.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BotCrashDrawn
             * @function getTypeUrl
             * @memberof proto.GameEvent.BotCrashDrawn
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BotCrashDrawn.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.BotCrashDrawn";
            };

            return BotCrashDrawn;
        })();

        GameEvent.BotCrashUnique = (function() {

            /**
             * Properties of a BotCrashUnique.
             * @memberof proto.GameEvent
             * @interface IBotCrashUnique
             * @property {proto.Team} byTeam BotCrashUnique byTeam
             * @property {number|null} [violator] BotCrashUnique violator
             * @property {number|null} [victim] BotCrashUnique victim
             * @property {proto.IVector2|null} [location] BotCrashUnique location
             * @property {number|null} [crashSpeed] BotCrashUnique crashSpeed
             * @property {number|null} [speedDiff] BotCrashUnique speedDiff
             * @property {number|null} [crashAngle] BotCrashUnique crashAngle
             */

            /**
             * Constructs a new BotCrashUnique.
             * @memberof proto.GameEvent
             * @classdesc Represents a BotCrashUnique.
             * @implements IBotCrashUnique
             * @constructor
             * @param {proto.GameEvent.IBotCrashUnique=} [properties] Properties to set
             */
            function BotCrashUnique(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BotCrashUnique byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.BotCrashUnique
             * @instance
             */
            BotCrashUnique.prototype.byTeam = 0;

            /**
             * BotCrashUnique violator.
             * @member {number} violator
             * @memberof proto.GameEvent.BotCrashUnique
             * @instance
             */
            BotCrashUnique.prototype.violator = 0;

            /**
             * BotCrashUnique victim.
             * @member {number} victim
             * @memberof proto.GameEvent.BotCrashUnique
             * @instance
             */
            BotCrashUnique.prototype.victim = 0;

            /**
             * BotCrashUnique location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.BotCrashUnique
             * @instance
             */
            BotCrashUnique.prototype.location = null;

            /**
             * BotCrashUnique crashSpeed.
             * @member {number} crashSpeed
             * @memberof proto.GameEvent.BotCrashUnique
             * @instance
             */
            BotCrashUnique.prototype.crashSpeed = 0;

            /**
             * BotCrashUnique speedDiff.
             * @member {number} speedDiff
             * @memberof proto.GameEvent.BotCrashUnique
             * @instance
             */
            BotCrashUnique.prototype.speedDiff = 0;

            /**
             * BotCrashUnique crashAngle.
             * @member {number} crashAngle
             * @memberof proto.GameEvent.BotCrashUnique
             * @instance
             */
            BotCrashUnique.prototype.crashAngle = 0;

            /**
             * Creates a new BotCrashUnique instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.BotCrashUnique
             * @static
             * @param {proto.GameEvent.IBotCrashUnique=} [properties] Properties to set
             * @returns {proto.GameEvent.BotCrashUnique} BotCrashUnique instance
             */
            BotCrashUnique.create = function create(properties) {
                return new BotCrashUnique(properties);
            };

            /**
             * Encodes the specified BotCrashUnique message. Does not implicitly {@link proto.GameEvent.BotCrashUnique.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.BotCrashUnique
             * @static
             * @param {proto.GameEvent.IBotCrashUnique} message BotCrashUnique message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotCrashUnique.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.violator != null && Object.hasOwnProperty.call(message, "violator"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.violator);
                if (message.victim != null && Object.hasOwnProperty.call(message, "victim"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.victim);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.crashSpeed != null && Object.hasOwnProperty.call(message, "crashSpeed"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.crashSpeed);
                if (message.speedDiff != null && Object.hasOwnProperty.call(message, "speedDiff"))
                    writer.uint32(/* id 6, wireType 5 =*/53).float(message.speedDiff);
                if (message.crashAngle != null && Object.hasOwnProperty.call(message, "crashAngle"))
                    writer.uint32(/* id 7, wireType 5 =*/61).float(message.crashAngle);
                return writer;
            };

            /**
             * Encodes the specified BotCrashUnique message, length delimited. Does not implicitly {@link proto.GameEvent.BotCrashUnique.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.BotCrashUnique
             * @static
             * @param {proto.GameEvent.IBotCrashUnique} message BotCrashUnique message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotCrashUnique.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BotCrashUnique message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.BotCrashUnique
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.BotCrashUnique} BotCrashUnique
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotCrashUnique.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.BotCrashUnique();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.violator = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.victim = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.crashSpeed = reader.float();
                            break;
                        }
                    case 6: {
                            message.speedDiff = reader.float();
                            break;
                        }
                    case 7: {
                            message.crashAngle = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a BotCrashUnique message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.BotCrashUnique
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.BotCrashUnique} BotCrashUnique
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotCrashUnique.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BotCrashUnique message.
             * @function verify
             * @memberof proto.GameEvent.BotCrashUnique
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BotCrashUnique.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.violator != null && message.hasOwnProperty("violator"))
                    if (!$util.isInteger(message.violator))
                        return "violator: integer expected";
                if (message.victim != null && message.hasOwnProperty("victim"))
                    if (!$util.isInteger(message.victim))
                        return "victim: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.crashSpeed != null && message.hasOwnProperty("crashSpeed"))
                    if (typeof message.crashSpeed !== "number")
                        return "crashSpeed: number expected";
                if (message.speedDiff != null && message.hasOwnProperty("speedDiff"))
                    if (typeof message.speedDiff !== "number")
                        return "speedDiff: number expected";
                if (message.crashAngle != null && message.hasOwnProperty("crashAngle"))
                    if (typeof message.crashAngle !== "number")
                        return "crashAngle: number expected";
                return null;
            };

            /**
             * Creates a BotCrashUnique message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.BotCrashUnique
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.BotCrashUnique} BotCrashUnique
             */
            BotCrashUnique.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.BotCrashUnique)
                    return object;
                let message = new $root.proto.GameEvent.BotCrashUnique();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.violator != null)
                    message.violator = object.violator >>> 0;
                if (object.victim != null)
                    message.victim = object.victim >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.BotCrashUnique.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.crashSpeed != null)
                    message.crashSpeed = Number(object.crashSpeed);
                if (object.speedDiff != null)
                    message.speedDiff = Number(object.speedDiff);
                if (object.crashAngle != null)
                    message.crashAngle = Number(object.crashAngle);
                return message;
            };

            /**
             * Creates a plain object from a BotCrashUnique message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.BotCrashUnique
             * @static
             * @param {proto.GameEvent.BotCrashUnique} message BotCrashUnique
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BotCrashUnique.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.violator = 0;
                    object.victim = 0;
                    object.location = null;
                    object.crashSpeed = 0;
                    object.speedDiff = 0;
                    object.crashAngle = 0;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.violator != null && message.hasOwnProperty("violator"))
                    object.violator = message.violator;
                if (message.victim != null && message.hasOwnProperty("victim"))
                    object.victim = message.victim;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.crashSpeed != null && message.hasOwnProperty("crashSpeed"))
                    object.crashSpeed = options.json && !isFinite(message.crashSpeed) ? String(message.crashSpeed) : message.crashSpeed;
                if (message.speedDiff != null && message.hasOwnProperty("speedDiff"))
                    object.speedDiff = options.json && !isFinite(message.speedDiff) ? String(message.speedDiff) : message.speedDiff;
                if (message.crashAngle != null && message.hasOwnProperty("crashAngle"))
                    object.crashAngle = options.json && !isFinite(message.crashAngle) ? String(message.crashAngle) : message.crashAngle;
                return object;
            };

            /**
             * Converts this BotCrashUnique to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.BotCrashUnique
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BotCrashUnique.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BotCrashUnique
             * @function getTypeUrl
             * @memberof proto.GameEvent.BotCrashUnique
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BotCrashUnique.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.BotCrashUnique";
            };

            return BotCrashUnique;
        })();

        GameEvent.BotPushedBot = (function() {

            /**
             * Properties of a BotPushedBot.
             * @memberof proto.GameEvent
             * @interface IBotPushedBot
             * @property {proto.Team} byTeam BotPushedBot byTeam
             * @property {number|null} [violator] BotPushedBot violator
             * @property {number|null} [victim] BotPushedBot victim
             * @property {proto.IVector2|null} [location] BotPushedBot location
             * @property {number|null} [pushedDistance] BotPushedBot pushedDistance
             */

            /**
             * Constructs a new BotPushedBot.
             * @memberof proto.GameEvent
             * @classdesc Represents a BotPushedBot.
             * @implements IBotPushedBot
             * @constructor
             * @param {proto.GameEvent.IBotPushedBot=} [properties] Properties to set
             */
            function BotPushedBot(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BotPushedBot byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.BotPushedBot
             * @instance
             */
            BotPushedBot.prototype.byTeam = 0;

            /**
             * BotPushedBot violator.
             * @member {number} violator
             * @memberof proto.GameEvent.BotPushedBot
             * @instance
             */
            BotPushedBot.prototype.violator = 0;

            /**
             * BotPushedBot victim.
             * @member {number} victim
             * @memberof proto.GameEvent.BotPushedBot
             * @instance
             */
            BotPushedBot.prototype.victim = 0;

            /**
             * BotPushedBot location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.BotPushedBot
             * @instance
             */
            BotPushedBot.prototype.location = null;

            /**
             * BotPushedBot pushedDistance.
             * @member {number} pushedDistance
             * @memberof proto.GameEvent.BotPushedBot
             * @instance
             */
            BotPushedBot.prototype.pushedDistance = 0;

            /**
             * Creates a new BotPushedBot instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.BotPushedBot
             * @static
             * @param {proto.GameEvent.IBotPushedBot=} [properties] Properties to set
             * @returns {proto.GameEvent.BotPushedBot} BotPushedBot instance
             */
            BotPushedBot.create = function create(properties) {
                return new BotPushedBot(properties);
            };

            /**
             * Encodes the specified BotPushedBot message. Does not implicitly {@link proto.GameEvent.BotPushedBot.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.BotPushedBot
             * @static
             * @param {proto.GameEvent.IBotPushedBot} message BotPushedBot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotPushedBot.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.violator != null && Object.hasOwnProperty.call(message, "violator"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.violator);
                if (message.victim != null && Object.hasOwnProperty.call(message, "victim"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.victim);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.pushedDistance != null && Object.hasOwnProperty.call(message, "pushedDistance"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.pushedDistance);
                return writer;
            };

            /**
             * Encodes the specified BotPushedBot message, length delimited. Does not implicitly {@link proto.GameEvent.BotPushedBot.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.BotPushedBot
             * @static
             * @param {proto.GameEvent.IBotPushedBot} message BotPushedBot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotPushedBot.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BotPushedBot message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.BotPushedBot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.BotPushedBot} BotPushedBot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotPushedBot.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.BotPushedBot();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.violator = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.victim = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.pushedDistance = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a BotPushedBot message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.BotPushedBot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.BotPushedBot} BotPushedBot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotPushedBot.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BotPushedBot message.
             * @function verify
             * @memberof proto.GameEvent.BotPushedBot
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BotPushedBot.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.violator != null && message.hasOwnProperty("violator"))
                    if (!$util.isInteger(message.violator))
                        return "violator: integer expected";
                if (message.victim != null && message.hasOwnProperty("victim"))
                    if (!$util.isInteger(message.victim))
                        return "victim: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.pushedDistance != null && message.hasOwnProperty("pushedDistance"))
                    if (typeof message.pushedDistance !== "number")
                        return "pushedDistance: number expected";
                return null;
            };

            /**
             * Creates a BotPushedBot message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.BotPushedBot
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.BotPushedBot} BotPushedBot
             */
            BotPushedBot.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.BotPushedBot)
                    return object;
                let message = new $root.proto.GameEvent.BotPushedBot();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.violator != null)
                    message.violator = object.violator >>> 0;
                if (object.victim != null)
                    message.victim = object.victim >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.BotPushedBot.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.pushedDistance != null)
                    message.pushedDistance = Number(object.pushedDistance);
                return message;
            };

            /**
             * Creates a plain object from a BotPushedBot message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.BotPushedBot
             * @static
             * @param {proto.GameEvent.BotPushedBot} message BotPushedBot
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BotPushedBot.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.violator = 0;
                    object.victim = 0;
                    object.location = null;
                    object.pushedDistance = 0;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.violator != null && message.hasOwnProperty("violator"))
                    object.violator = message.violator;
                if (message.victim != null && message.hasOwnProperty("victim"))
                    object.victim = message.victim;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.pushedDistance != null && message.hasOwnProperty("pushedDistance"))
                    object.pushedDistance = options.json && !isFinite(message.pushedDistance) ? String(message.pushedDistance) : message.pushedDistance;
                return object;
            };

            /**
             * Converts this BotPushedBot to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.BotPushedBot
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BotPushedBot.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BotPushedBot
             * @function getTypeUrl
             * @memberof proto.GameEvent.BotPushedBot
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BotPushedBot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.BotPushedBot";
            };

            return BotPushedBot;
        })();

        GameEvent.BotTippedOver = (function() {

            /**
             * Properties of a BotTippedOver.
             * @memberof proto.GameEvent
             * @interface IBotTippedOver
             * @property {proto.Team} byTeam BotTippedOver byTeam
             * @property {number|null} [byBot] BotTippedOver byBot
             * @property {proto.IVector2|null} [location] BotTippedOver location
             * @property {proto.IVector2|null} [ballLocation] BotTippedOver ballLocation
             */

            /**
             * Constructs a new BotTippedOver.
             * @memberof proto.GameEvent
             * @classdesc Represents a BotTippedOver.
             * @implements IBotTippedOver
             * @constructor
             * @param {proto.GameEvent.IBotTippedOver=} [properties] Properties to set
             */
            function BotTippedOver(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BotTippedOver byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.BotTippedOver
             * @instance
             */
            BotTippedOver.prototype.byTeam = 0;

            /**
             * BotTippedOver byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.BotTippedOver
             * @instance
             */
            BotTippedOver.prototype.byBot = 0;

            /**
             * BotTippedOver location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.BotTippedOver
             * @instance
             */
            BotTippedOver.prototype.location = null;

            /**
             * BotTippedOver ballLocation.
             * @member {proto.IVector2|null|undefined} ballLocation
             * @memberof proto.GameEvent.BotTippedOver
             * @instance
             */
            BotTippedOver.prototype.ballLocation = null;

            /**
             * Creates a new BotTippedOver instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.BotTippedOver
             * @static
             * @param {proto.GameEvent.IBotTippedOver=} [properties] Properties to set
             * @returns {proto.GameEvent.BotTippedOver} BotTippedOver instance
             */
            BotTippedOver.create = function create(properties) {
                return new BotTippedOver(properties);
            };

            /**
             * Encodes the specified BotTippedOver message. Does not implicitly {@link proto.GameEvent.BotTippedOver.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.BotTippedOver
             * @static
             * @param {proto.GameEvent.IBotTippedOver} message BotTippedOver message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotTippedOver.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.ballLocation != null && Object.hasOwnProperty.call(message, "ballLocation"))
                    $root.proto.Vector2.encode(message.ballLocation, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BotTippedOver message, length delimited. Does not implicitly {@link proto.GameEvent.BotTippedOver.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.BotTippedOver
             * @static
             * @param {proto.GameEvent.IBotTippedOver} message BotTippedOver message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotTippedOver.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BotTippedOver message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.BotTippedOver
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.BotTippedOver} BotTippedOver
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotTippedOver.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.BotTippedOver();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.ballLocation = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a BotTippedOver message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.BotTippedOver
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.BotTippedOver} BotTippedOver
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotTippedOver.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BotTippedOver message.
             * @function verify
             * @memberof proto.GameEvent.BotTippedOver
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BotTippedOver.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.ballLocation != null && message.hasOwnProperty("ballLocation")) {
                    let error = $root.proto.Vector2.verify(message.ballLocation);
                    if (error)
                        return "ballLocation." + error;
                }
                return null;
            };

            /**
             * Creates a BotTippedOver message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.BotTippedOver
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.BotTippedOver} BotTippedOver
             */
            BotTippedOver.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.BotTippedOver)
                    return object;
                let message = new $root.proto.GameEvent.BotTippedOver();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.BotTippedOver.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.ballLocation != null) {
                    if (typeof object.ballLocation !== "object")
                        throw TypeError(".proto.GameEvent.BotTippedOver.ballLocation: object expected");
                    message.ballLocation = $root.proto.Vector2.fromObject(object.ballLocation);
                }
                return message;
            };

            /**
             * Creates a plain object from a BotTippedOver message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.BotTippedOver
             * @static
             * @param {proto.GameEvent.BotTippedOver} message BotTippedOver
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BotTippedOver.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                    object.ballLocation = null;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.ballLocation != null && message.hasOwnProperty("ballLocation"))
                    object.ballLocation = $root.proto.Vector2.toObject(message.ballLocation, options);
                return object;
            };

            /**
             * Converts this BotTippedOver to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.BotTippedOver
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BotTippedOver.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BotTippedOver
             * @function getTypeUrl
             * @memberof proto.GameEvent.BotTippedOver
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BotTippedOver.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.BotTippedOver";
            };

            return BotTippedOver;
        })();

        GameEvent.DefenderInDefenseArea = (function() {

            /**
             * Properties of a DefenderInDefenseArea.
             * @memberof proto.GameEvent
             * @interface IDefenderInDefenseArea
             * @property {proto.Team} byTeam DefenderInDefenseArea byTeam
             * @property {number|null} [byBot] DefenderInDefenseArea byBot
             * @property {proto.IVector2|null} [location] DefenderInDefenseArea location
             * @property {number|null} [distance] DefenderInDefenseArea distance
             */

            /**
             * Constructs a new DefenderInDefenseArea.
             * @memberof proto.GameEvent
             * @classdesc Represents a DefenderInDefenseArea.
             * @implements IDefenderInDefenseArea
             * @constructor
             * @param {proto.GameEvent.IDefenderInDefenseArea=} [properties] Properties to set
             */
            function DefenderInDefenseArea(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DefenderInDefenseArea byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @instance
             */
            DefenderInDefenseArea.prototype.byTeam = 0;

            /**
             * DefenderInDefenseArea byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @instance
             */
            DefenderInDefenseArea.prototype.byBot = 0;

            /**
             * DefenderInDefenseArea location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @instance
             */
            DefenderInDefenseArea.prototype.location = null;

            /**
             * DefenderInDefenseArea distance.
             * @member {number} distance
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @instance
             */
            DefenderInDefenseArea.prototype.distance = 0;

            /**
             * Creates a new DefenderInDefenseArea instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @static
             * @param {proto.GameEvent.IDefenderInDefenseArea=} [properties] Properties to set
             * @returns {proto.GameEvent.DefenderInDefenseArea} DefenderInDefenseArea instance
             */
            DefenderInDefenseArea.create = function create(properties) {
                return new DefenderInDefenseArea(properties);
            };

            /**
             * Encodes the specified DefenderInDefenseArea message. Does not implicitly {@link proto.GameEvent.DefenderInDefenseArea.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @static
             * @param {proto.GameEvent.IDefenderInDefenseArea} message DefenderInDefenseArea message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DefenderInDefenseArea.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.distance);
                return writer;
            };

            /**
             * Encodes the specified DefenderInDefenseArea message, length delimited. Does not implicitly {@link proto.GameEvent.DefenderInDefenseArea.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @static
             * @param {proto.GameEvent.IDefenderInDefenseArea} message DefenderInDefenseArea message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DefenderInDefenseArea.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DefenderInDefenseArea message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.DefenderInDefenseArea} DefenderInDefenseArea
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DefenderInDefenseArea.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.DefenderInDefenseArea();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.distance = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a DefenderInDefenseArea message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.DefenderInDefenseArea} DefenderInDefenseArea
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DefenderInDefenseArea.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DefenderInDefenseArea message.
             * @function verify
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DefenderInDefenseArea.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.distance != null && message.hasOwnProperty("distance"))
                    if (typeof message.distance !== "number")
                        return "distance: number expected";
                return null;
            };

            /**
             * Creates a DefenderInDefenseArea message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.DefenderInDefenseArea} DefenderInDefenseArea
             */
            DefenderInDefenseArea.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.DefenderInDefenseArea)
                    return object;
                let message = new $root.proto.GameEvent.DefenderInDefenseArea();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.DefenderInDefenseArea.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.distance != null)
                    message.distance = Number(object.distance);
                return message;
            };

            /**
             * Creates a plain object from a DefenderInDefenseArea message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @static
             * @param {proto.GameEvent.DefenderInDefenseArea} message DefenderInDefenseArea
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DefenderInDefenseArea.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                    object.distance = 0;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.distance != null && message.hasOwnProperty("distance"))
                    object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
                return object;
            };

            /**
             * Converts this DefenderInDefenseArea to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DefenderInDefenseArea.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DefenderInDefenseArea
             * @function getTypeUrl
             * @memberof proto.GameEvent.DefenderInDefenseArea
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DefenderInDefenseArea.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.DefenderInDefenseArea";
            };

            return DefenderInDefenseArea;
        })();

        GameEvent.DefenderInDefenseAreaPartially = (function() {

            /**
             * Properties of a DefenderInDefenseAreaPartially.
             * @memberof proto.GameEvent
             * @interface IDefenderInDefenseAreaPartially
             * @property {proto.Team} byTeam DefenderInDefenseAreaPartially byTeam
             * @property {number|null} [byBot] DefenderInDefenseAreaPartially byBot
             * @property {proto.IVector2|null} [location] DefenderInDefenseAreaPartially location
             * @property {number|null} [distance] DefenderInDefenseAreaPartially distance
             * @property {proto.IVector2|null} [ballLocation] DefenderInDefenseAreaPartially ballLocation
             */

            /**
             * Constructs a new DefenderInDefenseAreaPartially.
             * @memberof proto.GameEvent
             * @classdesc Represents a DefenderInDefenseAreaPartially.
             * @implements IDefenderInDefenseAreaPartially
             * @constructor
             * @param {proto.GameEvent.IDefenderInDefenseAreaPartially=} [properties] Properties to set
             */
            function DefenderInDefenseAreaPartially(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DefenderInDefenseAreaPartially byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @instance
             */
            DefenderInDefenseAreaPartially.prototype.byTeam = 0;

            /**
             * DefenderInDefenseAreaPartially byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @instance
             */
            DefenderInDefenseAreaPartially.prototype.byBot = 0;

            /**
             * DefenderInDefenseAreaPartially location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @instance
             */
            DefenderInDefenseAreaPartially.prototype.location = null;

            /**
             * DefenderInDefenseAreaPartially distance.
             * @member {number} distance
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @instance
             */
            DefenderInDefenseAreaPartially.prototype.distance = 0;

            /**
             * DefenderInDefenseAreaPartially ballLocation.
             * @member {proto.IVector2|null|undefined} ballLocation
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @instance
             */
            DefenderInDefenseAreaPartially.prototype.ballLocation = null;

            /**
             * Creates a new DefenderInDefenseAreaPartially instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @static
             * @param {proto.GameEvent.IDefenderInDefenseAreaPartially=} [properties] Properties to set
             * @returns {proto.GameEvent.DefenderInDefenseAreaPartially} DefenderInDefenseAreaPartially instance
             */
            DefenderInDefenseAreaPartially.create = function create(properties) {
                return new DefenderInDefenseAreaPartially(properties);
            };

            /**
             * Encodes the specified DefenderInDefenseAreaPartially message. Does not implicitly {@link proto.GameEvent.DefenderInDefenseAreaPartially.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @static
             * @param {proto.GameEvent.IDefenderInDefenseAreaPartially} message DefenderInDefenseAreaPartially message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DefenderInDefenseAreaPartially.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.distance);
                if (message.ballLocation != null && Object.hasOwnProperty.call(message, "ballLocation"))
                    $root.proto.Vector2.encode(message.ballLocation, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DefenderInDefenseAreaPartially message, length delimited. Does not implicitly {@link proto.GameEvent.DefenderInDefenseAreaPartially.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @static
             * @param {proto.GameEvent.IDefenderInDefenseAreaPartially} message DefenderInDefenseAreaPartially message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DefenderInDefenseAreaPartially.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DefenderInDefenseAreaPartially message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.DefenderInDefenseAreaPartially} DefenderInDefenseAreaPartially
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DefenderInDefenseAreaPartially.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.DefenderInDefenseAreaPartially();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.distance = reader.float();
                            break;
                        }
                    case 5: {
                            message.ballLocation = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a DefenderInDefenseAreaPartially message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.DefenderInDefenseAreaPartially} DefenderInDefenseAreaPartially
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DefenderInDefenseAreaPartially.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DefenderInDefenseAreaPartially message.
             * @function verify
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DefenderInDefenseAreaPartially.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.distance != null && message.hasOwnProperty("distance"))
                    if (typeof message.distance !== "number")
                        return "distance: number expected";
                if (message.ballLocation != null && message.hasOwnProperty("ballLocation")) {
                    let error = $root.proto.Vector2.verify(message.ballLocation);
                    if (error)
                        return "ballLocation." + error;
                }
                return null;
            };

            /**
             * Creates a DefenderInDefenseAreaPartially message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.DefenderInDefenseAreaPartially} DefenderInDefenseAreaPartially
             */
            DefenderInDefenseAreaPartially.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.DefenderInDefenseAreaPartially)
                    return object;
                let message = new $root.proto.GameEvent.DefenderInDefenseAreaPartially();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.DefenderInDefenseAreaPartially.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.distance != null)
                    message.distance = Number(object.distance);
                if (object.ballLocation != null) {
                    if (typeof object.ballLocation !== "object")
                        throw TypeError(".proto.GameEvent.DefenderInDefenseAreaPartially.ballLocation: object expected");
                    message.ballLocation = $root.proto.Vector2.fromObject(object.ballLocation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DefenderInDefenseAreaPartially message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @static
             * @param {proto.GameEvent.DefenderInDefenseAreaPartially} message DefenderInDefenseAreaPartially
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DefenderInDefenseAreaPartially.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                    object.distance = 0;
                    object.ballLocation = null;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.distance != null && message.hasOwnProperty("distance"))
                    object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
                if (message.ballLocation != null && message.hasOwnProperty("ballLocation"))
                    object.ballLocation = $root.proto.Vector2.toObject(message.ballLocation, options);
                return object;
            };

            /**
             * Converts this DefenderInDefenseAreaPartially to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DefenderInDefenseAreaPartially.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DefenderInDefenseAreaPartially
             * @function getTypeUrl
             * @memberof proto.GameEvent.DefenderInDefenseAreaPartially
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DefenderInDefenseAreaPartially.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.DefenderInDefenseAreaPartially";
            };

            return DefenderInDefenseAreaPartially;
        })();

        GameEvent.AttackerTouchedBallInDefenseArea = (function() {

            /**
             * Properties of an AttackerTouchedBallInDefenseArea.
             * @memberof proto.GameEvent
             * @interface IAttackerTouchedBallInDefenseArea
             * @property {proto.Team} byTeam AttackerTouchedBallInDefenseArea byTeam
             * @property {number|null} [byBot] AttackerTouchedBallInDefenseArea byBot
             * @property {proto.IVector2|null} [location] AttackerTouchedBallInDefenseArea location
             * @property {number|null} [distance] AttackerTouchedBallInDefenseArea distance
             */

            /**
             * Constructs a new AttackerTouchedBallInDefenseArea.
             * @memberof proto.GameEvent
             * @classdesc Represents an AttackerTouchedBallInDefenseArea.
             * @implements IAttackerTouchedBallInDefenseArea
             * @constructor
             * @param {proto.GameEvent.IAttackerTouchedBallInDefenseArea=} [properties] Properties to set
             */
            function AttackerTouchedBallInDefenseArea(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AttackerTouchedBallInDefenseArea byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @instance
             */
            AttackerTouchedBallInDefenseArea.prototype.byTeam = 0;

            /**
             * AttackerTouchedBallInDefenseArea byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @instance
             */
            AttackerTouchedBallInDefenseArea.prototype.byBot = 0;

            /**
             * AttackerTouchedBallInDefenseArea location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @instance
             */
            AttackerTouchedBallInDefenseArea.prototype.location = null;

            /**
             * AttackerTouchedBallInDefenseArea distance.
             * @member {number} distance
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @instance
             */
            AttackerTouchedBallInDefenseArea.prototype.distance = 0;

            /**
             * Creates a new AttackerTouchedBallInDefenseArea instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @static
             * @param {proto.GameEvent.IAttackerTouchedBallInDefenseArea=} [properties] Properties to set
             * @returns {proto.GameEvent.AttackerTouchedBallInDefenseArea} AttackerTouchedBallInDefenseArea instance
             */
            AttackerTouchedBallInDefenseArea.create = function create(properties) {
                return new AttackerTouchedBallInDefenseArea(properties);
            };

            /**
             * Encodes the specified AttackerTouchedBallInDefenseArea message. Does not implicitly {@link proto.GameEvent.AttackerTouchedBallInDefenseArea.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @static
             * @param {proto.GameEvent.IAttackerTouchedBallInDefenseArea} message AttackerTouchedBallInDefenseArea message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttackerTouchedBallInDefenseArea.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.distance);
                return writer;
            };

            /**
             * Encodes the specified AttackerTouchedBallInDefenseArea message, length delimited. Does not implicitly {@link proto.GameEvent.AttackerTouchedBallInDefenseArea.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @static
             * @param {proto.GameEvent.IAttackerTouchedBallInDefenseArea} message AttackerTouchedBallInDefenseArea message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttackerTouchedBallInDefenseArea.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AttackerTouchedBallInDefenseArea message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.AttackerTouchedBallInDefenseArea} AttackerTouchedBallInDefenseArea
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttackerTouchedBallInDefenseArea.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.AttackerTouchedBallInDefenseArea();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.distance = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes an AttackerTouchedBallInDefenseArea message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.AttackerTouchedBallInDefenseArea} AttackerTouchedBallInDefenseArea
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttackerTouchedBallInDefenseArea.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AttackerTouchedBallInDefenseArea message.
             * @function verify
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AttackerTouchedBallInDefenseArea.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.distance != null && message.hasOwnProperty("distance"))
                    if (typeof message.distance !== "number")
                        return "distance: number expected";
                return null;
            };

            /**
             * Creates an AttackerTouchedBallInDefenseArea message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.AttackerTouchedBallInDefenseArea} AttackerTouchedBallInDefenseArea
             */
            AttackerTouchedBallInDefenseArea.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.AttackerTouchedBallInDefenseArea)
                    return object;
                let message = new $root.proto.GameEvent.AttackerTouchedBallInDefenseArea();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.AttackerTouchedBallInDefenseArea.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.distance != null)
                    message.distance = Number(object.distance);
                return message;
            };

            /**
             * Creates a plain object from an AttackerTouchedBallInDefenseArea message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @static
             * @param {proto.GameEvent.AttackerTouchedBallInDefenseArea} message AttackerTouchedBallInDefenseArea
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AttackerTouchedBallInDefenseArea.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                    object.distance = 0;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.distance != null && message.hasOwnProperty("distance"))
                    object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
                return object;
            };

            /**
             * Converts this AttackerTouchedBallInDefenseArea to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AttackerTouchedBallInDefenseArea.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AttackerTouchedBallInDefenseArea
             * @function getTypeUrl
             * @memberof proto.GameEvent.AttackerTouchedBallInDefenseArea
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AttackerTouchedBallInDefenseArea.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.AttackerTouchedBallInDefenseArea";
            };

            return AttackerTouchedBallInDefenseArea;
        })();

        GameEvent.BotKickedBallTooFast = (function() {

            /**
             * Properties of a BotKickedBallTooFast.
             * @memberof proto.GameEvent
             * @interface IBotKickedBallTooFast
             * @property {proto.Team} byTeam BotKickedBallTooFast byTeam
             * @property {number|null} [byBot] BotKickedBallTooFast byBot
             * @property {proto.IVector2|null} [location] BotKickedBallTooFast location
             * @property {number|null} [initialBallSpeed] BotKickedBallTooFast initialBallSpeed
             * @property {boolean|null} [chipped] BotKickedBallTooFast chipped
             */

            /**
             * Constructs a new BotKickedBallTooFast.
             * @memberof proto.GameEvent
             * @classdesc Represents a BotKickedBallTooFast.
             * @implements IBotKickedBallTooFast
             * @constructor
             * @param {proto.GameEvent.IBotKickedBallTooFast=} [properties] Properties to set
             */
            function BotKickedBallTooFast(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BotKickedBallTooFast byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @instance
             */
            BotKickedBallTooFast.prototype.byTeam = 0;

            /**
             * BotKickedBallTooFast byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @instance
             */
            BotKickedBallTooFast.prototype.byBot = 0;

            /**
             * BotKickedBallTooFast location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @instance
             */
            BotKickedBallTooFast.prototype.location = null;

            /**
             * BotKickedBallTooFast initialBallSpeed.
             * @member {number} initialBallSpeed
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @instance
             */
            BotKickedBallTooFast.prototype.initialBallSpeed = 0;

            /**
             * BotKickedBallTooFast chipped.
             * @member {boolean} chipped
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @instance
             */
            BotKickedBallTooFast.prototype.chipped = false;

            /**
             * Creates a new BotKickedBallTooFast instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @static
             * @param {proto.GameEvent.IBotKickedBallTooFast=} [properties] Properties to set
             * @returns {proto.GameEvent.BotKickedBallTooFast} BotKickedBallTooFast instance
             */
            BotKickedBallTooFast.create = function create(properties) {
                return new BotKickedBallTooFast(properties);
            };

            /**
             * Encodes the specified BotKickedBallTooFast message. Does not implicitly {@link proto.GameEvent.BotKickedBallTooFast.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @static
             * @param {proto.GameEvent.IBotKickedBallTooFast} message BotKickedBallTooFast message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotKickedBallTooFast.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.initialBallSpeed != null && Object.hasOwnProperty.call(message, "initialBallSpeed"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.initialBallSpeed);
                if (message.chipped != null && Object.hasOwnProperty.call(message, "chipped"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.chipped);
                return writer;
            };

            /**
             * Encodes the specified BotKickedBallTooFast message, length delimited. Does not implicitly {@link proto.GameEvent.BotKickedBallTooFast.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @static
             * @param {proto.GameEvent.IBotKickedBallTooFast} message BotKickedBallTooFast message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotKickedBallTooFast.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BotKickedBallTooFast message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.BotKickedBallTooFast} BotKickedBallTooFast
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotKickedBallTooFast.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.BotKickedBallTooFast();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.initialBallSpeed = reader.float();
                            break;
                        }
                    case 5: {
                            message.chipped = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a BotKickedBallTooFast message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.BotKickedBallTooFast} BotKickedBallTooFast
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotKickedBallTooFast.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BotKickedBallTooFast message.
             * @function verify
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BotKickedBallTooFast.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.initialBallSpeed != null && message.hasOwnProperty("initialBallSpeed"))
                    if (typeof message.initialBallSpeed !== "number")
                        return "initialBallSpeed: number expected";
                if (message.chipped != null && message.hasOwnProperty("chipped"))
                    if (typeof message.chipped !== "boolean")
                        return "chipped: boolean expected";
                return null;
            };

            /**
             * Creates a BotKickedBallTooFast message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.BotKickedBallTooFast} BotKickedBallTooFast
             */
            BotKickedBallTooFast.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.BotKickedBallTooFast)
                    return object;
                let message = new $root.proto.GameEvent.BotKickedBallTooFast();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.BotKickedBallTooFast.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.initialBallSpeed != null)
                    message.initialBallSpeed = Number(object.initialBallSpeed);
                if (object.chipped != null)
                    message.chipped = Boolean(object.chipped);
                return message;
            };

            /**
             * Creates a plain object from a BotKickedBallTooFast message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @static
             * @param {proto.GameEvent.BotKickedBallTooFast} message BotKickedBallTooFast
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BotKickedBallTooFast.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                    object.initialBallSpeed = 0;
                    object.chipped = false;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.initialBallSpeed != null && message.hasOwnProperty("initialBallSpeed"))
                    object.initialBallSpeed = options.json && !isFinite(message.initialBallSpeed) ? String(message.initialBallSpeed) : message.initialBallSpeed;
                if (message.chipped != null && message.hasOwnProperty("chipped"))
                    object.chipped = message.chipped;
                return object;
            };

            /**
             * Converts this BotKickedBallTooFast to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BotKickedBallTooFast.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BotKickedBallTooFast
             * @function getTypeUrl
             * @memberof proto.GameEvent.BotKickedBallTooFast
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BotKickedBallTooFast.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.BotKickedBallTooFast";
            };

            return BotKickedBallTooFast;
        })();

        GameEvent.BotDribbledBallTooFar = (function() {

            /**
             * Properties of a BotDribbledBallTooFar.
             * @memberof proto.GameEvent
             * @interface IBotDribbledBallTooFar
             * @property {proto.Team} byTeam BotDribbledBallTooFar byTeam
             * @property {number|null} [byBot] BotDribbledBallTooFar byBot
             * @property {proto.IVector2|null} [start] BotDribbledBallTooFar start
             * @property {proto.IVector2|null} [end] BotDribbledBallTooFar end
             */

            /**
             * Constructs a new BotDribbledBallTooFar.
             * @memberof proto.GameEvent
             * @classdesc Represents a BotDribbledBallTooFar.
             * @implements IBotDribbledBallTooFar
             * @constructor
             * @param {proto.GameEvent.IBotDribbledBallTooFar=} [properties] Properties to set
             */
            function BotDribbledBallTooFar(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BotDribbledBallTooFar byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @instance
             */
            BotDribbledBallTooFar.prototype.byTeam = 0;

            /**
             * BotDribbledBallTooFar byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @instance
             */
            BotDribbledBallTooFar.prototype.byBot = 0;

            /**
             * BotDribbledBallTooFar start.
             * @member {proto.IVector2|null|undefined} start
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @instance
             */
            BotDribbledBallTooFar.prototype.start = null;

            /**
             * BotDribbledBallTooFar end.
             * @member {proto.IVector2|null|undefined} end
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @instance
             */
            BotDribbledBallTooFar.prototype.end = null;

            /**
             * Creates a new BotDribbledBallTooFar instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @static
             * @param {proto.GameEvent.IBotDribbledBallTooFar=} [properties] Properties to set
             * @returns {proto.GameEvent.BotDribbledBallTooFar} BotDribbledBallTooFar instance
             */
            BotDribbledBallTooFar.create = function create(properties) {
                return new BotDribbledBallTooFar(properties);
            };

            /**
             * Encodes the specified BotDribbledBallTooFar message. Does not implicitly {@link proto.GameEvent.BotDribbledBallTooFar.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @static
             * @param {proto.GameEvent.IBotDribbledBallTooFar} message BotDribbledBallTooFar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotDribbledBallTooFar.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                    $root.proto.Vector2.encode(message.start, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                    $root.proto.Vector2.encode(message.end, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BotDribbledBallTooFar message, length delimited. Does not implicitly {@link proto.GameEvent.BotDribbledBallTooFar.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @static
             * @param {proto.GameEvent.IBotDribbledBallTooFar} message BotDribbledBallTooFar message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotDribbledBallTooFar.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BotDribbledBallTooFar message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.BotDribbledBallTooFar} BotDribbledBallTooFar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotDribbledBallTooFar.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.BotDribbledBallTooFar();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.start = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.end = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a BotDribbledBallTooFar message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.BotDribbledBallTooFar} BotDribbledBallTooFar
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotDribbledBallTooFar.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BotDribbledBallTooFar message.
             * @function verify
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BotDribbledBallTooFar.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.start != null && message.hasOwnProperty("start")) {
                    let error = $root.proto.Vector2.verify(message.start);
                    if (error)
                        return "start." + error;
                }
                if (message.end != null && message.hasOwnProperty("end")) {
                    let error = $root.proto.Vector2.verify(message.end);
                    if (error)
                        return "end." + error;
                }
                return null;
            };

            /**
             * Creates a BotDribbledBallTooFar message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.BotDribbledBallTooFar} BotDribbledBallTooFar
             */
            BotDribbledBallTooFar.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.BotDribbledBallTooFar)
                    return object;
                let message = new $root.proto.GameEvent.BotDribbledBallTooFar();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.start != null) {
                    if (typeof object.start !== "object")
                        throw TypeError(".proto.GameEvent.BotDribbledBallTooFar.start: object expected");
                    message.start = $root.proto.Vector2.fromObject(object.start);
                }
                if (object.end != null) {
                    if (typeof object.end !== "object")
                        throw TypeError(".proto.GameEvent.BotDribbledBallTooFar.end: object expected");
                    message.end = $root.proto.Vector2.fromObject(object.end);
                }
                return message;
            };

            /**
             * Creates a plain object from a BotDribbledBallTooFar message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @static
             * @param {proto.GameEvent.BotDribbledBallTooFar} message BotDribbledBallTooFar
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BotDribbledBallTooFar.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.start = null;
                    object.end = null;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.start != null && message.hasOwnProperty("start"))
                    object.start = $root.proto.Vector2.toObject(message.start, options);
                if (message.end != null && message.hasOwnProperty("end"))
                    object.end = $root.proto.Vector2.toObject(message.end, options);
                return object;
            };

            /**
             * Converts this BotDribbledBallTooFar to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BotDribbledBallTooFar.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BotDribbledBallTooFar
             * @function getTypeUrl
             * @memberof proto.GameEvent.BotDribbledBallTooFar
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BotDribbledBallTooFar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.BotDribbledBallTooFar";
            };

            return BotDribbledBallTooFar;
        })();

        GameEvent.AttackerTouchedOpponentInDefenseArea = (function() {

            /**
             * Properties of an AttackerTouchedOpponentInDefenseArea.
             * @memberof proto.GameEvent
             * @interface IAttackerTouchedOpponentInDefenseArea
             * @property {proto.Team} byTeam AttackerTouchedOpponentInDefenseArea byTeam
             * @property {number|null} [byBot] AttackerTouchedOpponentInDefenseArea byBot
             * @property {number|null} [victim] AttackerTouchedOpponentInDefenseArea victim
             * @property {proto.IVector2|null} [location] AttackerTouchedOpponentInDefenseArea location
             */

            /**
             * Constructs a new AttackerTouchedOpponentInDefenseArea.
             * @memberof proto.GameEvent
             * @classdesc Represents an AttackerTouchedOpponentInDefenseArea.
             * @implements IAttackerTouchedOpponentInDefenseArea
             * @constructor
             * @param {proto.GameEvent.IAttackerTouchedOpponentInDefenseArea=} [properties] Properties to set
             */
            function AttackerTouchedOpponentInDefenseArea(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AttackerTouchedOpponentInDefenseArea byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @instance
             */
            AttackerTouchedOpponentInDefenseArea.prototype.byTeam = 0;

            /**
             * AttackerTouchedOpponentInDefenseArea byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @instance
             */
            AttackerTouchedOpponentInDefenseArea.prototype.byBot = 0;

            /**
             * AttackerTouchedOpponentInDefenseArea victim.
             * @member {number} victim
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @instance
             */
            AttackerTouchedOpponentInDefenseArea.prototype.victim = 0;

            /**
             * AttackerTouchedOpponentInDefenseArea location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @instance
             */
            AttackerTouchedOpponentInDefenseArea.prototype.location = null;

            /**
             * Creates a new AttackerTouchedOpponentInDefenseArea instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @static
             * @param {proto.GameEvent.IAttackerTouchedOpponentInDefenseArea=} [properties] Properties to set
             * @returns {proto.GameEvent.AttackerTouchedOpponentInDefenseArea} AttackerTouchedOpponentInDefenseArea instance
             */
            AttackerTouchedOpponentInDefenseArea.create = function create(properties) {
                return new AttackerTouchedOpponentInDefenseArea(properties);
            };

            /**
             * Encodes the specified AttackerTouchedOpponentInDefenseArea message. Does not implicitly {@link proto.GameEvent.AttackerTouchedOpponentInDefenseArea.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @static
             * @param {proto.GameEvent.IAttackerTouchedOpponentInDefenseArea} message AttackerTouchedOpponentInDefenseArea message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttackerTouchedOpponentInDefenseArea.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.victim != null && Object.hasOwnProperty.call(message, "victim"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.victim);
                return writer;
            };

            /**
             * Encodes the specified AttackerTouchedOpponentInDefenseArea message, length delimited. Does not implicitly {@link proto.GameEvent.AttackerTouchedOpponentInDefenseArea.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @static
             * @param {proto.GameEvent.IAttackerTouchedOpponentInDefenseArea} message AttackerTouchedOpponentInDefenseArea message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttackerTouchedOpponentInDefenseArea.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AttackerTouchedOpponentInDefenseArea message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.AttackerTouchedOpponentInDefenseArea} AttackerTouchedOpponentInDefenseArea
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttackerTouchedOpponentInDefenseArea.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.AttackerTouchedOpponentInDefenseArea();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.victim = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes an AttackerTouchedOpponentInDefenseArea message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.AttackerTouchedOpponentInDefenseArea} AttackerTouchedOpponentInDefenseArea
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttackerTouchedOpponentInDefenseArea.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AttackerTouchedOpponentInDefenseArea message.
             * @function verify
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AttackerTouchedOpponentInDefenseArea.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.victim != null && message.hasOwnProperty("victim"))
                    if (!$util.isInteger(message.victim))
                        return "victim: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                return null;
            };

            /**
             * Creates an AttackerTouchedOpponentInDefenseArea message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.AttackerTouchedOpponentInDefenseArea} AttackerTouchedOpponentInDefenseArea
             */
            AttackerTouchedOpponentInDefenseArea.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.AttackerTouchedOpponentInDefenseArea)
                    return object;
                let message = new $root.proto.GameEvent.AttackerTouchedOpponentInDefenseArea();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.victim != null)
                    message.victim = object.victim >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.AttackerTouchedOpponentInDefenseArea.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                return message;
            };

            /**
             * Creates a plain object from an AttackerTouchedOpponentInDefenseArea message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @static
             * @param {proto.GameEvent.AttackerTouchedOpponentInDefenseArea} message AttackerTouchedOpponentInDefenseArea
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AttackerTouchedOpponentInDefenseArea.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                    object.victim = 0;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.victim != null && message.hasOwnProperty("victim"))
                    object.victim = message.victim;
                return object;
            };

            /**
             * Converts this AttackerTouchedOpponentInDefenseArea to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AttackerTouchedOpponentInDefenseArea.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AttackerTouchedOpponentInDefenseArea
             * @function getTypeUrl
             * @memberof proto.GameEvent.AttackerTouchedOpponentInDefenseArea
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AttackerTouchedOpponentInDefenseArea.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.AttackerTouchedOpponentInDefenseArea";
            };

            return AttackerTouchedOpponentInDefenseArea;
        })();

        GameEvent.AttackerDoubleTouchedBall = (function() {

            /**
             * Properties of an AttackerDoubleTouchedBall.
             * @memberof proto.GameEvent
             * @interface IAttackerDoubleTouchedBall
             * @property {proto.Team} byTeam AttackerDoubleTouchedBall byTeam
             * @property {number|null} [byBot] AttackerDoubleTouchedBall byBot
             * @property {proto.IVector2|null} [location] AttackerDoubleTouchedBall location
             */

            /**
             * Constructs a new AttackerDoubleTouchedBall.
             * @memberof proto.GameEvent
             * @classdesc Represents an AttackerDoubleTouchedBall.
             * @implements IAttackerDoubleTouchedBall
             * @constructor
             * @param {proto.GameEvent.IAttackerDoubleTouchedBall=} [properties] Properties to set
             */
            function AttackerDoubleTouchedBall(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AttackerDoubleTouchedBall byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.AttackerDoubleTouchedBall
             * @instance
             */
            AttackerDoubleTouchedBall.prototype.byTeam = 0;

            /**
             * AttackerDoubleTouchedBall byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.AttackerDoubleTouchedBall
             * @instance
             */
            AttackerDoubleTouchedBall.prototype.byBot = 0;

            /**
             * AttackerDoubleTouchedBall location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.AttackerDoubleTouchedBall
             * @instance
             */
            AttackerDoubleTouchedBall.prototype.location = null;

            /**
             * Creates a new AttackerDoubleTouchedBall instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.AttackerDoubleTouchedBall
             * @static
             * @param {proto.GameEvent.IAttackerDoubleTouchedBall=} [properties] Properties to set
             * @returns {proto.GameEvent.AttackerDoubleTouchedBall} AttackerDoubleTouchedBall instance
             */
            AttackerDoubleTouchedBall.create = function create(properties) {
                return new AttackerDoubleTouchedBall(properties);
            };

            /**
             * Encodes the specified AttackerDoubleTouchedBall message. Does not implicitly {@link proto.GameEvent.AttackerDoubleTouchedBall.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.AttackerDoubleTouchedBall
             * @static
             * @param {proto.GameEvent.IAttackerDoubleTouchedBall} message AttackerDoubleTouchedBall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttackerDoubleTouchedBall.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AttackerDoubleTouchedBall message, length delimited. Does not implicitly {@link proto.GameEvent.AttackerDoubleTouchedBall.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.AttackerDoubleTouchedBall
             * @static
             * @param {proto.GameEvent.IAttackerDoubleTouchedBall} message AttackerDoubleTouchedBall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttackerDoubleTouchedBall.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AttackerDoubleTouchedBall message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.AttackerDoubleTouchedBall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.AttackerDoubleTouchedBall} AttackerDoubleTouchedBall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttackerDoubleTouchedBall.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.AttackerDoubleTouchedBall();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes an AttackerDoubleTouchedBall message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.AttackerDoubleTouchedBall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.AttackerDoubleTouchedBall} AttackerDoubleTouchedBall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttackerDoubleTouchedBall.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AttackerDoubleTouchedBall message.
             * @function verify
             * @memberof proto.GameEvent.AttackerDoubleTouchedBall
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AttackerDoubleTouchedBall.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                return null;
            };

            /**
             * Creates an AttackerDoubleTouchedBall message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.AttackerDoubleTouchedBall
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.AttackerDoubleTouchedBall} AttackerDoubleTouchedBall
             */
            AttackerDoubleTouchedBall.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.AttackerDoubleTouchedBall)
                    return object;
                let message = new $root.proto.GameEvent.AttackerDoubleTouchedBall();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.AttackerDoubleTouchedBall.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                return message;
            };

            /**
             * Creates a plain object from an AttackerDoubleTouchedBall message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.AttackerDoubleTouchedBall
             * @static
             * @param {proto.GameEvent.AttackerDoubleTouchedBall} message AttackerDoubleTouchedBall
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AttackerDoubleTouchedBall.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                return object;
            };

            /**
             * Converts this AttackerDoubleTouchedBall to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.AttackerDoubleTouchedBall
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AttackerDoubleTouchedBall.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AttackerDoubleTouchedBall
             * @function getTypeUrl
             * @memberof proto.GameEvent.AttackerDoubleTouchedBall
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AttackerDoubleTouchedBall.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.AttackerDoubleTouchedBall";
            };

            return AttackerDoubleTouchedBall;
        })();

        GameEvent.AttackerTooCloseToDefenseArea = (function() {

            /**
             * Properties of an AttackerTooCloseToDefenseArea.
             * @memberof proto.GameEvent
             * @interface IAttackerTooCloseToDefenseArea
             * @property {proto.Team} byTeam AttackerTooCloseToDefenseArea byTeam
             * @property {number|null} [byBot] AttackerTooCloseToDefenseArea byBot
             * @property {proto.IVector2|null} [location] AttackerTooCloseToDefenseArea location
             * @property {number|null} [distance] AttackerTooCloseToDefenseArea distance
             * @property {proto.IVector2|null} [ballLocation] AttackerTooCloseToDefenseArea ballLocation
             */

            /**
             * Constructs a new AttackerTooCloseToDefenseArea.
             * @memberof proto.GameEvent
             * @classdesc Represents an AttackerTooCloseToDefenseArea.
             * @implements IAttackerTooCloseToDefenseArea
             * @constructor
             * @param {proto.GameEvent.IAttackerTooCloseToDefenseArea=} [properties] Properties to set
             */
            function AttackerTooCloseToDefenseArea(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AttackerTooCloseToDefenseArea byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @instance
             */
            AttackerTooCloseToDefenseArea.prototype.byTeam = 0;

            /**
             * AttackerTooCloseToDefenseArea byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @instance
             */
            AttackerTooCloseToDefenseArea.prototype.byBot = 0;

            /**
             * AttackerTooCloseToDefenseArea location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @instance
             */
            AttackerTooCloseToDefenseArea.prototype.location = null;

            /**
             * AttackerTooCloseToDefenseArea distance.
             * @member {number} distance
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @instance
             */
            AttackerTooCloseToDefenseArea.prototype.distance = 0;

            /**
             * AttackerTooCloseToDefenseArea ballLocation.
             * @member {proto.IVector2|null|undefined} ballLocation
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @instance
             */
            AttackerTooCloseToDefenseArea.prototype.ballLocation = null;

            /**
             * Creates a new AttackerTooCloseToDefenseArea instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @static
             * @param {proto.GameEvent.IAttackerTooCloseToDefenseArea=} [properties] Properties to set
             * @returns {proto.GameEvent.AttackerTooCloseToDefenseArea} AttackerTooCloseToDefenseArea instance
             */
            AttackerTooCloseToDefenseArea.create = function create(properties) {
                return new AttackerTooCloseToDefenseArea(properties);
            };

            /**
             * Encodes the specified AttackerTooCloseToDefenseArea message. Does not implicitly {@link proto.GameEvent.AttackerTooCloseToDefenseArea.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @static
             * @param {proto.GameEvent.IAttackerTooCloseToDefenseArea} message AttackerTooCloseToDefenseArea message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttackerTooCloseToDefenseArea.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.distance);
                if (message.ballLocation != null && Object.hasOwnProperty.call(message, "ballLocation"))
                    $root.proto.Vector2.encode(message.ballLocation, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AttackerTooCloseToDefenseArea message, length delimited. Does not implicitly {@link proto.GameEvent.AttackerTooCloseToDefenseArea.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @static
             * @param {proto.GameEvent.IAttackerTooCloseToDefenseArea} message AttackerTooCloseToDefenseArea message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AttackerTooCloseToDefenseArea.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AttackerTooCloseToDefenseArea message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.AttackerTooCloseToDefenseArea} AttackerTooCloseToDefenseArea
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttackerTooCloseToDefenseArea.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.AttackerTooCloseToDefenseArea();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.distance = reader.float();
                            break;
                        }
                    case 5: {
                            message.ballLocation = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes an AttackerTooCloseToDefenseArea message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.AttackerTooCloseToDefenseArea} AttackerTooCloseToDefenseArea
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AttackerTooCloseToDefenseArea.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AttackerTooCloseToDefenseArea message.
             * @function verify
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AttackerTooCloseToDefenseArea.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.distance != null && message.hasOwnProperty("distance"))
                    if (typeof message.distance !== "number")
                        return "distance: number expected";
                if (message.ballLocation != null && message.hasOwnProperty("ballLocation")) {
                    let error = $root.proto.Vector2.verify(message.ballLocation);
                    if (error)
                        return "ballLocation." + error;
                }
                return null;
            };

            /**
             * Creates an AttackerTooCloseToDefenseArea message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.AttackerTooCloseToDefenseArea} AttackerTooCloseToDefenseArea
             */
            AttackerTooCloseToDefenseArea.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.AttackerTooCloseToDefenseArea)
                    return object;
                let message = new $root.proto.GameEvent.AttackerTooCloseToDefenseArea();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.AttackerTooCloseToDefenseArea.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.distance != null)
                    message.distance = Number(object.distance);
                if (object.ballLocation != null) {
                    if (typeof object.ballLocation !== "object")
                        throw TypeError(".proto.GameEvent.AttackerTooCloseToDefenseArea.ballLocation: object expected");
                    message.ballLocation = $root.proto.Vector2.fromObject(object.ballLocation);
                }
                return message;
            };

            /**
             * Creates a plain object from an AttackerTooCloseToDefenseArea message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @static
             * @param {proto.GameEvent.AttackerTooCloseToDefenseArea} message AttackerTooCloseToDefenseArea
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AttackerTooCloseToDefenseArea.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                    object.distance = 0;
                    object.ballLocation = null;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.distance != null && message.hasOwnProperty("distance"))
                    object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
                if (message.ballLocation != null && message.hasOwnProperty("ballLocation"))
                    object.ballLocation = $root.proto.Vector2.toObject(message.ballLocation, options);
                return object;
            };

            /**
             * Converts this AttackerTooCloseToDefenseArea to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AttackerTooCloseToDefenseArea.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AttackerTooCloseToDefenseArea
             * @function getTypeUrl
             * @memberof proto.GameEvent.AttackerTooCloseToDefenseArea
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AttackerTooCloseToDefenseArea.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.AttackerTooCloseToDefenseArea";
            };

            return AttackerTooCloseToDefenseArea;
        })();

        GameEvent.BotHeldBallDeliberately = (function() {

            /**
             * Properties of a BotHeldBallDeliberately.
             * @memberof proto.GameEvent
             * @interface IBotHeldBallDeliberately
             * @property {proto.Team} byTeam BotHeldBallDeliberately byTeam
             * @property {number|null} [byBot] BotHeldBallDeliberately byBot
             * @property {proto.IVector2|null} [location] BotHeldBallDeliberately location
             * @property {number|null} [duration] BotHeldBallDeliberately duration
             */

            /**
             * Constructs a new BotHeldBallDeliberately.
             * @memberof proto.GameEvent
             * @classdesc Represents a BotHeldBallDeliberately.
             * @implements IBotHeldBallDeliberately
             * @constructor
             * @param {proto.GameEvent.IBotHeldBallDeliberately=} [properties] Properties to set
             */
            function BotHeldBallDeliberately(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BotHeldBallDeliberately byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @instance
             */
            BotHeldBallDeliberately.prototype.byTeam = 0;

            /**
             * BotHeldBallDeliberately byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @instance
             */
            BotHeldBallDeliberately.prototype.byBot = 0;

            /**
             * BotHeldBallDeliberately location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @instance
             */
            BotHeldBallDeliberately.prototype.location = null;

            /**
             * BotHeldBallDeliberately duration.
             * @member {number} duration
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @instance
             */
            BotHeldBallDeliberately.prototype.duration = 0;

            /**
             * Creates a new BotHeldBallDeliberately instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @static
             * @param {proto.GameEvent.IBotHeldBallDeliberately=} [properties] Properties to set
             * @returns {proto.GameEvent.BotHeldBallDeliberately} BotHeldBallDeliberately instance
             */
            BotHeldBallDeliberately.create = function create(properties) {
                return new BotHeldBallDeliberately(properties);
            };

            /**
             * Encodes the specified BotHeldBallDeliberately message. Does not implicitly {@link proto.GameEvent.BotHeldBallDeliberately.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @static
             * @param {proto.GameEvent.IBotHeldBallDeliberately} message BotHeldBallDeliberately message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotHeldBallDeliberately.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.duration);
                return writer;
            };

            /**
             * Encodes the specified BotHeldBallDeliberately message, length delimited. Does not implicitly {@link proto.GameEvent.BotHeldBallDeliberately.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @static
             * @param {proto.GameEvent.IBotHeldBallDeliberately} message BotHeldBallDeliberately message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotHeldBallDeliberately.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BotHeldBallDeliberately message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.BotHeldBallDeliberately} BotHeldBallDeliberately
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotHeldBallDeliberately.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.BotHeldBallDeliberately();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.duration = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a BotHeldBallDeliberately message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.BotHeldBallDeliberately} BotHeldBallDeliberately
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotHeldBallDeliberately.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BotHeldBallDeliberately message.
             * @function verify
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BotHeldBallDeliberately.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (typeof message.duration !== "number")
                        return "duration: number expected";
                return null;
            };

            /**
             * Creates a BotHeldBallDeliberately message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.BotHeldBallDeliberately} BotHeldBallDeliberately
             */
            BotHeldBallDeliberately.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.BotHeldBallDeliberately)
                    return object;
                let message = new $root.proto.GameEvent.BotHeldBallDeliberately();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.BotHeldBallDeliberately.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.duration != null)
                    message.duration = Number(object.duration);
                return message;
            };

            /**
             * Creates a plain object from a BotHeldBallDeliberately message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @static
             * @param {proto.GameEvent.BotHeldBallDeliberately} message BotHeldBallDeliberately
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BotHeldBallDeliberately.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                    object.duration = 0;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
                return object;
            };

            /**
             * Converts this BotHeldBallDeliberately to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BotHeldBallDeliberately.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BotHeldBallDeliberately
             * @function getTypeUrl
             * @memberof proto.GameEvent.BotHeldBallDeliberately
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BotHeldBallDeliberately.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.BotHeldBallDeliberately";
            };

            return BotHeldBallDeliberately;
        })();

        GameEvent.BotInterferedPlacement = (function() {

            /**
             * Properties of a BotInterferedPlacement.
             * @memberof proto.GameEvent
             * @interface IBotInterferedPlacement
             * @property {proto.Team} byTeam BotInterferedPlacement byTeam
             * @property {number|null} [byBot] BotInterferedPlacement byBot
             * @property {proto.IVector2|null} [location] BotInterferedPlacement location
             */

            /**
             * Constructs a new BotInterferedPlacement.
             * @memberof proto.GameEvent
             * @classdesc Represents a BotInterferedPlacement.
             * @implements IBotInterferedPlacement
             * @constructor
             * @param {proto.GameEvent.IBotInterferedPlacement=} [properties] Properties to set
             */
            function BotInterferedPlacement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BotInterferedPlacement byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.BotInterferedPlacement
             * @instance
             */
            BotInterferedPlacement.prototype.byTeam = 0;

            /**
             * BotInterferedPlacement byBot.
             * @member {number} byBot
             * @memberof proto.GameEvent.BotInterferedPlacement
             * @instance
             */
            BotInterferedPlacement.prototype.byBot = 0;

            /**
             * BotInterferedPlacement location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.BotInterferedPlacement
             * @instance
             */
            BotInterferedPlacement.prototype.location = null;

            /**
             * Creates a new BotInterferedPlacement instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.BotInterferedPlacement
             * @static
             * @param {proto.GameEvent.IBotInterferedPlacement=} [properties] Properties to set
             * @returns {proto.GameEvent.BotInterferedPlacement} BotInterferedPlacement instance
             */
            BotInterferedPlacement.create = function create(properties) {
                return new BotInterferedPlacement(properties);
            };

            /**
             * Encodes the specified BotInterferedPlacement message. Does not implicitly {@link proto.GameEvent.BotInterferedPlacement.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.BotInterferedPlacement
             * @static
             * @param {proto.GameEvent.IBotInterferedPlacement} message BotInterferedPlacement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotInterferedPlacement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.byBot != null && Object.hasOwnProperty.call(message, "byBot"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.byBot);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BotInterferedPlacement message, length delimited. Does not implicitly {@link proto.GameEvent.BotInterferedPlacement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.BotInterferedPlacement
             * @static
             * @param {proto.GameEvent.IBotInterferedPlacement} message BotInterferedPlacement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotInterferedPlacement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BotInterferedPlacement message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.BotInterferedPlacement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.BotInterferedPlacement} BotInterferedPlacement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotInterferedPlacement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.BotInterferedPlacement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.byBot = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a BotInterferedPlacement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.BotInterferedPlacement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.BotInterferedPlacement} BotInterferedPlacement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotInterferedPlacement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BotInterferedPlacement message.
             * @function verify
             * @memberof proto.GameEvent.BotInterferedPlacement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BotInterferedPlacement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    if (!$util.isInteger(message.byBot))
                        return "byBot: integer expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                return null;
            };

            /**
             * Creates a BotInterferedPlacement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.BotInterferedPlacement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.BotInterferedPlacement} BotInterferedPlacement
             */
            BotInterferedPlacement.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.BotInterferedPlacement)
                    return object;
                let message = new $root.proto.GameEvent.BotInterferedPlacement();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.byBot != null)
                    message.byBot = object.byBot >>> 0;
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.BotInterferedPlacement.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                return message;
            };

            /**
             * Creates a plain object from a BotInterferedPlacement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.BotInterferedPlacement
             * @static
             * @param {proto.GameEvent.BotInterferedPlacement} message BotInterferedPlacement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BotInterferedPlacement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.byBot = 0;
                    object.location = null;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.byBot != null && message.hasOwnProperty("byBot"))
                    object.byBot = message.byBot;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                return object;
            };

            /**
             * Converts this BotInterferedPlacement to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.BotInterferedPlacement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BotInterferedPlacement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BotInterferedPlacement
             * @function getTypeUrl
             * @memberof proto.GameEvent.BotInterferedPlacement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BotInterferedPlacement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.BotInterferedPlacement";
            };

            return BotInterferedPlacement;
        })();

        GameEvent.MultipleCards = (function() {

            /**
             * Properties of a MultipleCards.
             * @memberof proto.GameEvent
             * @interface IMultipleCards
             * @property {proto.Team} byTeam MultipleCards byTeam
             */

            /**
             * Constructs a new MultipleCards.
             * @memberof proto.GameEvent
             * @classdesc Represents a MultipleCards.
             * @implements IMultipleCards
             * @constructor
             * @param {proto.GameEvent.IMultipleCards=} [properties] Properties to set
             */
            function MultipleCards(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MultipleCards byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.MultipleCards
             * @instance
             */
            MultipleCards.prototype.byTeam = 0;

            /**
             * Creates a new MultipleCards instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.MultipleCards
             * @static
             * @param {proto.GameEvent.IMultipleCards=} [properties] Properties to set
             * @returns {proto.GameEvent.MultipleCards} MultipleCards instance
             */
            MultipleCards.create = function create(properties) {
                return new MultipleCards(properties);
            };

            /**
             * Encodes the specified MultipleCards message. Does not implicitly {@link proto.GameEvent.MultipleCards.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.MultipleCards
             * @static
             * @param {proto.GameEvent.IMultipleCards} message MultipleCards message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultipleCards.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                return writer;
            };

            /**
             * Encodes the specified MultipleCards message, length delimited. Does not implicitly {@link proto.GameEvent.MultipleCards.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.MultipleCards
             * @static
             * @param {proto.GameEvent.IMultipleCards} message MultipleCards message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultipleCards.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MultipleCards message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.MultipleCards
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.MultipleCards} MultipleCards
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultipleCards.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.MultipleCards();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a MultipleCards message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.MultipleCards
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.MultipleCards} MultipleCards
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultipleCards.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MultipleCards message.
             * @function verify
             * @memberof proto.GameEvent.MultipleCards
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MultipleCards.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                return null;
            };

            /**
             * Creates a MultipleCards message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.MultipleCards
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.MultipleCards} MultipleCards
             */
            MultipleCards.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.MultipleCards)
                    return object;
                let message = new $root.proto.GameEvent.MultipleCards();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a MultipleCards message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.MultipleCards
             * @static
             * @param {proto.GameEvent.MultipleCards} message MultipleCards
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MultipleCards.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                return object;
            };

            /**
             * Converts this MultipleCards to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.MultipleCards
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MultipleCards.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MultipleCards
             * @function getTypeUrl
             * @memberof proto.GameEvent.MultipleCards
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MultipleCards.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.MultipleCards";
            };

            return MultipleCards;
        })();

        GameEvent.MultipleFouls = (function() {

            /**
             * Properties of a MultipleFouls.
             * @memberof proto.GameEvent
             * @interface IMultipleFouls
             * @property {proto.Team} byTeam MultipleFouls byTeam
             */

            /**
             * Constructs a new MultipleFouls.
             * @memberof proto.GameEvent
             * @classdesc Represents a MultipleFouls.
             * @implements IMultipleFouls
             * @constructor
             * @param {proto.GameEvent.IMultipleFouls=} [properties] Properties to set
             */
            function MultipleFouls(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MultipleFouls byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.MultipleFouls
             * @instance
             */
            MultipleFouls.prototype.byTeam = 0;

            /**
             * Creates a new MultipleFouls instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.MultipleFouls
             * @static
             * @param {proto.GameEvent.IMultipleFouls=} [properties] Properties to set
             * @returns {proto.GameEvent.MultipleFouls} MultipleFouls instance
             */
            MultipleFouls.create = function create(properties) {
                return new MultipleFouls(properties);
            };

            /**
             * Encodes the specified MultipleFouls message. Does not implicitly {@link proto.GameEvent.MultipleFouls.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.MultipleFouls
             * @static
             * @param {proto.GameEvent.IMultipleFouls} message MultipleFouls message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultipleFouls.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                return writer;
            };

            /**
             * Encodes the specified MultipleFouls message, length delimited. Does not implicitly {@link proto.GameEvent.MultipleFouls.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.MultipleFouls
             * @static
             * @param {proto.GameEvent.IMultipleFouls} message MultipleFouls message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultipleFouls.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MultipleFouls message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.MultipleFouls
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.MultipleFouls} MultipleFouls
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultipleFouls.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.MultipleFouls();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a MultipleFouls message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.MultipleFouls
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.MultipleFouls} MultipleFouls
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultipleFouls.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MultipleFouls message.
             * @function verify
             * @memberof proto.GameEvent.MultipleFouls
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MultipleFouls.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                return null;
            };

            /**
             * Creates a MultipleFouls message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.MultipleFouls
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.MultipleFouls} MultipleFouls
             */
            MultipleFouls.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.MultipleFouls)
                    return object;
                let message = new $root.proto.GameEvent.MultipleFouls();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a MultipleFouls message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.MultipleFouls
             * @static
             * @param {proto.GameEvent.MultipleFouls} message MultipleFouls
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MultipleFouls.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                return object;
            };

            /**
             * Converts this MultipleFouls to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.MultipleFouls
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MultipleFouls.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MultipleFouls
             * @function getTypeUrl
             * @memberof proto.GameEvent.MultipleFouls
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MultipleFouls.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.MultipleFouls";
            };

            return MultipleFouls;
        })();

        GameEvent.MultiplePlacementFailures = (function() {

            /**
             * Properties of a MultiplePlacementFailures.
             * @memberof proto.GameEvent
             * @interface IMultiplePlacementFailures
             * @property {proto.Team} byTeam MultiplePlacementFailures byTeam
             */

            /**
             * Constructs a new MultiplePlacementFailures.
             * @memberof proto.GameEvent
             * @classdesc Represents a MultiplePlacementFailures.
             * @implements IMultiplePlacementFailures
             * @constructor
             * @param {proto.GameEvent.IMultiplePlacementFailures=} [properties] Properties to set
             */
            function MultiplePlacementFailures(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MultiplePlacementFailures byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.MultiplePlacementFailures
             * @instance
             */
            MultiplePlacementFailures.prototype.byTeam = 0;

            /**
             * Creates a new MultiplePlacementFailures instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.MultiplePlacementFailures
             * @static
             * @param {proto.GameEvent.IMultiplePlacementFailures=} [properties] Properties to set
             * @returns {proto.GameEvent.MultiplePlacementFailures} MultiplePlacementFailures instance
             */
            MultiplePlacementFailures.create = function create(properties) {
                return new MultiplePlacementFailures(properties);
            };

            /**
             * Encodes the specified MultiplePlacementFailures message. Does not implicitly {@link proto.GameEvent.MultiplePlacementFailures.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.MultiplePlacementFailures
             * @static
             * @param {proto.GameEvent.IMultiplePlacementFailures} message MultiplePlacementFailures message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultiplePlacementFailures.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                return writer;
            };

            /**
             * Encodes the specified MultiplePlacementFailures message, length delimited. Does not implicitly {@link proto.GameEvent.MultiplePlacementFailures.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.MultiplePlacementFailures
             * @static
             * @param {proto.GameEvent.IMultiplePlacementFailures} message MultiplePlacementFailures message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultiplePlacementFailures.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MultiplePlacementFailures message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.MultiplePlacementFailures
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.MultiplePlacementFailures} MultiplePlacementFailures
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultiplePlacementFailures.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.MultiplePlacementFailures();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a MultiplePlacementFailures message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.MultiplePlacementFailures
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.MultiplePlacementFailures} MultiplePlacementFailures
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultiplePlacementFailures.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MultiplePlacementFailures message.
             * @function verify
             * @memberof proto.GameEvent.MultiplePlacementFailures
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MultiplePlacementFailures.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                return null;
            };

            /**
             * Creates a MultiplePlacementFailures message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.MultiplePlacementFailures
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.MultiplePlacementFailures} MultiplePlacementFailures
             */
            MultiplePlacementFailures.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.MultiplePlacementFailures)
                    return object;
                let message = new $root.proto.GameEvent.MultiplePlacementFailures();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a MultiplePlacementFailures message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.MultiplePlacementFailures
             * @static
             * @param {proto.GameEvent.MultiplePlacementFailures} message MultiplePlacementFailures
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MultiplePlacementFailures.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                return object;
            };

            /**
             * Converts this MultiplePlacementFailures to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.MultiplePlacementFailures
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MultiplePlacementFailures.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MultiplePlacementFailures
             * @function getTypeUrl
             * @memberof proto.GameEvent.MultiplePlacementFailures
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MultiplePlacementFailures.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.MultiplePlacementFailures";
            };

            return MultiplePlacementFailures;
        })();

        GameEvent.KickTimeout = (function() {

            /**
             * Properties of a KickTimeout.
             * @memberof proto.GameEvent
             * @interface IKickTimeout
             * @property {proto.Team} byTeam KickTimeout byTeam
             * @property {proto.IVector2|null} [location] KickTimeout location
             * @property {number|null} [time] KickTimeout time
             */

            /**
             * Constructs a new KickTimeout.
             * @memberof proto.GameEvent
             * @classdesc Represents a KickTimeout.
             * @implements IKickTimeout
             * @constructor
             * @param {proto.GameEvent.IKickTimeout=} [properties] Properties to set
             */
            function KickTimeout(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KickTimeout byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.KickTimeout
             * @instance
             */
            KickTimeout.prototype.byTeam = 0;

            /**
             * KickTimeout location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.KickTimeout
             * @instance
             */
            KickTimeout.prototype.location = null;

            /**
             * KickTimeout time.
             * @member {number} time
             * @memberof proto.GameEvent.KickTimeout
             * @instance
             */
            KickTimeout.prototype.time = 0;

            /**
             * Creates a new KickTimeout instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.KickTimeout
             * @static
             * @param {proto.GameEvent.IKickTimeout=} [properties] Properties to set
             * @returns {proto.GameEvent.KickTimeout} KickTimeout instance
             */
            KickTimeout.create = function create(properties) {
                return new KickTimeout(properties);
            };

            /**
             * Encodes the specified KickTimeout message. Does not implicitly {@link proto.GameEvent.KickTimeout.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.KickTimeout
             * @static
             * @param {proto.GameEvent.IKickTimeout} message KickTimeout message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickTimeout.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.time);
                return writer;
            };

            /**
             * Encodes the specified KickTimeout message, length delimited. Does not implicitly {@link proto.GameEvent.KickTimeout.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.KickTimeout
             * @static
             * @param {proto.GameEvent.IKickTimeout} message KickTimeout message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickTimeout.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickTimeout message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.KickTimeout
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.KickTimeout} KickTimeout
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickTimeout.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.KickTimeout();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.time = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a KickTimeout message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.KickTimeout
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.KickTimeout} KickTimeout
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickTimeout.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickTimeout message.
             * @function verify
             * @memberof proto.GameEvent.KickTimeout
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KickTimeout.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time !== "number")
                        return "time: number expected";
                return null;
            };

            /**
             * Creates a KickTimeout message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.KickTimeout
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.KickTimeout} KickTimeout
             */
            KickTimeout.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.KickTimeout)
                    return object;
                let message = new $root.proto.GameEvent.KickTimeout();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.KickTimeout.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.time != null)
                    message.time = Number(object.time);
                return message;
            };

            /**
             * Creates a plain object from a KickTimeout message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.KickTimeout
             * @static
             * @param {proto.GameEvent.KickTimeout} message KickTimeout
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickTimeout.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.location = null;
                    object.time = 0;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
                return object;
            };

            /**
             * Converts this KickTimeout to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.KickTimeout
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KickTimeout.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KickTimeout
             * @function getTypeUrl
             * @memberof proto.GameEvent.KickTimeout
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KickTimeout.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.KickTimeout";
            };

            return KickTimeout;
        })();

        GameEvent.NoProgressInGame = (function() {

            /**
             * Properties of a NoProgressInGame.
             * @memberof proto.GameEvent
             * @interface INoProgressInGame
             * @property {proto.IVector2|null} [location] NoProgressInGame location
             * @property {number|null} [time] NoProgressInGame time
             */

            /**
             * Constructs a new NoProgressInGame.
             * @memberof proto.GameEvent
             * @classdesc Represents a NoProgressInGame.
             * @implements INoProgressInGame
             * @constructor
             * @param {proto.GameEvent.INoProgressInGame=} [properties] Properties to set
             */
            function NoProgressInGame(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NoProgressInGame location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.NoProgressInGame
             * @instance
             */
            NoProgressInGame.prototype.location = null;

            /**
             * NoProgressInGame time.
             * @member {number} time
             * @memberof proto.GameEvent.NoProgressInGame
             * @instance
             */
            NoProgressInGame.prototype.time = 0;

            /**
             * Creates a new NoProgressInGame instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.NoProgressInGame
             * @static
             * @param {proto.GameEvent.INoProgressInGame=} [properties] Properties to set
             * @returns {proto.GameEvent.NoProgressInGame} NoProgressInGame instance
             */
            NoProgressInGame.create = function create(properties) {
                return new NoProgressInGame(properties);
            };

            /**
             * Encodes the specified NoProgressInGame message. Does not implicitly {@link proto.GameEvent.NoProgressInGame.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.NoProgressInGame
             * @static
             * @param {proto.GameEvent.INoProgressInGame} message NoProgressInGame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoProgressInGame.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.time);
                return writer;
            };

            /**
             * Encodes the specified NoProgressInGame message, length delimited. Does not implicitly {@link proto.GameEvent.NoProgressInGame.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.NoProgressInGame
             * @static
             * @param {proto.GameEvent.INoProgressInGame} message NoProgressInGame message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoProgressInGame.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NoProgressInGame message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.NoProgressInGame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.NoProgressInGame} NoProgressInGame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoProgressInGame.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.NoProgressInGame();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.time = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NoProgressInGame message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.NoProgressInGame
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.NoProgressInGame} NoProgressInGame
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoProgressInGame.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NoProgressInGame message.
             * @function verify
             * @memberof proto.GameEvent.NoProgressInGame
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NoProgressInGame.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time !== "number")
                        return "time: number expected";
                return null;
            };

            /**
             * Creates a NoProgressInGame message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.NoProgressInGame
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.NoProgressInGame} NoProgressInGame
             */
            NoProgressInGame.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.NoProgressInGame)
                    return object;
                let message = new $root.proto.GameEvent.NoProgressInGame();
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.NoProgressInGame.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.time != null)
                    message.time = Number(object.time);
                return message;
            };

            /**
             * Creates a plain object from a NoProgressInGame message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.NoProgressInGame
             * @static
             * @param {proto.GameEvent.NoProgressInGame} message NoProgressInGame
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NoProgressInGame.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.location = null;
                    object.time = 0;
                }
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = options.json && !isFinite(message.time) ? String(message.time) : message.time;
                return object;
            };

            /**
             * Converts this NoProgressInGame to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.NoProgressInGame
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NoProgressInGame.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NoProgressInGame
             * @function getTypeUrl
             * @memberof proto.GameEvent.NoProgressInGame
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NoProgressInGame.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.NoProgressInGame";
            };

            return NoProgressInGame;
        })();

        GameEvent.PlacementFailed = (function() {

            /**
             * Properties of a PlacementFailed.
             * @memberof proto.GameEvent
             * @interface IPlacementFailed
             * @property {proto.Team} byTeam PlacementFailed byTeam
             * @property {number|null} [remainingDistance] PlacementFailed remainingDistance
             */

            /**
             * Constructs a new PlacementFailed.
             * @memberof proto.GameEvent
             * @classdesc Represents a PlacementFailed.
             * @implements IPlacementFailed
             * @constructor
             * @param {proto.GameEvent.IPlacementFailed=} [properties] Properties to set
             */
            function PlacementFailed(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PlacementFailed byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.PlacementFailed
             * @instance
             */
            PlacementFailed.prototype.byTeam = 0;

            /**
             * PlacementFailed remainingDistance.
             * @member {number} remainingDistance
             * @memberof proto.GameEvent.PlacementFailed
             * @instance
             */
            PlacementFailed.prototype.remainingDistance = 0;

            /**
             * Creates a new PlacementFailed instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.PlacementFailed
             * @static
             * @param {proto.GameEvent.IPlacementFailed=} [properties] Properties to set
             * @returns {proto.GameEvent.PlacementFailed} PlacementFailed instance
             */
            PlacementFailed.create = function create(properties) {
                return new PlacementFailed(properties);
            };

            /**
             * Encodes the specified PlacementFailed message. Does not implicitly {@link proto.GameEvent.PlacementFailed.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.PlacementFailed
             * @static
             * @param {proto.GameEvent.IPlacementFailed} message PlacementFailed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlacementFailed.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.remainingDistance != null && Object.hasOwnProperty.call(message, "remainingDistance"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.remainingDistance);
                return writer;
            };

            /**
             * Encodes the specified PlacementFailed message, length delimited. Does not implicitly {@link proto.GameEvent.PlacementFailed.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.PlacementFailed
             * @static
             * @param {proto.GameEvent.IPlacementFailed} message PlacementFailed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlacementFailed.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PlacementFailed message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.PlacementFailed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.PlacementFailed} PlacementFailed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlacementFailed.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.PlacementFailed();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.remainingDistance = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a PlacementFailed message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.PlacementFailed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.PlacementFailed} PlacementFailed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlacementFailed.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PlacementFailed message.
             * @function verify
             * @memberof proto.GameEvent.PlacementFailed
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PlacementFailed.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.remainingDistance != null && message.hasOwnProperty("remainingDistance"))
                    if (typeof message.remainingDistance !== "number")
                        return "remainingDistance: number expected";
                return null;
            };

            /**
             * Creates a PlacementFailed message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.PlacementFailed
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.PlacementFailed} PlacementFailed
             */
            PlacementFailed.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.PlacementFailed)
                    return object;
                let message = new $root.proto.GameEvent.PlacementFailed();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.remainingDistance != null)
                    message.remainingDistance = Number(object.remainingDistance);
                return message;
            };

            /**
             * Creates a plain object from a PlacementFailed message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.PlacementFailed
             * @static
             * @param {proto.GameEvent.PlacementFailed} message PlacementFailed
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PlacementFailed.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.remainingDistance = 0;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.remainingDistance != null && message.hasOwnProperty("remainingDistance"))
                    object.remainingDistance = options.json && !isFinite(message.remainingDistance) ? String(message.remainingDistance) : message.remainingDistance;
                return object;
            };

            /**
             * Converts this PlacementFailed to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.PlacementFailed
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PlacementFailed.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PlacementFailed
             * @function getTypeUrl
             * @memberof proto.GameEvent.PlacementFailed
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PlacementFailed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.PlacementFailed";
            };

            return PlacementFailed;
        })();

        GameEvent.UnsportingBehaviorMinor = (function() {

            /**
             * Properties of an UnsportingBehaviorMinor.
             * @memberof proto.GameEvent
             * @interface IUnsportingBehaviorMinor
             * @property {proto.Team} byTeam UnsportingBehaviorMinor byTeam
             * @property {string} reason UnsportingBehaviorMinor reason
             */

            /**
             * Constructs a new UnsportingBehaviorMinor.
             * @memberof proto.GameEvent
             * @classdesc Represents an UnsportingBehaviorMinor.
             * @implements IUnsportingBehaviorMinor
             * @constructor
             * @param {proto.GameEvent.IUnsportingBehaviorMinor=} [properties] Properties to set
             */
            function UnsportingBehaviorMinor(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UnsportingBehaviorMinor byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.UnsportingBehaviorMinor
             * @instance
             */
            UnsportingBehaviorMinor.prototype.byTeam = 0;

            /**
             * UnsportingBehaviorMinor reason.
             * @member {string} reason
             * @memberof proto.GameEvent.UnsportingBehaviorMinor
             * @instance
             */
            UnsportingBehaviorMinor.prototype.reason = "";

            /**
             * Creates a new UnsportingBehaviorMinor instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.UnsportingBehaviorMinor
             * @static
             * @param {proto.GameEvent.IUnsportingBehaviorMinor=} [properties] Properties to set
             * @returns {proto.GameEvent.UnsportingBehaviorMinor} UnsportingBehaviorMinor instance
             */
            UnsportingBehaviorMinor.create = function create(properties) {
                return new UnsportingBehaviorMinor(properties);
            };

            /**
             * Encodes the specified UnsportingBehaviorMinor message. Does not implicitly {@link proto.GameEvent.UnsportingBehaviorMinor.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.UnsportingBehaviorMinor
             * @static
             * @param {proto.GameEvent.IUnsportingBehaviorMinor} message UnsportingBehaviorMinor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnsportingBehaviorMinor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.reason);
                return writer;
            };

            /**
             * Encodes the specified UnsportingBehaviorMinor message, length delimited. Does not implicitly {@link proto.GameEvent.UnsportingBehaviorMinor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.UnsportingBehaviorMinor
             * @static
             * @param {proto.GameEvent.IUnsportingBehaviorMinor} message UnsportingBehaviorMinor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnsportingBehaviorMinor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnsportingBehaviorMinor message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.UnsportingBehaviorMinor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.UnsportingBehaviorMinor} UnsportingBehaviorMinor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnsportingBehaviorMinor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.UnsportingBehaviorMinor();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.reason = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                if (!message.hasOwnProperty("reason"))
                    throw $util.ProtocolError("missing required 'reason'", { instance: message });
                return message;
            };

            /**
             * Decodes an UnsportingBehaviorMinor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.UnsportingBehaviorMinor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.UnsportingBehaviorMinor} UnsportingBehaviorMinor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnsportingBehaviorMinor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnsportingBehaviorMinor message.
             * @function verify
             * @memberof proto.GameEvent.UnsportingBehaviorMinor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnsportingBehaviorMinor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (!$util.isString(message.reason))
                    return "reason: string expected";
                return null;
            };

            /**
             * Creates an UnsportingBehaviorMinor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.UnsportingBehaviorMinor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.UnsportingBehaviorMinor} UnsportingBehaviorMinor
             */
            UnsportingBehaviorMinor.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.UnsportingBehaviorMinor)
                    return object;
                let message = new $root.proto.GameEvent.UnsportingBehaviorMinor();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.reason != null)
                    message.reason = String(object.reason);
                return message;
            };

            /**
             * Creates a plain object from an UnsportingBehaviorMinor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.UnsportingBehaviorMinor
             * @static
             * @param {proto.GameEvent.UnsportingBehaviorMinor} message UnsportingBehaviorMinor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnsportingBehaviorMinor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.reason = "";
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.reason != null && message.hasOwnProperty("reason"))
                    object.reason = message.reason;
                return object;
            };

            /**
             * Converts this UnsportingBehaviorMinor to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.UnsportingBehaviorMinor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnsportingBehaviorMinor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UnsportingBehaviorMinor
             * @function getTypeUrl
             * @memberof proto.GameEvent.UnsportingBehaviorMinor
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UnsportingBehaviorMinor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.UnsportingBehaviorMinor";
            };

            return UnsportingBehaviorMinor;
        })();

        GameEvent.UnsportingBehaviorMajor = (function() {

            /**
             * Properties of an UnsportingBehaviorMajor.
             * @memberof proto.GameEvent
             * @interface IUnsportingBehaviorMajor
             * @property {proto.Team} byTeam UnsportingBehaviorMajor byTeam
             * @property {string} reason UnsportingBehaviorMajor reason
             */

            /**
             * Constructs a new UnsportingBehaviorMajor.
             * @memberof proto.GameEvent
             * @classdesc Represents an UnsportingBehaviorMajor.
             * @implements IUnsportingBehaviorMajor
             * @constructor
             * @param {proto.GameEvent.IUnsportingBehaviorMajor=} [properties] Properties to set
             */
            function UnsportingBehaviorMajor(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UnsportingBehaviorMajor byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.UnsportingBehaviorMajor
             * @instance
             */
            UnsportingBehaviorMajor.prototype.byTeam = 0;

            /**
             * UnsportingBehaviorMajor reason.
             * @member {string} reason
             * @memberof proto.GameEvent.UnsportingBehaviorMajor
             * @instance
             */
            UnsportingBehaviorMajor.prototype.reason = "";

            /**
             * Creates a new UnsportingBehaviorMajor instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.UnsportingBehaviorMajor
             * @static
             * @param {proto.GameEvent.IUnsportingBehaviorMajor=} [properties] Properties to set
             * @returns {proto.GameEvent.UnsportingBehaviorMajor} UnsportingBehaviorMajor instance
             */
            UnsportingBehaviorMajor.create = function create(properties) {
                return new UnsportingBehaviorMajor(properties);
            };

            /**
             * Encodes the specified UnsportingBehaviorMajor message. Does not implicitly {@link proto.GameEvent.UnsportingBehaviorMajor.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.UnsportingBehaviorMajor
             * @static
             * @param {proto.GameEvent.IUnsportingBehaviorMajor} message UnsportingBehaviorMajor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnsportingBehaviorMajor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.reason);
                return writer;
            };

            /**
             * Encodes the specified UnsportingBehaviorMajor message, length delimited. Does not implicitly {@link proto.GameEvent.UnsportingBehaviorMajor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.UnsportingBehaviorMajor
             * @static
             * @param {proto.GameEvent.IUnsportingBehaviorMajor} message UnsportingBehaviorMajor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnsportingBehaviorMajor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnsportingBehaviorMajor message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.UnsportingBehaviorMajor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.UnsportingBehaviorMajor} UnsportingBehaviorMajor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnsportingBehaviorMajor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.UnsportingBehaviorMajor();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.reason = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                if (!message.hasOwnProperty("reason"))
                    throw $util.ProtocolError("missing required 'reason'", { instance: message });
                return message;
            };

            /**
             * Decodes an UnsportingBehaviorMajor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.UnsportingBehaviorMajor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.UnsportingBehaviorMajor} UnsportingBehaviorMajor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnsportingBehaviorMajor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnsportingBehaviorMajor message.
             * @function verify
             * @memberof proto.GameEvent.UnsportingBehaviorMajor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnsportingBehaviorMajor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (!$util.isString(message.reason))
                    return "reason: string expected";
                return null;
            };

            /**
             * Creates an UnsportingBehaviorMajor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.UnsportingBehaviorMajor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.UnsportingBehaviorMajor} UnsportingBehaviorMajor
             */
            UnsportingBehaviorMajor.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.UnsportingBehaviorMajor)
                    return object;
                let message = new $root.proto.GameEvent.UnsportingBehaviorMajor();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.reason != null)
                    message.reason = String(object.reason);
                return message;
            };

            /**
             * Creates a plain object from an UnsportingBehaviorMajor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.UnsportingBehaviorMajor
             * @static
             * @param {proto.GameEvent.UnsportingBehaviorMajor} message UnsportingBehaviorMajor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnsportingBehaviorMajor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.reason = "";
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.reason != null && message.hasOwnProperty("reason"))
                    object.reason = message.reason;
                return object;
            };

            /**
             * Converts this UnsportingBehaviorMajor to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.UnsportingBehaviorMajor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnsportingBehaviorMajor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UnsportingBehaviorMajor
             * @function getTypeUrl
             * @memberof proto.GameEvent.UnsportingBehaviorMajor
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UnsportingBehaviorMajor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.UnsportingBehaviorMajor";
            };

            return UnsportingBehaviorMajor;
        })();

        GameEvent.KeeperHeldBall = (function() {

            /**
             * Properties of a KeeperHeldBall.
             * @memberof proto.GameEvent
             * @interface IKeeperHeldBall
             * @property {proto.Team} byTeam KeeperHeldBall byTeam
             * @property {proto.IVector2|null} [location] KeeperHeldBall location
             * @property {number|null} [duration] KeeperHeldBall duration
             */

            /**
             * Constructs a new KeeperHeldBall.
             * @memberof proto.GameEvent
             * @classdesc Represents a KeeperHeldBall.
             * @implements IKeeperHeldBall
             * @constructor
             * @param {proto.GameEvent.IKeeperHeldBall=} [properties] Properties to set
             */
            function KeeperHeldBall(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeeperHeldBall byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.KeeperHeldBall
             * @instance
             */
            KeeperHeldBall.prototype.byTeam = 0;

            /**
             * KeeperHeldBall location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.KeeperHeldBall
             * @instance
             */
            KeeperHeldBall.prototype.location = null;

            /**
             * KeeperHeldBall duration.
             * @member {number} duration
             * @memberof proto.GameEvent.KeeperHeldBall
             * @instance
             */
            KeeperHeldBall.prototype.duration = 0;

            /**
             * Creates a new KeeperHeldBall instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.KeeperHeldBall
             * @static
             * @param {proto.GameEvent.IKeeperHeldBall=} [properties] Properties to set
             * @returns {proto.GameEvent.KeeperHeldBall} KeeperHeldBall instance
             */
            KeeperHeldBall.create = function create(properties) {
                return new KeeperHeldBall(properties);
            };

            /**
             * Encodes the specified KeeperHeldBall message. Does not implicitly {@link proto.GameEvent.KeeperHeldBall.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.KeeperHeldBall
             * @static
             * @param {proto.GameEvent.IKeeperHeldBall} message KeeperHeldBall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeeperHeldBall.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.duration);
                return writer;
            };

            /**
             * Encodes the specified KeeperHeldBall message, length delimited. Does not implicitly {@link proto.GameEvent.KeeperHeldBall.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.KeeperHeldBall
             * @static
             * @param {proto.GameEvent.IKeeperHeldBall} message KeeperHeldBall message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeeperHeldBall.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeeperHeldBall message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.KeeperHeldBall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.KeeperHeldBall} KeeperHeldBall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeeperHeldBall.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.KeeperHeldBall();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.duration = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a KeeperHeldBall message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.KeeperHeldBall
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.KeeperHeldBall} KeeperHeldBall
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeeperHeldBall.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeeperHeldBall message.
             * @function verify
             * @memberof proto.GameEvent.KeeperHeldBall
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeeperHeldBall.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (typeof message.duration !== "number")
                        return "duration: number expected";
                return null;
            };

            /**
             * Creates a KeeperHeldBall message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.KeeperHeldBall
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.KeeperHeldBall} KeeperHeldBall
             */
            KeeperHeldBall.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.KeeperHeldBall)
                    return object;
                let message = new $root.proto.GameEvent.KeeperHeldBall();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.KeeperHeldBall.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                if (object.duration != null)
                    message.duration = Number(object.duration);
                return message;
            };

            /**
             * Creates a plain object from a KeeperHeldBall message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.KeeperHeldBall
             * @static
             * @param {proto.GameEvent.KeeperHeldBall} message KeeperHeldBall
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeeperHeldBall.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.location = null;
                    object.duration = 0;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
                return object;
            };

            /**
             * Converts this KeeperHeldBall to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.KeeperHeldBall
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeeperHeldBall.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KeeperHeldBall
             * @function getTypeUrl
             * @memberof proto.GameEvent.KeeperHeldBall
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KeeperHeldBall.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.KeeperHeldBall";
            };

            return KeeperHeldBall;
        })();

        GameEvent.PlacementSucceeded = (function() {

            /**
             * Properties of a PlacementSucceeded.
             * @memberof proto.GameEvent
             * @interface IPlacementSucceeded
             * @property {proto.Team} byTeam PlacementSucceeded byTeam
             * @property {number|null} [timeTaken] PlacementSucceeded timeTaken
             * @property {number|null} [precision] PlacementSucceeded precision
             * @property {number|null} [distance] PlacementSucceeded distance
             */

            /**
             * Constructs a new PlacementSucceeded.
             * @memberof proto.GameEvent
             * @classdesc Represents a PlacementSucceeded.
             * @implements IPlacementSucceeded
             * @constructor
             * @param {proto.GameEvent.IPlacementSucceeded=} [properties] Properties to set
             */
            function PlacementSucceeded(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PlacementSucceeded byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.PlacementSucceeded
             * @instance
             */
            PlacementSucceeded.prototype.byTeam = 0;

            /**
             * PlacementSucceeded timeTaken.
             * @member {number} timeTaken
             * @memberof proto.GameEvent.PlacementSucceeded
             * @instance
             */
            PlacementSucceeded.prototype.timeTaken = 0;

            /**
             * PlacementSucceeded precision.
             * @member {number} precision
             * @memberof proto.GameEvent.PlacementSucceeded
             * @instance
             */
            PlacementSucceeded.prototype.precision = 0;

            /**
             * PlacementSucceeded distance.
             * @member {number} distance
             * @memberof proto.GameEvent.PlacementSucceeded
             * @instance
             */
            PlacementSucceeded.prototype.distance = 0;

            /**
             * Creates a new PlacementSucceeded instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.PlacementSucceeded
             * @static
             * @param {proto.GameEvent.IPlacementSucceeded=} [properties] Properties to set
             * @returns {proto.GameEvent.PlacementSucceeded} PlacementSucceeded instance
             */
            PlacementSucceeded.create = function create(properties) {
                return new PlacementSucceeded(properties);
            };

            /**
             * Encodes the specified PlacementSucceeded message. Does not implicitly {@link proto.GameEvent.PlacementSucceeded.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.PlacementSucceeded
             * @static
             * @param {proto.GameEvent.IPlacementSucceeded} message PlacementSucceeded message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlacementSucceeded.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.timeTaken != null && Object.hasOwnProperty.call(message, "timeTaken"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.timeTaken);
                if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.precision);
                if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.distance);
                return writer;
            };

            /**
             * Encodes the specified PlacementSucceeded message, length delimited. Does not implicitly {@link proto.GameEvent.PlacementSucceeded.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.PlacementSucceeded
             * @static
             * @param {proto.GameEvent.IPlacementSucceeded} message PlacementSucceeded message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlacementSucceeded.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PlacementSucceeded message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.PlacementSucceeded
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.PlacementSucceeded} PlacementSucceeded
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlacementSucceeded.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.PlacementSucceeded();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.timeTaken = reader.float();
                            break;
                        }
                    case 3: {
                            message.precision = reader.float();
                            break;
                        }
                    case 4: {
                            message.distance = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a PlacementSucceeded message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.PlacementSucceeded
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.PlacementSucceeded} PlacementSucceeded
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlacementSucceeded.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PlacementSucceeded message.
             * @function verify
             * @memberof proto.GameEvent.PlacementSucceeded
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PlacementSucceeded.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.timeTaken != null && message.hasOwnProperty("timeTaken"))
                    if (typeof message.timeTaken !== "number")
                        return "timeTaken: number expected";
                if (message.precision != null && message.hasOwnProperty("precision"))
                    if (typeof message.precision !== "number")
                        return "precision: number expected";
                if (message.distance != null && message.hasOwnProperty("distance"))
                    if (typeof message.distance !== "number")
                        return "distance: number expected";
                return null;
            };

            /**
             * Creates a PlacementSucceeded message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.PlacementSucceeded
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.PlacementSucceeded} PlacementSucceeded
             */
            PlacementSucceeded.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.PlacementSucceeded)
                    return object;
                let message = new $root.proto.GameEvent.PlacementSucceeded();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.timeTaken != null)
                    message.timeTaken = Number(object.timeTaken);
                if (object.precision != null)
                    message.precision = Number(object.precision);
                if (object.distance != null)
                    message.distance = Number(object.distance);
                return message;
            };

            /**
             * Creates a plain object from a PlacementSucceeded message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.PlacementSucceeded
             * @static
             * @param {proto.GameEvent.PlacementSucceeded} message PlacementSucceeded
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PlacementSucceeded.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.timeTaken = 0;
                    object.precision = 0;
                    object.distance = 0;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.timeTaken != null && message.hasOwnProperty("timeTaken"))
                    object.timeTaken = options.json && !isFinite(message.timeTaken) ? String(message.timeTaken) : message.timeTaken;
                if (message.precision != null && message.hasOwnProperty("precision"))
                    object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                if (message.distance != null && message.hasOwnProperty("distance"))
                    object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
                return object;
            };

            /**
             * Converts this PlacementSucceeded to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.PlacementSucceeded
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PlacementSucceeded.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PlacementSucceeded
             * @function getTypeUrl
             * @memberof proto.GameEvent.PlacementSucceeded
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PlacementSucceeded.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.PlacementSucceeded";
            };

            return PlacementSucceeded;
        })();

        GameEvent.Prepared = (function() {

            /**
             * Properties of a Prepared.
             * @memberof proto.GameEvent
             * @interface IPrepared
             * @property {number|null} [timeTaken] Prepared timeTaken
             */

            /**
             * Constructs a new Prepared.
             * @memberof proto.GameEvent
             * @classdesc Represents a Prepared.
             * @implements IPrepared
             * @constructor
             * @param {proto.GameEvent.IPrepared=} [properties] Properties to set
             */
            function Prepared(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Prepared timeTaken.
             * @member {number} timeTaken
             * @memberof proto.GameEvent.Prepared
             * @instance
             */
            Prepared.prototype.timeTaken = 0;

            /**
             * Creates a new Prepared instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.Prepared
             * @static
             * @param {proto.GameEvent.IPrepared=} [properties] Properties to set
             * @returns {proto.GameEvent.Prepared} Prepared instance
             */
            Prepared.create = function create(properties) {
                return new Prepared(properties);
            };

            /**
             * Encodes the specified Prepared message. Does not implicitly {@link proto.GameEvent.Prepared.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.Prepared
             * @static
             * @param {proto.GameEvent.IPrepared} message Prepared message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Prepared.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timeTaken != null && Object.hasOwnProperty.call(message, "timeTaken"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.timeTaken);
                return writer;
            };

            /**
             * Encodes the specified Prepared message, length delimited. Does not implicitly {@link proto.GameEvent.Prepared.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.Prepared
             * @static
             * @param {proto.GameEvent.IPrepared} message Prepared message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Prepared.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Prepared message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.Prepared
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.Prepared} Prepared
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Prepared.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.Prepared();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.timeTaken = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Prepared message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.Prepared
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.Prepared} Prepared
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Prepared.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Prepared message.
             * @function verify
             * @memberof proto.GameEvent.Prepared
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Prepared.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timeTaken != null && message.hasOwnProperty("timeTaken"))
                    if (typeof message.timeTaken !== "number")
                        return "timeTaken: number expected";
                return null;
            };

            /**
             * Creates a Prepared message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.Prepared
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.Prepared} Prepared
             */
            Prepared.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.Prepared)
                    return object;
                let message = new $root.proto.GameEvent.Prepared();
                if (object.timeTaken != null)
                    message.timeTaken = Number(object.timeTaken);
                return message;
            };

            /**
             * Creates a plain object from a Prepared message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.Prepared
             * @static
             * @param {proto.GameEvent.Prepared} message Prepared
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Prepared.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.timeTaken = 0;
                if (message.timeTaken != null && message.hasOwnProperty("timeTaken"))
                    object.timeTaken = options.json && !isFinite(message.timeTaken) ? String(message.timeTaken) : message.timeTaken;
                return object;
            };

            /**
             * Converts this Prepared to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.Prepared
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Prepared.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Prepared
             * @function getTypeUrl
             * @memberof proto.GameEvent.Prepared
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Prepared.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.Prepared";
            };

            return Prepared;
        })();

        GameEvent.BotSubstitution = (function() {

            /**
             * Properties of a BotSubstitution.
             * @memberof proto.GameEvent
             * @interface IBotSubstitution
             * @property {proto.Team} byTeam BotSubstitution byTeam
             */

            /**
             * Constructs a new BotSubstitution.
             * @memberof proto.GameEvent
             * @classdesc Represents a BotSubstitution.
             * @implements IBotSubstitution
             * @constructor
             * @param {proto.GameEvent.IBotSubstitution=} [properties] Properties to set
             */
            function BotSubstitution(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BotSubstitution byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.BotSubstitution
             * @instance
             */
            BotSubstitution.prototype.byTeam = 0;

            /**
             * Creates a new BotSubstitution instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.BotSubstitution
             * @static
             * @param {proto.GameEvent.IBotSubstitution=} [properties] Properties to set
             * @returns {proto.GameEvent.BotSubstitution} BotSubstitution instance
             */
            BotSubstitution.create = function create(properties) {
                return new BotSubstitution(properties);
            };

            /**
             * Encodes the specified BotSubstitution message. Does not implicitly {@link proto.GameEvent.BotSubstitution.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.BotSubstitution
             * @static
             * @param {proto.GameEvent.IBotSubstitution} message BotSubstitution message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotSubstitution.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                return writer;
            };

            /**
             * Encodes the specified BotSubstitution message, length delimited. Does not implicitly {@link proto.GameEvent.BotSubstitution.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.BotSubstitution
             * @static
             * @param {proto.GameEvent.IBotSubstitution} message BotSubstitution message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BotSubstitution.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BotSubstitution message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.BotSubstitution
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.BotSubstitution} BotSubstitution
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotSubstitution.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.BotSubstitution();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a BotSubstitution message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.BotSubstitution
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.BotSubstitution} BotSubstitution
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BotSubstitution.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BotSubstitution message.
             * @function verify
             * @memberof proto.GameEvent.BotSubstitution
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BotSubstitution.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                return null;
            };

            /**
             * Creates a BotSubstitution message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.BotSubstitution
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.BotSubstitution} BotSubstitution
             */
            BotSubstitution.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.BotSubstitution)
                    return object;
                let message = new $root.proto.GameEvent.BotSubstitution();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a BotSubstitution message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.BotSubstitution
             * @static
             * @param {proto.GameEvent.BotSubstitution} message BotSubstitution
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BotSubstitution.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                return object;
            };

            /**
             * Converts this BotSubstitution to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.BotSubstitution
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BotSubstitution.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BotSubstitution
             * @function getTypeUrl
             * @memberof proto.GameEvent.BotSubstitution
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BotSubstitution.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.BotSubstitution";
            };

            return BotSubstitution;
        })();

        GameEvent.ChallengeFlag = (function() {

            /**
             * Properties of a ChallengeFlag.
             * @memberof proto.GameEvent
             * @interface IChallengeFlag
             * @property {proto.Team} byTeam ChallengeFlag byTeam
             */

            /**
             * Constructs a new ChallengeFlag.
             * @memberof proto.GameEvent
             * @classdesc Represents a ChallengeFlag.
             * @implements IChallengeFlag
             * @constructor
             * @param {proto.GameEvent.IChallengeFlag=} [properties] Properties to set
             */
            function ChallengeFlag(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChallengeFlag byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.ChallengeFlag
             * @instance
             */
            ChallengeFlag.prototype.byTeam = 0;

            /**
             * Creates a new ChallengeFlag instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.ChallengeFlag
             * @static
             * @param {proto.GameEvent.IChallengeFlag=} [properties] Properties to set
             * @returns {proto.GameEvent.ChallengeFlag} ChallengeFlag instance
             */
            ChallengeFlag.create = function create(properties) {
                return new ChallengeFlag(properties);
            };

            /**
             * Encodes the specified ChallengeFlag message. Does not implicitly {@link proto.GameEvent.ChallengeFlag.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.ChallengeFlag
             * @static
             * @param {proto.GameEvent.IChallengeFlag} message ChallengeFlag message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChallengeFlag.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                return writer;
            };

            /**
             * Encodes the specified ChallengeFlag message, length delimited. Does not implicitly {@link proto.GameEvent.ChallengeFlag.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.ChallengeFlag
             * @static
             * @param {proto.GameEvent.IChallengeFlag} message ChallengeFlag message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChallengeFlag.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChallengeFlag message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.ChallengeFlag
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.ChallengeFlag} ChallengeFlag
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChallengeFlag.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.ChallengeFlag();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a ChallengeFlag message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.ChallengeFlag
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.ChallengeFlag} ChallengeFlag
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChallengeFlag.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChallengeFlag message.
             * @function verify
             * @memberof proto.GameEvent.ChallengeFlag
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChallengeFlag.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                return null;
            };

            /**
             * Creates a ChallengeFlag message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.ChallengeFlag
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.ChallengeFlag} ChallengeFlag
             */
            ChallengeFlag.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.ChallengeFlag)
                    return object;
                let message = new $root.proto.GameEvent.ChallengeFlag();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a ChallengeFlag message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.ChallengeFlag
             * @static
             * @param {proto.GameEvent.ChallengeFlag} message ChallengeFlag
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChallengeFlag.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                return object;
            };

            /**
             * Converts this ChallengeFlag to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.ChallengeFlag
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChallengeFlag.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ChallengeFlag
             * @function getTypeUrl
             * @memberof proto.GameEvent.ChallengeFlag
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ChallengeFlag.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.ChallengeFlag";
            };

            return ChallengeFlag;
        })();

        GameEvent.EmergencyStop = (function() {

            /**
             * Properties of an EmergencyStop.
             * @memberof proto.GameEvent
             * @interface IEmergencyStop
             * @property {proto.Team} byTeam EmergencyStop byTeam
             */

            /**
             * Constructs a new EmergencyStop.
             * @memberof proto.GameEvent
             * @classdesc Represents an EmergencyStop.
             * @implements IEmergencyStop
             * @constructor
             * @param {proto.GameEvent.IEmergencyStop=} [properties] Properties to set
             */
            function EmergencyStop(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EmergencyStop byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.EmergencyStop
             * @instance
             */
            EmergencyStop.prototype.byTeam = 0;

            /**
             * Creates a new EmergencyStop instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.EmergencyStop
             * @static
             * @param {proto.GameEvent.IEmergencyStop=} [properties] Properties to set
             * @returns {proto.GameEvent.EmergencyStop} EmergencyStop instance
             */
            EmergencyStop.create = function create(properties) {
                return new EmergencyStop(properties);
            };

            /**
             * Encodes the specified EmergencyStop message. Does not implicitly {@link proto.GameEvent.EmergencyStop.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.EmergencyStop
             * @static
             * @param {proto.GameEvent.IEmergencyStop} message EmergencyStop message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmergencyStop.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                return writer;
            };

            /**
             * Encodes the specified EmergencyStop message, length delimited. Does not implicitly {@link proto.GameEvent.EmergencyStop.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.EmergencyStop
             * @static
             * @param {proto.GameEvent.IEmergencyStop} message EmergencyStop message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EmergencyStop.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EmergencyStop message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.EmergencyStop
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.EmergencyStop} EmergencyStop
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmergencyStop.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.EmergencyStop();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes an EmergencyStop message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.EmergencyStop
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.EmergencyStop} EmergencyStop
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EmergencyStop.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EmergencyStop message.
             * @function verify
             * @memberof proto.GameEvent.EmergencyStop
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EmergencyStop.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                return null;
            };

            /**
             * Creates an EmergencyStop message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.EmergencyStop
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.EmergencyStop} EmergencyStop
             */
            EmergencyStop.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.EmergencyStop)
                    return object;
                let message = new $root.proto.GameEvent.EmergencyStop();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an EmergencyStop message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.EmergencyStop
             * @static
             * @param {proto.GameEvent.EmergencyStop} message EmergencyStop
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EmergencyStop.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                return object;
            };

            /**
             * Converts this EmergencyStop to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.EmergencyStop
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EmergencyStop.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EmergencyStop
             * @function getTypeUrl
             * @memberof proto.GameEvent.EmergencyStop
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EmergencyStop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.EmergencyStop";
            };

            return EmergencyStop;
        })();

        GameEvent.TooManyRobots = (function() {

            /**
             * Properties of a TooManyRobots.
             * @memberof proto.GameEvent
             * @interface ITooManyRobots
             * @property {proto.Team} byTeam TooManyRobots byTeam
             * @property {number|null} [numRobotsAllowed] TooManyRobots numRobotsAllowed
             * @property {number|null} [numRobotsOnField] TooManyRobots numRobotsOnField
             * @property {proto.IVector2|null} [ballLocation] TooManyRobots ballLocation
             */

            /**
             * Constructs a new TooManyRobots.
             * @memberof proto.GameEvent
             * @classdesc Represents a TooManyRobots.
             * @implements ITooManyRobots
             * @constructor
             * @param {proto.GameEvent.ITooManyRobots=} [properties] Properties to set
             */
            function TooManyRobots(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TooManyRobots byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.TooManyRobots
             * @instance
             */
            TooManyRobots.prototype.byTeam = 0;

            /**
             * TooManyRobots numRobotsAllowed.
             * @member {number} numRobotsAllowed
             * @memberof proto.GameEvent.TooManyRobots
             * @instance
             */
            TooManyRobots.prototype.numRobotsAllowed = 0;

            /**
             * TooManyRobots numRobotsOnField.
             * @member {number} numRobotsOnField
             * @memberof proto.GameEvent.TooManyRobots
             * @instance
             */
            TooManyRobots.prototype.numRobotsOnField = 0;

            /**
             * TooManyRobots ballLocation.
             * @member {proto.IVector2|null|undefined} ballLocation
             * @memberof proto.GameEvent.TooManyRobots
             * @instance
             */
            TooManyRobots.prototype.ballLocation = null;

            /**
             * Creates a new TooManyRobots instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.TooManyRobots
             * @static
             * @param {proto.GameEvent.ITooManyRobots=} [properties] Properties to set
             * @returns {proto.GameEvent.TooManyRobots} TooManyRobots instance
             */
            TooManyRobots.create = function create(properties) {
                return new TooManyRobots(properties);
            };

            /**
             * Encodes the specified TooManyRobots message. Does not implicitly {@link proto.GameEvent.TooManyRobots.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.TooManyRobots
             * @static
             * @param {proto.GameEvent.ITooManyRobots} message TooManyRobots message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TooManyRobots.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.numRobotsAllowed != null && Object.hasOwnProperty.call(message, "numRobotsAllowed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.numRobotsAllowed);
                if (message.numRobotsOnField != null && Object.hasOwnProperty.call(message, "numRobotsOnField"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.numRobotsOnField);
                if (message.ballLocation != null && Object.hasOwnProperty.call(message, "ballLocation"))
                    $root.proto.Vector2.encode(message.ballLocation, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TooManyRobots message, length delimited. Does not implicitly {@link proto.GameEvent.TooManyRobots.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.TooManyRobots
             * @static
             * @param {proto.GameEvent.ITooManyRobots} message TooManyRobots message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TooManyRobots.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TooManyRobots message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.TooManyRobots
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.TooManyRobots} TooManyRobots
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TooManyRobots.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.TooManyRobots();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.numRobotsAllowed = reader.int32();
                            break;
                        }
                    case 3: {
                            message.numRobotsOnField = reader.int32();
                            break;
                        }
                    case 4: {
                            message.ballLocation = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a TooManyRobots message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.TooManyRobots
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.TooManyRobots} TooManyRobots
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TooManyRobots.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TooManyRobots message.
             * @function verify
             * @memberof proto.GameEvent.TooManyRobots
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TooManyRobots.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.numRobotsAllowed != null && message.hasOwnProperty("numRobotsAllowed"))
                    if (!$util.isInteger(message.numRobotsAllowed))
                        return "numRobotsAllowed: integer expected";
                if (message.numRobotsOnField != null && message.hasOwnProperty("numRobotsOnField"))
                    if (!$util.isInteger(message.numRobotsOnField))
                        return "numRobotsOnField: integer expected";
                if (message.ballLocation != null && message.hasOwnProperty("ballLocation")) {
                    let error = $root.proto.Vector2.verify(message.ballLocation);
                    if (error)
                        return "ballLocation." + error;
                }
                return null;
            };

            /**
             * Creates a TooManyRobots message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.TooManyRobots
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.TooManyRobots} TooManyRobots
             */
            TooManyRobots.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.TooManyRobots)
                    return object;
                let message = new $root.proto.GameEvent.TooManyRobots();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.numRobotsAllowed != null)
                    message.numRobotsAllowed = object.numRobotsAllowed | 0;
                if (object.numRobotsOnField != null)
                    message.numRobotsOnField = object.numRobotsOnField | 0;
                if (object.ballLocation != null) {
                    if (typeof object.ballLocation !== "object")
                        throw TypeError(".proto.GameEvent.TooManyRobots.ballLocation: object expected");
                    message.ballLocation = $root.proto.Vector2.fromObject(object.ballLocation);
                }
                return message;
            };

            /**
             * Creates a plain object from a TooManyRobots message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.TooManyRobots
             * @static
             * @param {proto.GameEvent.TooManyRobots} message TooManyRobots
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TooManyRobots.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.numRobotsAllowed = 0;
                    object.numRobotsOnField = 0;
                    object.ballLocation = null;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.numRobotsAllowed != null && message.hasOwnProperty("numRobotsAllowed"))
                    object.numRobotsAllowed = message.numRobotsAllowed;
                if (message.numRobotsOnField != null && message.hasOwnProperty("numRobotsOnField"))
                    object.numRobotsOnField = message.numRobotsOnField;
                if (message.ballLocation != null && message.hasOwnProperty("ballLocation"))
                    object.ballLocation = $root.proto.Vector2.toObject(message.ballLocation, options);
                return object;
            };

            /**
             * Converts this TooManyRobots to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.TooManyRobots
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TooManyRobots.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TooManyRobots
             * @function getTypeUrl
             * @memberof proto.GameEvent.TooManyRobots
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TooManyRobots.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.TooManyRobots";
            };

            return TooManyRobots;
        })();

        GameEvent.BoundaryCrossing = (function() {

            /**
             * Properties of a BoundaryCrossing.
             * @memberof proto.GameEvent
             * @interface IBoundaryCrossing
             * @property {proto.Team} byTeam BoundaryCrossing byTeam
             * @property {proto.IVector2|null} [location] BoundaryCrossing location
             */

            /**
             * Constructs a new BoundaryCrossing.
             * @memberof proto.GameEvent
             * @classdesc Represents a BoundaryCrossing.
             * @implements IBoundaryCrossing
             * @constructor
             * @param {proto.GameEvent.IBoundaryCrossing=} [properties] Properties to set
             */
            function BoundaryCrossing(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BoundaryCrossing byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.BoundaryCrossing
             * @instance
             */
            BoundaryCrossing.prototype.byTeam = 0;

            /**
             * BoundaryCrossing location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.BoundaryCrossing
             * @instance
             */
            BoundaryCrossing.prototype.location = null;

            /**
             * Creates a new BoundaryCrossing instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.BoundaryCrossing
             * @static
             * @param {proto.GameEvent.IBoundaryCrossing=} [properties] Properties to set
             * @returns {proto.GameEvent.BoundaryCrossing} BoundaryCrossing instance
             */
            BoundaryCrossing.create = function create(properties) {
                return new BoundaryCrossing(properties);
            };

            /**
             * Encodes the specified BoundaryCrossing message. Does not implicitly {@link proto.GameEvent.BoundaryCrossing.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.BoundaryCrossing
             * @static
             * @param {proto.GameEvent.IBoundaryCrossing} message BoundaryCrossing message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoundaryCrossing.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BoundaryCrossing message, length delimited. Does not implicitly {@link proto.GameEvent.BoundaryCrossing.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.BoundaryCrossing
             * @static
             * @param {proto.GameEvent.IBoundaryCrossing} message BoundaryCrossing message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoundaryCrossing.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BoundaryCrossing message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.BoundaryCrossing
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.BoundaryCrossing} BoundaryCrossing
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoundaryCrossing.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.BoundaryCrossing();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a BoundaryCrossing message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.BoundaryCrossing
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.BoundaryCrossing} BoundaryCrossing
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoundaryCrossing.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BoundaryCrossing message.
             * @function verify
             * @memberof proto.GameEvent.BoundaryCrossing
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BoundaryCrossing.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                return null;
            };

            /**
             * Creates a BoundaryCrossing message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.BoundaryCrossing
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.BoundaryCrossing} BoundaryCrossing
             */
            BoundaryCrossing.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.BoundaryCrossing)
                    return object;
                let message = new $root.proto.GameEvent.BoundaryCrossing();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.BoundaryCrossing.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                return message;
            };

            /**
             * Creates a plain object from a BoundaryCrossing message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.BoundaryCrossing
             * @static
             * @param {proto.GameEvent.BoundaryCrossing} message BoundaryCrossing
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BoundaryCrossing.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.location = null;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                return object;
            };

            /**
             * Converts this BoundaryCrossing to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.BoundaryCrossing
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BoundaryCrossing.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BoundaryCrossing
             * @function getTypeUrl
             * @memberof proto.GameEvent.BoundaryCrossing
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BoundaryCrossing.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.BoundaryCrossing";
            };

            return BoundaryCrossing;
        })();

        GameEvent.PenaltyKickFailed = (function() {

            /**
             * Properties of a PenaltyKickFailed.
             * @memberof proto.GameEvent
             * @interface IPenaltyKickFailed
             * @property {proto.Team} byTeam PenaltyKickFailed byTeam
             * @property {proto.IVector2|null} [location] PenaltyKickFailed location
             */

            /**
             * Constructs a new PenaltyKickFailed.
             * @memberof proto.GameEvent
             * @classdesc Represents a PenaltyKickFailed.
             * @implements IPenaltyKickFailed
             * @constructor
             * @param {proto.GameEvent.IPenaltyKickFailed=} [properties] Properties to set
             */
            function PenaltyKickFailed(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PenaltyKickFailed byTeam.
             * @member {proto.Team} byTeam
             * @memberof proto.GameEvent.PenaltyKickFailed
             * @instance
             */
            PenaltyKickFailed.prototype.byTeam = 0;

            /**
             * PenaltyKickFailed location.
             * @member {proto.IVector2|null|undefined} location
             * @memberof proto.GameEvent.PenaltyKickFailed
             * @instance
             */
            PenaltyKickFailed.prototype.location = null;

            /**
             * Creates a new PenaltyKickFailed instance using the specified properties.
             * @function create
             * @memberof proto.GameEvent.PenaltyKickFailed
             * @static
             * @param {proto.GameEvent.IPenaltyKickFailed=} [properties] Properties to set
             * @returns {proto.GameEvent.PenaltyKickFailed} PenaltyKickFailed instance
             */
            PenaltyKickFailed.create = function create(properties) {
                return new PenaltyKickFailed(properties);
            };

            /**
             * Encodes the specified PenaltyKickFailed message. Does not implicitly {@link proto.GameEvent.PenaltyKickFailed.verify|verify} messages.
             * @function encode
             * @memberof proto.GameEvent.PenaltyKickFailed
             * @static
             * @param {proto.GameEvent.IPenaltyKickFailed} message PenaltyKickFailed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PenaltyKickFailed.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.byTeam);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.proto.Vector2.encode(message.location, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PenaltyKickFailed message, length delimited. Does not implicitly {@link proto.GameEvent.PenaltyKickFailed.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.GameEvent.PenaltyKickFailed
             * @static
             * @param {proto.GameEvent.IPenaltyKickFailed} message PenaltyKickFailed message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PenaltyKickFailed.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PenaltyKickFailed message from the specified reader or buffer.
             * @function decode
             * @memberof proto.GameEvent.PenaltyKickFailed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.GameEvent.PenaltyKickFailed} PenaltyKickFailed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PenaltyKickFailed.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEvent.PenaltyKickFailed();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.byTeam = reader.int32();
                            break;
                        }
                    case 2: {
                            message.location = $root.proto.Vector2.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("byTeam"))
                    throw $util.ProtocolError("missing required 'byTeam'", { instance: message });
                return message;
            };

            /**
             * Decodes a PenaltyKickFailed message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.GameEvent.PenaltyKickFailed
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.GameEvent.PenaltyKickFailed} PenaltyKickFailed
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PenaltyKickFailed.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PenaltyKickFailed message.
             * @function verify
             * @memberof proto.GameEvent.PenaltyKickFailed
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PenaltyKickFailed.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                switch (message.byTeam) {
                default:
                    return "byTeam: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    let error = $root.proto.Vector2.verify(message.location);
                    if (error)
                        return "location." + error;
                }
                return null;
            };

            /**
             * Creates a PenaltyKickFailed message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.GameEvent.PenaltyKickFailed
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.GameEvent.PenaltyKickFailed} PenaltyKickFailed
             */
            PenaltyKickFailed.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.GameEvent.PenaltyKickFailed)
                    return object;
                let message = new $root.proto.GameEvent.PenaltyKickFailed();
                switch (object.byTeam) {
                default:
                    if (typeof object.byTeam === "number") {
                        message.byTeam = object.byTeam;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.byTeam = 0;
                    break;
                case "YELLOW":
                case 1:
                    message.byTeam = 1;
                    break;
                case "BLUE":
                case 2:
                    message.byTeam = 2;
                    break;
                }
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".proto.GameEvent.PenaltyKickFailed.location: object expected");
                    message.location = $root.proto.Vector2.fromObject(object.location);
                }
                return message;
            };

            /**
             * Creates a plain object from a PenaltyKickFailed message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.GameEvent.PenaltyKickFailed
             * @static
             * @param {proto.GameEvent.PenaltyKickFailed} message PenaltyKickFailed
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PenaltyKickFailed.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.byTeam = options.enums === String ? "UNKNOWN" : 0;
                    object.location = null;
                }
                if (message.byTeam != null && message.hasOwnProperty("byTeam"))
                    object.byTeam = options.enums === String ? $root.proto.Team[message.byTeam] === undefined ? message.byTeam : $root.proto.Team[message.byTeam] : message.byTeam;
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = $root.proto.Vector2.toObject(message.location, options);
                return object;
            };

            /**
             * Converts this PenaltyKickFailed to JSON.
             * @function toJSON
             * @memberof proto.GameEvent.PenaltyKickFailed
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PenaltyKickFailed.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PenaltyKickFailed
             * @function getTypeUrl
             * @memberof proto.GameEvent.PenaltyKickFailed
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PenaltyKickFailed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.GameEvent.PenaltyKickFailed";
            };

            return PenaltyKickFailed;
        })();

        /**
         * Type enum.
         * @name proto.GameEvent.Type
         * @enum {number}
         * @property {number} UNKNOWN_GAME_EVENT_TYPE=0 UNKNOWN_GAME_EVENT_TYPE value
         * @property {number} BALL_LEFT_FIELD_TOUCH_LINE=6 BALL_LEFT_FIELD_TOUCH_LINE value
         * @property {number} BALL_LEFT_FIELD_GOAL_LINE=7 BALL_LEFT_FIELD_GOAL_LINE value
         * @property {number} AIMLESS_KICK=11 AIMLESS_KICK value
         * @property {number} ATTACKER_TOO_CLOSE_TO_DEFENSE_AREA=19 ATTACKER_TOO_CLOSE_TO_DEFENSE_AREA value
         * @property {number} DEFENDER_IN_DEFENSE_AREA=31 DEFENDER_IN_DEFENSE_AREA value
         * @property {number} BOUNDARY_CROSSING=41 BOUNDARY_CROSSING value
         * @property {number} KEEPER_HELD_BALL=13 KEEPER_HELD_BALL value
         * @property {number} BOT_DRIBBLED_BALL_TOO_FAR=17 BOT_DRIBBLED_BALL_TOO_FAR value
         * @property {number} BOT_PUSHED_BOT=24 BOT_PUSHED_BOT value
         * @property {number} BOT_HELD_BALL_DELIBERATELY=26 BOT_HELD_BALL_DELIBERATELY value
         * @property {number} BOT_TIPPED_OVER=27 BOT_TIPPED_OVER value
         * @property {number} ATTACKER_TOUCHED_BALL_IN_DEFENSE_AREA=15 ATTACKER_TOUCHED_BALL_IN_DEFENSE_AREA value
         * @property {number} BOT_KICKED_BALL_TOO_FAST=18 BOT_KICKED_BALL_TOO_FAST value
         * @property {number} BOT_CRASH_UNIQUE=22 BOT_CRASH_UNIQUE value
         * @property {number} BOT_CRASH_DRAWN=21 BOT_CRASH_DRAWN value
         * @property {number} DEFENDER_TOO_CLOSE_TO_KICK_POINT=29 DEFENDER_TOO_CLOSE_TO_KICK_POINT value
         * @property {number} BOT_TOO_FAST_IN_STOP=28 BOT_TOO_FAST_IN_STOP value
         * @property {number} BOT_INTERFERED_PLACEMENT=20 BOT_INTERFERED_PLACEMENT value
         * @property {number} POSSIBLE_GOAL=39 POSSIBLE_GOAL value
         * @property {number} GOAL=8 GOAL value
         * @property {number} INVALID_GOAL=42 INVALID_GOAL value
         * @property {number} ATTACKER_DOUBLE_TOUCHED_BALL=14 ATTACKER_DOUBLE_TOUCHED_BALL value
         * @property {number} PLACEMENT_SUCCEEDED=5 PLACEMENT_SUCCEEDED value
         * @property {number} PENALTY_KICK_FAILED=43 PENALTY_KICK_FAILED value
         * @property {number} NO_PROGRESS_IN_GAME=2 NO_PROGRESS_IN_GAME value
         * @property {number} PLACEMENT_FAILED=3 PLACEMENT_FAILED value
         * @property {number} MULTIPLE_CARDS=32 MULTIPLE_CARDS value
         * @property {number} MULTIPLE_FOULS=34 MULTIPLE_FOULS value
         * @property {number} BOT_SUBSTITUTION=37 BOT_SUBSTITUTION value
         * @property {number} TOO_MANY_ROBOTS=38 TOO_MANY_ROBOTS value
         * @property {number} CHALLENGE_FLAG=44 CHALLENGE_FLAG value
         * @property {number} EMERGENCY_STOP=45 EMERGENCY_STOP value
         * @property {number} UNSPORTING_BEHAVIOR_MINOR=35 UNSPORTING_BEHAVIOR_MINOR value
         * @property {number} UNSPORTING_BEHAVIOR_MAJOR=36 UNSPORTING_BEHAVIOR_MAJOR value
         */
        GameEvent.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_GAME_EVENT_TYPE"] = 0;
            values[valuesById[6] = "BALL_LEFT_FIELD_TOUCH_LINE"] = 6;
            values[valuesById[7] = "BALL_LEFT_FIELD_GOAL_LINE"] = 7;
            values[valuesById[11] = "AIMLESS_KICK"] = 11;
            values[valuesById[19] = "ATTACKER_TOO_CLOSE_TO_DEFENSE_AREA"] = 19;
            values[valuesById[31] = "DEFENDER_IN_DEFENSE_AREA"] = 31;
            values[valuesById[41] = "BOUNDARY_CROSSING"] = 41;
            values[valuesById[13] = "KEEPER_HELD_BALL"] = 13;
            values[valuesById[17] = "BOT_DRIBBLED_BALL_TOO_FAR"] = 17;
            values[valuesById[24] = "BOT_PUSHED_BOT"] = 24;
            values[valuesById[26] = "BOT_HELD_BALL_DELIBERATELY"] = 26;
            values[valuesById[27] = "BOT_TIPPED_OVER"] = 27;
            values[valuesById[15] = "ATTACKER_TOUCHED_BALL_IN_DEFENSE_AREA"] = 15;
            values[valuesById[18] = "BOT_KICKED_BALL_TOO_FAST"] = 18;
            values[valuesById[22] = "BOT_CRASH_UNIQUE"] = 22;
            values[valuesById[21] = "BOT_CRASH_DRAWN"] = 21;
            values[valuesById[29] = "DEFENDER_TOO_CLOSE_TO_KICK_POINT"] = 29;
            values[valuesById[28] = "BOT_TOO_FAST_IN_STOP"] = 28;
            values[valuesById[20] = "BOT_INTERFERED_PLACEMENT"] = 20;
            values[valuesById[39] = "POSSIBLE_GOAL"] = 39;
            values[valuesById[8] = "GOAL"] = 8;
            values[valuesById[42] = "INVALID_GOAL"] = 42;
            values[valuesById[14] = "ATTACKER_DOUBLE_TOUCHED_BALL"] = 14;
            values[valuesById[5] = "PLACEMENT_SUCCEEDED"] = 5;
            values[valuesById[43] = "PENALTY_KICK_FAILED"] = 43;
            values[valuesById[2] = "NO_PROGRESS_IN_GAME"] = 2;
            values[valuesById[3] = "PLACEMENT_FAILED"] = 3;
            values[valuesById[32] = "MULTIPLE_CARDS"] = 32;
            values[valuesById[34] = "MULTIPLE_FOULS"] = 34;
            values[valuesById[37] = "BOT_SUBSTITUTION"] = 37;
            values[valuesById[38] = "TOO_MANY_ROBOTS"] = 38;
            values[valuesById[44] = "CHALLENGE_FLAG"] = 44;
            values[valuesById[45] = "EMERGENCY_STOP"] = 45;
            values[valuesById[35] = "UNSPORTING_BEHAVIOR_MINOR"] = 35;
            values[valuesById[36] = "UNSPORTING_BEHAVIOR_MAJOR"] = 36;
            return values;
        })();

        return GameEvent;
    })();

    proto.RoboCup2014Legacy = (function() {

        /**
         * Namespace RoboCup2014Legacy.
         * @memberof proto
         * @namespace
         */
        const RoboCup2014Legacy = {};

        RoboCup2014Legacy.Geometry = (function() {

            /**
             * Namespace Geometry.
             * @memberof proto.RoboCup2014Legacy
             * @namespace
             */
            const Geometry = {};

            Geometry.SSL_GeometryFieldSize = (function() {

                /**
                 * Properties of a SSL_GeometryFieldSize.
                 * @memberof proto.RoboCup2014Legacy.Geometry
                 * @interface ISSL_GeometryFieldSize
                 * @property {number} lineWidth SSL_GeometryFieldSize lineWidth
                 * @property {number} fieldLength SSL_GeometryFieldSize fieldLength
                 * @property {number} fieldWidth SSL_GeometryFieldSize fieldWidth
                 * @property {number} boundaryWidth SSL_GeometryFieldSize boundaryWidth
                 * @property {number} refereeWidth SSL_GeometryFieldSize refereeWidth
                 * @property {number} goalWidth SSL_GeometryFieldSize goalWidth
                 * @property {number} goalDepth SSL_GeometryFieldSize goalDepth
                 * @property {number} goalWallWidth SSL_GeometryFieldSize goalWallWidth
                 * @property {number} centerCircleRadius SSL_GeometryFieldSize centerCircleRadius
                 * @property {number} defenseRadius SSL_GeometryFieldSize defenseRadius
                 * @property {number} defenseStretch SSL_GeometryFieldSize defenseStretch
                 * @property {number} freeKickFromDefenseDist SSL_GeometryFieldSize freeKickFromDefenseDist
                 * @property {number} penaltySpotFromFieldLineDist SSL_GeometryFieldSize penaltySpotFromFieldLineDist
                 * @property {number} penaltyLineFromSpotDist SSL_GeometryFieldSize penaltyLineFromSpotDist
                 */

                /**
                 * Constructs a new SSL_GeometryFieldSize.
                 * @memberof proto.RoboCup2014Legacy.Geometry
                 * @classdesc Represents a SSL_GeometryFieldSize.
                 * @implements ISSL_GeometryFieldSize
                 * @constructor
                 * @param {proto.RoboCup2014Legacy.Geometry.ISSL_GeometryFieldSize=} [properties] Properties to set
                 */
                function SSL_GeometryFieldSize(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SSL_GeometryFieldSize lineWidth.
                 * @member {number} lineWidth
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.lineWidth = 0;

                /**
                 * SSL_GeometryFieldSize fieldLength.
                 * @member {number} fieldLength
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.fieldLength = 0;

                /**
                 * SSL_GeometryFieldSize fieldWidth.
                 * @member {number} fieldWidth
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.fieldWidth = 0;

                /**
                 * SSL_GeometryFieldSize boundaryWidth.
                 * @member {number} boundaryWidth
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.boundaryWidth = 0;

                /**
                 * SSL_GeometryFieldSize refereeWidth.
                 * @member {number} refereeWidth
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.refereeWidth = 0;

                /**
                 * SSL_GeometryFieldSize goalWidth.
                 * @member {number} goalWidth
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.goalWidth = 0;

                /**
                 * SSL_GeometryFieldSize goalDepth.
                 * @member {number} goalDepth
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.goalDepth = 0;

                /**
                 * SSL_GeometryFieldSize goalWallWidth.
                 * @member {number} goalWallWidth
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.goalWallWidth = 0;

                /**
                 * SSL_GeometryFieldSize centerCircleRadius.
                 * @member {number} centerCircleRadius
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.centerCircleRadius = 0;

                /**
                 * SSL_GeometryFieldSize defenseRadius.
                 * @member {number} defenseRadius
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.defenseRadius = 0;

                /**
                 * SSL_GeometryFieldSize defenseStretch.
                 * @member {number} defenseStretch
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.defenseStretch = 0;

                /**
                 * SSL_GeometryFieldSize freeKickFromDefenseDist.
                 * @member {number} freeKickFromDefenseDist
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.freeKickFromDefenseDist = 0;

                /**
                 * SSL_GeometryFieldSize penaltySpotFromFieldLineDist.
                 * @member {number} penaltySpotFromFieldLineDist
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.penaltySpotFromFieldLineDist = 0;

                /**
                 * SSL_GeometryFieldSize penaltyLineFromSpotDist.
                 * @member {number} penaltyLineFromSpotDist
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 */
                SSL_GeometryFieldSize.prototype.penaltyLineFromSpotDist = 0;

                /**
                 * Creates a new SSL_GeometryFieldSize instance using the specified properties.
                 * @function create
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @static
                 * @param {proto.RoboCup2014Legacy.Geometry.ISSL_GeometryFieldSize=} [properties] Properties to set
                 * @returns {proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize} SSL_GeometryFieldSize instance
                 */
                SSL_GeometryFieldSize.create = function create(properties) {
                    return new SSL_GeometryFieldSize(properties);
                };

                /**
                 * Encodes the specified SSL_GeometryFieldSize message. Does not implicitly {@link proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize.verify|verify} messages.
                 * @function encode
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @static
                 * @param {proto.RoboCup2014Legacy.Geometry.ISSL_GeometryFieldSize} message SSL_GeometryFieldSize message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SSL_GeometryFieldSize.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lineWidth);
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fieldLength);
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fieldWidth);
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.boundaryWidth);
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.refereeWidth);
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.goalWidth);
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.goalDepth);
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.goalWallWidth);
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.centerCircleRadius);
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.defenseRadius);
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.defenseStretch);
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.freeKickFromDefenseDist);
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.penaltySpotFromFieldLineDist);
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.penaltyLineFromSpotDist);
                    return writer;
                };

                /**
                 * Encodes the specified SSL_GeometryFieldSize message, length delimited. Does not implicitly {@link proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @static
                 * @param {proto.RoboCup2014Legacy.Geometry.ISSL_GeometryFieldSize} message SSL_GeometryFieldSize message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SSL_GeometryFieldSize.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SSL_GeometryFieldSize message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize} SSL_GeometryFieldSize
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SSL_GeometryFieldSize.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.lineWidth = reader.int32();
                                break;
                            }
                        case 2: {
                                message.fieldLength = reader.int32();
                                break;
                            }
                        case 3: {
                                message.fieldWidth = reader.int32();
                                break;
                            }
                        case 4: {
                                message.boundaryWidth = reader.int32();
                                break;
                            }
                        case 5: {
                                message.refereeWidth = reader.int32();
                                break;
                            }
                        case 6: {
                                message.goalWidth = reader.int32();
                                break;
                            }
                        case 7: {
                                message.goalDepth = reader.int32();
                                break;
                            }
                        case 8: {
                                message.goalWallWidth = reader.int32();
                                break;
                            }
                        case 9: {
                                message.centerCircleRadius = reader.int32();
                                break;
                            }
                        case 10: {
                                message.defenseRadius = reader.int32();
                                break;
                            }
                        case 11: {
                                message.defenseStretch = reader.int32();
                                break;
                            }
                        case 12: {
                                message.freeKickFromDefenseDist = reader.int32();
                                break;
                            }
                        case 13: {
                                message.penaltySpotFromFieldLineDist = reader.int32();
                                break;
                            }
                        case 14: {
                                message.penaltyLineFromSpotDist = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("lineWidth"))
                        throw $util.ProtocolError("missing required 'lineWidth'", { instance: message });
                    if (!message.hasOwnProperty("fieldLength"))
                        throw $util.ProtocolError("missing required 'fieldLength'", { instance: message });
                    if (!message.hasOwnProperty("fieldWidth"))
                        throw $util.ProtocolError("missing required 'fieldWidth'", { instance: message });
                    if (!message.hasOwnProperty("boundaryWidth"))
                        throw $util.ProtocolError("missing required 'boundaryWidth'", { instance: message });
                    if (!message.hasOwnProperty("refereeWidth"))
                        throw $util.ProtocolError("missing required 'refereeWidth'", { instance: message });
                    if (!message.hasOwnProperty("goalWidth"))
                        throw $util.ProtocolError("missing required 'goalWidth'", { instance: message });
                    if (!message.hasOwnProperty("goalDepth"))
                        throw $util.ProtocolError("missing required 'goalDepth'", { instance: message });
                    if (!message.hasOwnProperty("goalWallWidth"))
                        throw $util.ProtocolError("missing required 'goalWallWidth'", { instance: message });
                    if (!message.hasOwnProperty("centerCircleRadius"))
                        throw $util.ProtocolError("missing required 'centerCircleRadius'", { instance: message });
                    if (!message.hasOwnProperty("defenseRadius"))
                        throw $util.ProtocolError("missing required 'defenseRadius'", { instance: message });
                    if (!message.hasOwnProperty("defenseStretch"))
                        throw $util.ProtocolError("missing required 'defenseStretch'", { instance: message });
                    if (!message.hasOwnProperty("freeKickFromDefenseDist"))
                        throw $util.ProtocolError("missing required 'freeKickFromDefenseDist'", { instance: message });
                    if (!message.hasOwnProperty("penaltySpotFromFieldLineDist"))
                        throw $util.ProtocolError("missing required 'penaltySpotFromFieldLineDist'", { instance: message });
                    if (!message.hasOwnProperty("penaltyLineFromSpotDist"))
                        throw $util.ProtocolError("missing required 'penaltyLineFromSpotDist'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a SSL_GeometryFieldSize message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize} SSL_GeometryFieldSize
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SSL_GeometryFieldSize.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SSL_GeometryFieldSize message.
                 * @function verify
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SSL_GeometryFieldSize.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isInteger(message.lineWidth))
                        return "lineWidth: integer expected";
                    if (!$util.isInteger(message.fieldLength))
                        return "fieldLength: integer expected";
                    if (!$util.isInteger(message.fieldWidth))
                        return "fieldWidth: integer expected";
                    if (!$util.isInteger(message.boundaryWidth))
                        return "boundaryWidth: integer expected";
                    if (!$util.isInteger(message.refereeWidth))
                        return "refereeWidth: integer expected";
                    if (!$util.isInteger(message.goalWidth))
                        return "goalWidth: integer expected";
                    if (!$util.isInteger(message.goalDepth))
                        return "goalDepth: integer expected";
                    if (!$util.isInteger(message.goalWallWidth))
                        return "goalWallWidth: integer expected";
                    if (!$util.isInteger(message.centerCircleRadius))
                        return "centerCircleRadius: integer expected";
                    if (!$util.isInteger(message.defenseRadius))
                        return "defenseRadius: integer expected";
                    if (!$util.isInteger(message.defenseStretch))
                        return "defenseStretch: integer expected";
                    if (!$util.isInteger(message.freeKickFromDefenseDist))
                        return "freeKickFromDefenseDist: integer expected";
                    if (!$util.isInteger(message.penaltySpotFromFieldLineDist))
                        return "penaltySpotFromFieldLineDist: integer expected";
                    if (!$util.isInteger(message.penaltyLineFromSpotDist))
                        return "penaltyLineFromSpotDist: integer expected";
                    return null;
                };

                /**
                 * Creates a SSL_GeometryFieldSize message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize} SSL_GeometryFieldSize
                 */
                SSL_GeometryFieldSize.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize)
                        return object;
                    let message = new $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize();
                    if (object.lineWidth != null)
                        message.lineWidth = object.lineWidth | 0;
                    if (object.fieldLength != null)
                        message.fieldLength = object.fieldLength | 0;
                    if (object.fieldWidth != null)
                        message.fieldWidth = object.fieldWidth | 0;
                    if (object.boundaryWidth != null)
                        message.boundaryWidth = object.boundaryWidth | 0;
                    if (object.refereeWidth != null)
                        message.refereeWidth = object.refereeWidth | 0;
                    if (object.goalWidth != null)
                        message.goalWidth = object.goalWidth | 0;
                    if (object.goalDepth != null)
                        message.goalDepth = object.goalDepth | 0;
                    if (object.goalWallWidth != null)
                        message.goalWallWidth = object.goalWallWidth | 0;
                    if (object.centerCircleRadius != null)
                        message.centerCircleRadius = object.centerCircleRadius | 0;
                    if (object.defenseRadius != null)
                        message.defenseRadius = object.defenseRadius | 0;
                    if (object.defenseStretch != null)
                        message.defenseStretch = object.defenseStretch | 0;
                    if (object.freeKickFromDefenseDist != null)
                        message.freeKickFromDefenseDist = object.freeKickFromDefenseDist | 0;
                    if (object.penaltySpotFromFieldLineDist != null)
                        message.penaltySpotFromFieldLineDist = object.penaltySpotFromFieldLineDist | 0;
                    if (object.penaltyLineFromSpotDist != null)
                        message.penaltyLineFromSpotDist = object.penaltyLineFromSpotDist | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a SSL_GeometryFieldSize message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @static
                 * @param {proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize} message SSL_GeometryFieldSize
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SSL_GeometryFieldSize.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.lineWidth = 0;
                        object.fieldLength = 0;
                        object.fieldWidth = 0;
                        object.boundaryWidth = 0;
                        object.refereeWidth = 0;
                        object.goalWidth = 0;
                        object.goalDepth = 0;
                        object.goalWallWidth = 0;
                        object.centerCircleRadius = 0;
                        object.defenseRadius = 0;
                        object.defenseStretch = 0;
                        object.freeKickFromDefenseDist = 0;
                        object.penaltySpotFromFieldLineDist = 0;
                        object.penaltyLineFromSpotDist = 0;
                    }
                    if (message.lineWidth != null && message.hasOwnProperty("lineWidth"))
                        object.lineWidth = message.lineWidth;
                    if (message.fieldLength != null && message.hasOwnProperty("fieldLength"))
                        object.fieldLength = message.fieldLength;
                    if (message.fieldWidth != null && message.hasOwnProperty("fieldWidth"))
                        object.fieldWidth = message.fieldWidth;
                    if (message.boundaryWidth != null && message.hasOwnProperty("boundaryWidth"))
                        object.boundaryWidth = message.boundaryWidth;
                    if (message.refereeWidth != null && message.hasOwnProperty("refereeWidth"))
                        object.refereeWidth = message.refereeWidth;
                    if (message.goalWidth != null && message.hasOwnProperty("goalWidth"))
                        object.goalWidth = message.goalWidth;
                    if (message.goalDepth != null && message.hasOwnProperty("goalDepth"))
                        object.goalDepth = message.goalDepth;
                    if (message.goalWallWidth != null && message.hasOwnProperty("goalWallWidth"))
                        object.goalWallWidth = message.goalWallWidth;
                    if (message.centerCircleRadius != null && message.hasOwnProperty("centerCircleRadius"))
                        object.centerCircleRadius = message.centerCircleRadius;
                    if (message.defenseRadius != null && message.hasOwnProperty("defenseRadius"))
                        object.defenseRadius = message.defenseRadius;
                    if (message.defenseStretch != null && message.hasOwnProperty("defenseStretch"))
                        object.defenseStretch = message.defenseStretch;
                    if (message.freeKickFromDefenseDist != null && message.hasOwnProperty("freeKickFromDefenseDist"))
                        object.freeKickFromDefenseDist = message.freeKickFromDefenseDist;
                    if (message.penaltySpotFromFieldLineDist != null && message.hasOwnProperty("penaltySpotFromFieldLineDist"))
                        object.penaltySpotFromFieldLineDist = message.penaltySpotFromFieldLineDist;
                    if (message.penaltyLineFromSpotDist != null && message.hasOwnProperty("penaltyLineFromSpotDist"))
                        object.penaltyLineFromSpotDist = message.penaltyLineFromSpotDist;
                    return object;
                };

                /**
                 * Converts this SSL_GeometryFieldSize to JSON.
                 * @function toJSON
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SSL_GeometryFieldSize.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SSL_GeometryFieldSize
                 * @function getTypeUrl
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SSL_GeometryFieldSize.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize";
                };

                return SSL_GeometryFieldSize;
            })();

            Geometry.SSL_GeometryData = (function() {

                /**
                 * Properties of a SSL_GeometryData.
                 * @memberof proto.RoboCup2014Legacy.Geometry
                 * @interface ISSL_GeometryData
                 * @property {proto.RoboCup2014Legacy.Geometry.ISSL_GeometryFieldSize} field SSL_GeometryData field
                 * @property {Array.<proto.ISSL_GeometryCameraCalibration>|null} [calib] SSL_GeometryData calib
                 */

                /**
                 * Constructs a new SSL_GeometryData.
                 * @memberof proto.RoboCup2014Legacy.Geometry
                 * @classdesc Represents a SSL_GeometryData.
                 * @implements ISSL_GeometryData
                 * @constructor
                 * @param {proto.RoboCup2014Legacy.Geometry.ISSL_GeometryData=} [properties] Properties to set
                 */
                function SSL_GeometryData(properties) {
                    this.calib = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SSL_GeometryData field.
                 * @member {proto.RoboCup2014Legacy.Geometry.ISSL_GeometryFieldSize} field
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryData
                 * @instance
                 */
                SSL_GeometryData.prototype.field = null;

                /**
                 * SSL_GeometryData calib.
                 * @member {Array.<proto.ISSL_GeometryCameraCalibration>} calib
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryData
                 * @instance
                 */
                SSL_GeometryData.prototype.calib = $util.emptyArray;

                /**
                 * Creates a new SSL_GeometryData instance using the specified properties.
                 * @function create
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryData
                 * @static
                 * @param {proto.RoboCup2014Legacy.Geometry.ISSL_GeometryData=} [properties] Properties to set
                 * @returns {proto.RoboCup2014Legacy.Geometry.SSL_GeometryData} SSL_GeometryData instance
                 */
                SSL_GeometryData.create = function create(properties) {
                    return new SSL_GeometryData(properties);
                };

                /**
                 * Encodes the specified SSL_GeometryData message. Does not implicitly {@link proto.RoboCup2014Legacy.Geometry.SSL_GeometryData.verify|verify} messages.
                 * @function encode
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryData
                 * @static
                 * @param {proto.RoboCup2014Legacy.Geometry.ISSL_GeometryData} message SSL_GeometryData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SSL_GeometryData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize.encode(message.field, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.calib != null && message.calib.length)
                        for (let i = 0; i < message.calib.length; ++i)
                            $root.proto.SSL_GeometryCameraCalibration.encode(message.calib[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SSL_GeometryData message, length delimited. Does not implicitly {@link proto.RoboCup2014Legacy.Geometry.SSL_GeometryData.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryData
                 * @static
                 * @param {proto.RoboCup2014Legacy.Geometry.ISSL_GeometryData} message SSL_GeometryData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SSL_GeometryData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SSL_GeometryData message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.RoboCup2014Legacy.Geometry.SSL_GeometryData} SSL_GeometryData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SSL_GeometryData.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryData();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.field = $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                if (!(message.calib && message.calib.length))
                                    message.calib = [];
                                message.calib.push($root.proto.SSL_GeometryCameraCalibration.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("field"))
                        throw $util.ProtocolError("missing required 'field'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a SSL_GeometryData message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.RoboCup2014Legacy.Geometry.SSL_GeometryData} SSL_GeometryData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SSL_GeometryData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SSL_GeometryData message.
                 * @function verify
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SSL_GeometryData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    {
                        let error = $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize.verify(message.field);
                        if (error)
                            return "field." + error;
                    }
                    if (message.calib != null && message.hasOwnProperty("calib")) {
                        if (!Array.isArray(message.calib))
                            return "calib: array expected";
                        for (let i = 0; i < message.calib.length; ++i) {
                            let error = $root.proto.SSL_GeometryCameraCalibration.verify(message.calib[i]);
                            if (error)
                                return "calib." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SSL_GeometryData message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryData
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.RoboCup2014Legacy.Geometry.SSL_GeometryData} SSL_GeometryData
                 */
                SSL_GeometryData.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryData)
                        return object;
                    let message = new $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryData();
                    if (object.field != null) {
                        if (typeof object.field !== "object")
                            throw TypeError(".proto.RoboCup2014Legacy.Geometry.SSL_GeometryData.field: object expected");
                        message.field = $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize.fromObject(object.field);
                    }
                    if (object.calib) {
                        if (!Array.isArray(object.calib))
                            throw TypeError(".proto.RoboCup2014Legacy.Geometry.SSL_GeometryData.calib: array expected");
                        message.calib = [];
                        for (let i = 0; i < object.calib.length; ++i) {
                            if (typeof object.calib[i] !== "object")
                                throw TypeError(".proto.RoboCup2014Legacy.Geometry.SSL_GeometryData.calib: object expected");
                            message.calib[i] = $root.proto.SSL_GeometryCameraCalibration.fromObject(object.calib[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SSL_GeometryData message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryData
                 * @static
                 * @param {proto.RoboCup2014Legacy.Geometry.SSL_GeometryData} message SSL_GeometryData
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SSL_GeometryData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.calib = [];
                    if (options.defaults)
                        object.field = null;
                    if (message.field != null && message.hasOwnProperty("field"))
                        object.field = $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryFieldSize.toObject(message.field, options);
                    if (message.calib && message.calib.length) {
                        object.calib = [];
                        for (let j = 0; j < message.calib.length; ++j)
                            object.calib[j] = $root.proto.SSL_GeometryCameraCalibration.toObject(message.calib[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SSL_GeometryData to JSON.
                 * @function toJSON
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryData
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SSL_GeometryData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SSL_GeometryData
                 * @function getTypeUrl
                 * @memberof proto.RoboCup2014Legacy.Geometry.SSL_GeometryData
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SSL_GeometryData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/proto.RoboCup2014Legacy.Geometry.SSL_GeometryData";
                };

                return SSL_GeometryData;
            })();

            return Geometry;
        })();

        RoboCup2014Legacy.Wrapper = (function() {

            /**
             * Namespace Wrapper.
             * @memberof proto.RoboCup2014Legacy
             * @namespace
             */
            const Wrapper = {};

            Wrapper.SSL_WrapperPacket = (function() {

                /**
                 * Properties of a SSL_WrapperPacket.
                 * @memberof proto.RoboCup2014Legacy.Wrapper
                 * @interface ISSL_WrapperPacket
                 * @property {proto.ISSL_DetectionFrame|null} [detection] SSL_WrapperPacket detection
                 * @property {proto.RoboCup2014Legacy.Geometry.ISSL_GeometryData|null} [geometry] SSL_WrapperPacket geometry
                 */

                /**
                 * Constructs a new SSL_WrapperPacket.
                 * @memberof proto.RoboCup2014Legacy.Wrapper
                 * @classdesc Represents a SSL_WrapperPacket.
                 * @implements ISSL_WrapperPacket
                 * @constructor
                 * @param {proto.RoboCup2014Legacy.Wrapper.ISSL_WrapperPacket=} [properties] Properties to set
                 */
                function SSL_WrapperPacket(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SSL_WrapperPacket detection.
                 * @member {proto.ISSL_DetectionFrame|null|undefined} detection
                 * @memberof proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket
                 * @instance
                 */
                SSL_WrapperPacket.prototype.detection = null;

                /**
                 * SSL_WrapperPacket geometry.
                 * @member {proto.RoboCup2014Legacy.Geometry.ISSL_GeometryData|null|undefined} geometry
                 * @memberof proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket
                 * @instance
                 */
                SSL_WrapperPacket.prototype.geometry = null;

                /**
                 * Creates a new SSL_WrapperPacket instance using the specified properties.
                 * @function create
                 * @memberof proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket
                 * @static
                 * @param {proto.RoboCup2014Legacy.Wrapper.ISSL_WrapperPacket=} [properties] Properties to set
                 * @returns {proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket} SSL_WrapperPacket instance
                 */
                SSL_WrapperPacket.create = function create(properties) {
                    return new SSL_WrapperPacket(properties);
                };

                /**
                 * Encodes the specified SSL_WrapperPacket message. Does not implicitly {@link proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket.verify|verify} messages.
                 * @function encode
                 * @memberof proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket
                 * @static
                 * @param {proto.RoboCup2014Legacy.Wrapper.ISSL_WrapperPacket} message SSL_WrapperPacket message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SSL_WrapperPacket.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.detection != null && Object.hasOwnProperty.call(message, "detection"))
                        $root.proto.SSL_DetectionFrame.encode(message.detection, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.geometry != null && Object.hasOwnProperty.call(message, "geometry"))
                        $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryData.encode(message.geometry, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SSL_WrapperPacket message, length delimited. Does not implicitly {@link proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket
                 * @static
                 * @param {proto.RoboCup2014Legacy.Wrapper.ISSL_WrapperPacket} message SSL_WrapperPacket message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SSL_WrapperPacket.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SSL_WrapperPacket message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket} SSL_WrapperPacket
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SSL_WrapperPacket.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.detection = $root.proto.SSL_DetectionFrame.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.geometry = $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryData.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SSL_WrapperPacket message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket} SSL_WrapperPacket
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SSL_WrapperPacket.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SSL_WrapperPacket message.
                 * @function verify
                 * @memberof proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SSL_WrapperPacket.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.detection != null && message.hasOwnProperty("detection")) {
                        let error = $root.proto.SSL_DetectionFrame.verify(message.detection);
                        if (error)
                            return "detection." + error;
                    }
                    if (message.geometry != null && message.hasOwnProperty("geometry")) {
                        let error = $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryData.verify(message.geometry);
                        if (error)
                            return "geometry." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SSL_WrapperPacket message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket} SSL_WrapperPacket
                 */
                SSL_WrapperPacket.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket)
                        return object;
                    let message = new $root.proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket();
                    if (object.detection != null) {
                        if (typeof object.detection !== "object")
                            throw TypeError(".proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket.detection: object expected");
                        message.detection = $root.proto.SSL_DetectionFrame.fromObject(object.detection);
                    }
                    if (object.geometry != null) {
                        if (typeof object.geometry !== "object")
                            throw TypeError(".proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket.geometry: object expected");
                        message.geometry = $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryData.fromObject(object.geometry);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SSL_WrapperPacket message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket
                 * @static
                 * @param {proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket} message SSL_WrapperPacket
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SSL_WrapperPacket.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.detection = null;
                        object.geometry = null;
                    }
                    if (message.detection != null && message.hasOwnProperty("detection"))
                        object.detection = $root.proto.SSL_DetectionFrame.toObject(message.detection, options);
                    if (message.geometry != null && message.hasOwnProperty("geometry"))
                        object.geometry = $root.proto.RoboCup2014Legacy.Geometry.SSL_GeometryData.toObject(message.geometry, options);
                    return object;
                };

                /**
                 * Converts this SSL_WrapperPacket to JSON.
                 * @function toJSON
                 * @memberof proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SSL_WrapperPacket.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SSL_WrapperPacket
                 * @function getTypeUrl
                 * @memberof proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SSL_WrapperPacket.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/proto.RoboCup2014Legacy.Wrapper.SSL_WrapperPacket";
                };

                return SSL_WrapperPacket;
            })();

            return Wrapper;
        })();

        return RoboCup2014Legacy;
    })();

    proto.SSL_FieldLineSegment = (function() {

        /**
         * Properties of a SSL_FieldLineSegment.
         * @memberof proto
         * @interface ISSL_FieldLineSegment
         * @property {string} name SSL_FieldLineSegment name
         * @property {proto.IVector2f} p1 SSL_FieldLineSegment p1
         * @property {proto.IVector2f} p2 SSL_FieldLineSegment p2
         * @property {number} thickness SSL_FieldLineSegment thickness
         * @property {proto.SSL_FieldShapeType|null} [type] SSL_FieldLineSegment type
         */

        /**
         * Constructs a new SSL_FieldLineSegment.
         * @memberof proto
         * @classdesc Represents a SSL_FieldLineSegment.
         * @implements ISSL_FieldLineSegment
         * @constructor
         * @param {proto.ISSL_FieldLineSegment=} [properties] Properties to set
         */
        function SSL_FieldLineSegment(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SSL_FieldLineSegment name.
         * @member {string} name
         * @memberof proto.SSL_FieldLineSegment
         * @instance
         */
        SSL_FieldLineSegment.prototype.name = "";

        /**
         * SSL_FieldLineSegment p1.
         * @member {proto.IVector2f} p1
         * @memberof proto.SSL_FieldLineSegment
         * @instance
         */
        SSL_FieldLineSegment.prototype.p1 = null;

        /**
         * SSL_FieldLineSegment p2.
         * @member {proto.IVector2f} p2
         * @memberof proto.SSL_FieldLineSegment
         * @instance
         */
        SSL_FieldLineSegment.prototype.p2 = null;

        /**
         * SSL_FieldLineSegment thickness.
         * @member {number} thickness
         * @memberof proto.SSL_FieldLineSegment
         * @instance
         */
        SSL_FieldLineSegment.prototype.thickness = 0;

        /**
         * SSL_FieldLineSegment type.
         * @member {proto.SSL_FieldShapeType} type
         * @memberof proto.SSL_FieldLineSegment
         * @instance
         */
        SSL_FieldLineSegment.prototype.type = 0;

        /**
         * Creates a new SSL_FieldLineSegment instance using the specified properties.
         * @function create
         * @memberof proto.SSL_FieldLineSegment
         * @static
         * @param {proto.ISSL_FieldLineSegment=} [properties] Properties to set
         * @returns {proto.SSL_FieldLineSegment} SSL_FieldLineSegment instance
         */
        SSL_FieldLineSegment.create = function create(properties) {
            return new SSL_FieldLineSegment(properties);
        };

        /**
         * Encodes the specified SSL_FieldLineSegment message. Does not implicitly {@link proto.SSL_FieldLineSegment.verify|verify} messages.
         * @function encode
         * @memberof proto.SSL_FieldLineSegment
         * @static
         * @param {proto.ISSL_FieldLineSegment} message SSL_FieldLineSegment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_FieldLineSegment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            $root.proto.Vector2f.encode(message.p1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            $root.proto.Vector2f.encode(message.p2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.thickness);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified SSL_FieldLineSegment message, length delimited. Does not implicitly {@link proto.SSL_FieldLineSegment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SSL_FieldLineSegment
         * @static
         * @param {proto.ISSL_FieldLineSegment} message SSL_FieldLineSegment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_FieldLineSegment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SSL_FieldLineSegment message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SSL_FieldLineSegment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SSL_FieldLineSegment} SSL_FieldLineSegment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_FieldLineSegment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SSL_FieldLineSegment();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.p1 = $root.proto.Vector2f.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.p2 = $root.proto.Vector2f.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.thickness = reader.float();
                        break;
                    }
                case 5: {
                        message.type = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("p1"))
                throw $util.ProtocolError("missing required 'p1'", { instance: message });
            if (!message.hasOwnProperty("p2"))
                throw $util.ProtocolError("missing required 'p2'", { instance: message });
            if (!message.hasOwnProperty("thickness"))
                throw $util.ProtocolError("missing required 'thickness'", { instance: message });
            return message;
        };

        /**
         * Decodes a SSL_FieldLineSegment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SSL_FieldLineSegment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SSL_FieldLineSegment} SSL_FieldLineSegment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_FieldLineSegment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SSL_FieldLineSegment message.
         * @function verify
         * @memberof proto.SSL_FieldLineSegment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SSL_FieldLineSegment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            {
                let error = $root.proto.Vector2f.verify(message.p1);
                if (error)
                    return "p1." + error;
            }
            {
                let error = $root.proto.Vector2f.verify(message.p2);
                if (error)
                    return "p2." + error;
            }
            if (typeof message.thickness !== "number")
                return "thickness: number expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                    break;
                }
            return null;
        };

        /**
         * Creates a SSL_FieldLineSegment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SSL_FieldLineSegment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SSL_FieldLineSegment} SSL_FieldLineSegment
         */
        SSL_FieldLineSegment.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SSL_FieldLineSegment)
                return object;
            let message = new $root.proto.SSL_FieldLineSegment();
            if (object.name != null)
                message.name = String(object.name);
            if (object.p1 != null) {
                if (typeof object.p1 !== "object")
                    throw TypeError(".proto.SSL_FieldLineSegment.p1: object expected");
                message.p1 = $root.proto.Vector2f.fromObject(object.p1);
            }
            if (object.p2 != null) {
                if (typeof object.p2 !== "object")
                    throw TypeError(".proto.SSL_FieldLineSegment.p2: object expected");
                message.p2 = $root.proto.Vector2f.fromObject(object.p2);
            }
            if (object.thickness != null)
                message.thickness = Number(object.thickness);
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "Undefined":
            case 0:
                message.type = 0;
                break;
            case "CenterCircle":
            case 1:
                message.type = 1;
                break;
            case "TopTouchLine":
            case 2:
                message.type = 2;
                break;
            case "BottomTouchLine":
            case 3:
                message.type = 3;
                break;
            case "LeftGoalLine":
            case 4:
                message.type = 4;
                break;
            case "RightGoalLine":
            case 5:
                message.type = 5;
                break;
            case "HalfwayLine":
            case 6:
                message.type = 6;
                break;
            case "CenterLine":
            case 7:
                message.type = 7;
                break;
            case "LeftPenaltyStretch":
            case 8:
                message.type = 8;
                break;
            case "RightPenaltyStretch":
            case 9:
                message.type = 9;
                break;
            case "LeftFieldLeftPenaltyStretch":
            case 10:
                message.type = 10;
                break;
            case "LeftFieldRightPenaltyStretch":
            case 11:
                message.type = 11;
                break;
            case "RightFieldLeftPenaltyStretch":
            case 12:
                message.type = 12;
                break;
            case "RightFieldRightPenaltyStretch":
            case 13:
                message.type = 13;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SSL_FieldLineSegment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SSL_FieldLineSegment
         * @static
         * @param {proto.SSL_FieldLineSegment} message SSL_FieldLineSegment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SSL_FieldLineSegment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.p1 = null;
                object.p2 = null;
                object.thickness = 0;
                object.type = options.enums === String ? "Undefined" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.p1 != null && message.hasOwnProperty("p1"))
                object.p1 = $root.proto.Vector2f.toObject(message.p1, options);
            if (message.p2 != null && message.hasOwnProperty("p2"))
                object.p2 = $root.proto.Vector2f.toObject(message.p2, options);
            if (message.thickness != null && message.hasOwnProperty("thickness"))
                object.thickness = options.json && !isFinite(message.thickness) ? String(message.thickness) : message.thickness;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.proto.SSL_FieldShapeType[message.type] === undefined ? message.type : $root.proto.SSL_FieldShapeType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this SSL_FieldLineSegment to JSON.
         * @function toJSON
         * @memberof proto.SSL_FieldLineSegment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SSL_FieldLineSegment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SSL_FieldLineSegment
         * @function getTypeUrl
         * @memberof proto.SSL_FieldLineSegment
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SSL_FieldLineSegment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SSL_FieldLineSegment";
        };

        return SSL_FieldLineSegment;
    })();

    proto.SSL_FieldCircularArc = (function() {

        /**
         * Properties of a SSL_FieldCircularArc.
         * @memberof proto
         * @interface ISSL_FieldCircularArc
         * @property {string} name SSL_FieldCircularArc name
         * @property {proto.IVector2f} center SSL_FieldCircularArc center
         * @property {number} radius SSL_FieldCircularArc radius
         * @property {number} a1 SSL_FieldCircularArc a1
         * @property {number} a2 SSL_FieldCircularArc a2
         * @property {number} thickness SSL_FieldCircularArc thickness
         * @property {proto.SSL_FieldShapeType|null} [type] SSL_FieldCircularArc type
         */

        /**
         * Constructs a new SSL_FieldCircularArc.
         * @memberof proto
         * @classdesc Represents a SSL_FieldCircularArc.
         * @implements ISSL_FieldCircularArc
         * @constructor
         * @param {proto.ISSL_FieldCircularArc=} [properties] Properties to set
         */
        function SSL_FieldCircularArc(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SSL_FieldCircularArc name.
         * @member {string} name
         * @memberof proto.SSL_FieldCircularArc
         * @instance
         */
        SSL_FieldCircularArc.prototype.name = "";

        /**
         * SSL_FieldCircularArc center.
         * @member {proto.IVector2f} center
         * @memberof proto.SSL_FieldCircularArc
         * @instance
         */
        SSL_FieldCircularArc.prototype.center = null;

        /**
         * SSL_FieldCircularArc radius.
         * @member {number} radius
         * @memberof proto.SSL_FieldCircularArc
         * @instance
         */
        SSL_FieldCircularArc.prototype.radius = 0;

        /**
         * SSL_FieldCircularArc a1.
         * @member {number} a1
         * @memberof proto.SSL_FieldCircularArc
         * @instance
         */
        SSL_FieldCircularArc.prototype.a1 = 0;

        /**
         * SSL_FieldCircularArc a2.
         * @member {number} a2
         * @memberof proto.SSL_FieldCircularArc
         * @instance
         */
        SSL_FieldCircularArc.prototype.a2 = 0;

        /**
         * SSL_FieldCircularArc thickness.
         * @member {number} thickness
         * @memberof proto.SSL_FieldCircularArc
         * @instance
         */
        SSL_FieldCircularArc.prototype.thickness = 0;

        /**
         * SSL_FieldCircularArc type.
         * @member {proto.SSL_FieldShapeType} type
         * @memberof proto.SSL_FieldCircularArc
         * @instance
         */
        SSL_FieldCircularArc.prototype.type = 0;

        /**
         * Creates a new SSL_FieldCircularArc instance using the specified properties.
         * @function create
         * @memberof proto.SSL_FieldCircularArc
         * @static
         * @param {proto.ISSL_FieldCircularArc=} [properties] Properties to set
         * @returns {proto.SSL_FieldCircularArc} SSL_FieldCircularArc instance
         */
        SSL_FieldCircularArc.create = function create(properties) {
            return new SSL_FieldCircularArc(properties);
        };

        /**
         * Encodes the specified SSL_FieldCircularArc message. Does not implicitly {@link proto.SSL_FieldCircularArc.verify|verify} messages.
         * @function encode
         * @memberof proto.SSL_FieldCircularArc
         * @static
         * @param {proto.ISSL_FieldCircularArc} message SSL_FieldCircularArc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_FieldCircularArc.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            $root.proto.Vector2f.encode(message.center, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.radius);
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.a1);
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.a2);
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.thickness);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified SSL_FieldCircularArc message, length delimited. Does not implicitly {@link proto.SSL_FieldCircularArc.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SSL_FieldCircularArc
         * @static
         * @param {proto.ISSL_FieldCircularArc} message SSL_FieldCircularArc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_FieldCircularArc.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SSL_FieldCircularArc message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SSL_FieldCircularArc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SSL_FieldCircularArc} SSL_FieldCircularArc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_FieldCircularArc.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SSL_FieldCircularArc();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.center = $root.proto.Vector2f.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.radius = reader.float();
                        break;
                    }
                case 4: {
                        message.a1 = reader.float();
                        break;
                    }
                case 5: {
                        message.a2 = reader.float();
                        break;
                    }
                case 6: {
                        message.thickness = reader.float();
                        break;
                    }
                case 7: {
                        message.type = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("center"))
                throw $util.ProtocolError("missing required 'center'", { instance: message });
            if (!message.hasOwnProperty("radius"))
                throw $util.ProtocolError("missing required 'radius'", { instance: message });
            if (!message.hasOwnProperty("a1"))
                throw $util.ProtocolError("missing required 'a1'", { instance: message });
            if (!message.hasOwnProperty("a2"))
                throw $util.ProtocolError("missing required 'a2'", { instance: message });
            if (!message.hasOwnProperty("thickness"))
                throw $util.ProtocolError("missing required 'thickness'", { instance: message });
            return message;
        };

        /**
         * Decodes a SSL_FieldCircularArc message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SSL_FieldCircularArc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SSL_FieldCircularArc} SSL_FieldCircularArc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_FieldCircularArc.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SSL_FieldCircularArc message.
         * @function verify
         * @memberof proto.SSL_FieldCircularArc
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SSL_FieldCircularArc.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            {
                let error = $root.proto.Vector2f.verify(message.center);
                if (error)
                    return "center." + error;
            }
            if (typeof message.radius !== "number")
                return "radius: number expected";
            if (typeof message.a1 !== "number")
                return "a1: number expected";
            if (typeof message.a2 !== "number")
                return "a2: number expected";
            if (typeof message.thickness !== "number")
                return "thickness: number expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                    break;
                }
            return null;
        };

        /**
         * Creates a SSL_FieldCircularArc message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SSL_FieldCircularArc
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SSL_FieldCircularArc} SSL_FieldCircularArc
         */
        SSL_FieldCircularArc.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SSL_FieldCircularArc)
                return object;
            let message = new $root.proto.SSL_FieldCircularArc();
            if (object.name != null)
                message.name = String(object.name);
            if (object.center != null) {
                if (typeof object.center !== "object")
                    throw TypeError(".proto.SSL_FieldCircularArc.center: object expected");
                message.center = $root.proto.Vector2f.fromObject(object.center);
            }
            if (object.radius != null)
                message.radius = Number(object.radius);
            if (object.a1 != null)
                message.a1 = Number(object.a1);
            if (object.a2 != null)
                message.a2 = Number(object.a2);
            if (object.thickness != null)
                message.thickness = Number(object.thickness);
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "Undefined":
            case 0:
                message.type = 0;
                break;
            case "CenterCircle":
            case 1:
                message.type = 1;
                break;
            case "TopTouchLine":
            case 2:
                message.type = 2;
                break;
            case "BottomTouchLine":
            case 3:
                message.type = 3;
                break;
            case "LeftGoalLine":
            case 4:
                message.type = 4;
                break;
            case "RightGoalLine":
            case 5:
                message.type = 5;
                break;
            case "HalfwayLine":
            case 6:
                message.type = 6;
                break;
            case "CenterLine":
            case 7:
                message.type = 7;
                break;
            case "LeftPenaltyStretch":
            case 8:
                message.type = 8;
                break;
            case "RightPenaltyStretch":
            case 9:
                message.type = 9;
                break;
            case "LeftFieldLeftPenaltyStretch":
            case 10:
                message.type = 10;
                break;
            case "LeftFieldRightPenaltyStretch":
            case 11:
                message.type = 11;
                break;
            case "RightFieldLeftPenaltyStretch":
            case 12:
                message.type = 12;
                break;
            case "RightFieldRightPenaltyStretch":
            case 13:
                message.type = 13;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a SSL_FieldCircularArc message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SSL_FieldCircularArc
         * @static
         * @param {proto.SSL_FieldCircularArc} message SSL_FieldCircularArc
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SSL_FieldCircularArc.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.center = null;
                object.radius = 0;
                object.a1 = 0;
                object.a2 = 0;
                object.thickness = 0;
                object.type = options.enums === String ? "Undefined" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.center != null && message.hasOwnProperty("center"))
                object.center = $root.proto.Vector2f.toObject(message.center, options);
            if (message.radius != null && message.hasOwnProperty("radius"))
                object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
            if (message.a1 != null && message.hasOwnProperty("a1"))
                object.a1 = options.json && !isFinite(message.a1) ? String(message.a1) : message.a1;
            if (message.a2 != null && message.hasOwnProperty("a2"))
                object.a2 = options.json && !isFinite(message.a2) ? String(message.a2) : message.a2;
            if (message.thickness != null && message.hasOwnProperty("thickness"))
                object.thickness = options.json && !isFinite(message.thickness) ? String(message.thickness) : message.thickness;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.proto.SSL_FieldShapeType[message.type] === undefined ? message.type : $root.proto.SSL_FieldShapeType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this SSL_FieldCircularArc to JSON.
         * @function toJSON
         * @memberof proto.SSL_FieldCircularArc
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SSL_FieldCircularArc.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SSL_FieldCircularArc
         * @function getTypeUrl
         * @memberof proto.SSL_FieldCircularArc
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SSL_FieldCircularArc.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SSL_FieldCircularArc";
        };

        return SSL_FieldCircularArc;
    })();

    proto.SSL_GeometryFieldSize = (function() {

        /**
         * Properties of a SSL_GeometryFieldSize.
         * @memberof proto
         * @interface ISSL_GeometryFieldSize
         * @property {number} fieldLength SSL_GeometryFieldSize fieldLength
         * @property {number} fieldWidth SSL_GeometryFieldSize fieldWidth
         * @property {number} goalWidth SSL_GeometryFieldSize goalWidth
         * @property {number} goalDepth SSL_GeometryFieldSize goalDepth
         * @property {number} boundaryWidth SSL_GeometryFieldSize boundaryWidth
         * @property {Array.<proto.ISSL_FieldLineSegment>|null} [fieldLines] SSL_GeometryFieldSize fieldLines
         * @property {Array.<proto.ISSL_FieldCircularArc>|null} [fieldArcs] SSL_GeometryFieldSize fieldArcs
         * @property {number|null} [penaltyAreaDepth] SSL_GeometryFieldSize penaltyAreaDepth
         * @property {number|null} [penaltyAreaWidth] SSL_GeometryFieldSize penaltyAreaWidth
         */

        /**
         * Constructs a new SSL_GeometryFieldSize.
         * @memberof proto
         * @classdesc Represents a SSL_GeometryFieldSize.
         * @implements ISSL_GeometryFieldSize
         * @constructor
         * @param {proto.ISSL_GeometryFieldSize=} [properties] Properties to set
         */
        function SSL_GeometryFieldSize(properties) {
            this.fieldLines = [];
            this.fieldArcs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SSL_GeometryFieldSize fieldLength.
         * @member {number} fieldLength
         * @memberof proto.SSL_GeometryFieldSize
         * @instance
         */
        SSL_GeometryFieldSize.prototype.fieldLength = 0;

        /**
         * SSL_GeometryFieldSize fieldWidth.
         * @member {number} fieldWidth
         * @memberof proto.SSL_GeometryFieldSize
         * @instance
         */
        SSL_GeometryFieldSize.prototype.fieldWidth = 0;

        /**
         * SSL_GeometryFieldSize goalWidth.
         * @member {number} goalWidth
         * @memberof proto.SSL_GeometryFieldSize
         * @instance
         */
        SSL_GeometryFieldSize.prototype.goalWidth = 0;

        /**
         * SSL_GeometryFieldSize goalDepth.
         * @member {number} goalDepth
         * @memberof proto.SSL_GeometryFieldSize
         * @instance
         */
        SSL_GeometryFieldSize.prototype.goalDepth = 0;

        /**
         * SSL_GeometryFieldSize boundaryWidth.
         * @member {number} boundaryWidth
         * @memberof proto.SSL_GeometryFieldSize
         * @instance
         */
        SSL_GeometryFieldSize.prototype.boundaryWidth = 0;

        /**
         * SSL_GeometryFieldSize fieldLines.
         * @member {Array.<proto.ISSL_FieldLineSegment>} fieldLines
         * @memberof proto.SSL_GeometryFieldSize
         * @instance
         */
        SSL_GeometryFieldSize.prototype.fieldLines = $util.emptyArray;

        /**
         * SSL_GeometryFieldSize fieldArcs.
         * @member {Array.<proto.ISSL_FieldCircularArc>} fieldArcs
         * @memberof proto.SSL_GeometryFieldSize
         * @instance
         */
        SSL_GeometryFieldSize.prototype.fieldArcs = $util.emptyArray;

        /**
         * SSL_GeometryFieldSize penaltyAreaDepth.
         * @member {number} penaltyAreaDepth
         * @memberof proto.SSL_GeometryFieldSize
         * @instance
         */
        SSL_GeometryFieldSize.prototype.penaltyAreaDepth = 0;

        /**
         * SSL_GeometryFieldSize penaltyAreaWidth.
         * @member {number} penaltyAreaWidth
         * @memberof proto.SSL_GeometryFieldSize
         * @instance
         */
        SSL_GeometryFieldSize.prototype.penaltyAreaWidth = 0;

        /**
         * Creates a new SSL_GeometryFieldSize instance using the specified properties.
         * @function create
         * @memberof proto.SSL_GeometryFieldSize
         * @static
         * @param {proto.ISSL_GeometryFieldSize=} [properties] Properties to set
         * @returns {proto.SSL_GeometryFieldSize} SSL_GeometryFieldSize instance
         */
        SSL_GeometryFieldSize.create = function create(properties) {
            return new SSL_GeometryFieldSize(properties);
        };

        /**
         * Encodes the specified SSL_GeometryFieldSize message. Does not implicitly {@link proto.SSL_GeometryFieldSize.verify|verify} messages.
         * @function encode
         * @memberof proto.SSL_GeometryFieldSize
         * @static
         * @param {proto.ISSL_GeometryFieldSize} message SSL_GeometryFieldSize message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_GeometryFieldSize.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fieldLength);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fieldWidth);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.goalWidth);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.goalDepth);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.boundaryWidth);
            if (message.fieldLines != null && message.fieldLines.length)
                for (let i = 0; i < message.fieldLines.length; ++i)
                    $root.proto.SSL_FieldLineSegment.encode(message.fieldLines[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.fieldArcs != null && message.fieldArcs.length)
                for (let i = 0; i < message.fieldArcs.length; ++i)
                    $root.proto.SSL_FieldCircularArc.encode(message.fieldArcs[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.penaltyAreaDepth != null && Object.hasOwnProperty.call(message, "penaltyAreaDepth"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.penaltyAreaDepth);
            if (message.penaltyAreaWidth != null && Object.hasOwnProperty.call(message, "penaltyAreaWidth"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.penaltyAreaWidth);
            return writer;
        };

        /**
         * Encodes the specified SSL_GeometryFieldSize message, length delimited. Does not implicitly {@link proto.SSL_GeometryFieldSize.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SSL_GeometryFieldSize
         * @static
         * @param {proto.ISSL_GeometryFieldSize} message SSL_GeometryFieldSize message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_GeometryFieldSize.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SSL_GeometryFieldSize message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SSL_GeometryFieldSize
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SSL_GeometryFieldSize} SSL_GeometryFieldSize
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_GeometryFieldSize.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SSL_GeometryFieldSize();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.fieldLength = reader.int32();
                        break;
                    }
                case 2: {
                        message.fieldWidth = reader.int32();
                        break;
                    }
                case 3: {
                        message.goalWidth = reader.int32();
                        break;
                    }
                case 4: {
                        message.goalDepth = reader.int32();
                        break;
                    }
                case 5: {
                        message.boundaryWidth = reader.int32();
                        break;
                    }
                case 6: {
                        if (!(message.fieldLines && message.fieldLines.length))
                            message.fieldLines = [];
                        message.fieldLines.push($root.proto.SSL_FieldLineSegment.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        if (!(message.fieldArcs && message.fieldArcs.length))
                            message.fieldArcs = [];
                        message.fieldArcs.push($root.proto.SSL_FieldCircularArc.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        message.penaltyAreaDepth = reader.int32();
                        break;
                    }
                case 9: {
                        message.penaltyAreaWidth = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("fieldLength"))
                throw $util.ProtocolError("missing required 'fieldLength'", { instance: message });
            if (!message.hasOwnProperty("fieldWidth"))
                throw $util.ProtocolError("missing required 'fieldWidth'", { instance: message });
            if (!message.hasOwnProperty("goalWidth"))
                throw $util.ProtocolError("missing required 'goalWidth'", { instance: message });
            if (!message.hasOwnProperty("goalDepth"))
                throw $util.ProtocolError("missing required 'goalDepth'", { instance: message });
            if (!message.hasOwnProperty("boundaryWidth"))
                throw $util.ProtocolError("missing required 'boundaryWidth'", { instance: message });
            return message;
        };

        /**
         * Decodes a SSL_GeometryFieldSize message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SSL_GeometryFieldSize
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SSL_GeometryFieldSize} SSL_GeometryFieldSize
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_GeometryFieldSize.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SSL_GeometryFieldSize message.
         * @function verify
         * @memberof proto.SSL_GeometryFieldSize
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SSL_GeometryFieldSize.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.fieldLength))
                return "fieldLength: integer expected";
            if (!$util.isInteger(message.fieldWidth))
                return "fieldWidth: integer expected";
            if (!$util.isInteger(message.goalWidth))
                return "goalWidth: integer expected";
            if (!$util.isInteger(message.goalDepth))
                return "goalDepth: integer expected";
            if (!$util.isInteger(message.boundaryWidth))
                return "boundaryWidth: integer expected";
            if (message.fieldLines != null && message.hasOwnProperty("fieldLines")) {
                if (!Array.isArray(message.fieldLines))
                    return "fieldLines: array expected";
                for (let i = 0; i < message.fieldLines.length; ++i) {
                    let error = $root.proto.SSL_FieldLineSegment.verify(message.fieldLines[i]);
                    if (error)
                        return "fieldLines." + error;
                }
            }
            if (message.fieldArcs != null && message.hasOwnProperty("fieldArcs")) {
                if (!Array.isArray(message.fieldArcs))
                    return "fieldArcs: array expected";
                for (let i = 0; i < message.fieldArcs.length; ++i) {
                    let error = $root.proto.SSL_FieldCircularArc.verify(message.fieldArcs[i]);
                    if (error)
                        return "fieldArcs." + error;
                }
            }
            if (message.penaltyAreaDepth != null && message.hasOwnProperty("penaltyAreaDepth"))
                if (!$util.isInteger(message.penaltyAreaDepth))
                    return "penaltyAreaDepth: integer expected";
            if (message.penaltyAreaWidth != null && message.hasOwnProperty("penaltyAreaWidth"))
                if (!$util.isInteger(message.penaltyAreaWidth))
                    return "penaltyAreaWidth: integer expected";
            return null;
        };

        /**
         * Creates a SSL_GeometryFieldSize message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SSL_GeometryFieldSize
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SSL_GeometryFieldSize} SSL_GeometryFieldSize
         */
        SSL_GeometryFieldSize.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SSL_GeometryFieldSize)
                return object;
            let message = new $root.proto.SSL_GeometryFieldSize();
            if (object.fieldLength != null)
                message.fieldLength = object.fieldLength | 0;
            if (object.fieldWidth != null)
                message.fieldWidth = object.fieldWidth | 0;
            if (object.goalWidth != null)
                message.goalWidth = object.goalWidth | 0;
            if (object.goalDepth != null)
                message.goalDepth = object.goalDepth | 0;
            if (object.boundaryWidth != null)
                message.boundaryWidth = object.boundaryWidth | 0;
            if (object.fieldLines) {
                if (!Array.isArray(object.fieldLines))
                    throw TypeError(".proto.SSL_GeometryFieldSize.fieldLines: array expected");
                message.fieldLines = [];
                for (let i = 0; i < object.fieldLines.length; ++i) {
                    if (typeof object.fieldLines[i] !== "object")
                        throw TypeError(".proto.SSL_GeometryFieldSize.fieldLines: object expected");
                    message.fieldLines[i] = $root.proto.SSL_FieldLineSegment.fromObject(object.fieldLines[i]);
                }
            }
            if (object.fieldArcs) {
                if (!Array.isArray(object.fieldArcs))
                    throw TypeError(".proto.SSL_GeometryFieldSize.fieldArcs: array expected");
                message.fieldArcs = [];
                for (let i = 0; i < object.fieldArcs.length; ++i) {
                    if (typeof object.fieldArcs[i] !== "object")
                        throw TypeError(".proto.SSL_GeometryFieldSize.fieldArcs: object expected");
                    message.fieldArcs[i] = $root.proto.SSL_FieldCircularArc.fromObject(object.fieldArcs[i]);
                }
            }
            if (object.penaltyAreaDepth != null)
                message.penaltyAreaDepth = object.penaltyAreaDepth | 0;
            if (object.penaltyAreaWidth != null)
                message.penaltyAreaWidth = object.penaltyAreaWidth | 0;
            return message;
        };

        /**
         * Creates a plain object from a SSL_GeometryFieldSize message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SSL_GeometryFieldSize
         * @static
         * @param {proto.SSL_GeometryFieldSize} message SSL_GeometryFieldSize
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SSL_GeometryFieldSize.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.fieldLines = [];
                object.fieldArcs = [];
            }
            if (options.defaults) {
                object.fieldLength = 0;
                object.fieldWidth = 0;
                object.goalWidth = 0;
                object.goalDepth = 0;
                object.boundaryWidth = 0;
                object.penaltyAreaDepth = 0;
                object.penaltyAreaWidth = 0;
            }
            if (message.fieldLength != null && message.hasOwnProperty("fieldLength"))
                object.fieldLength = message.fieldLength;
            if (message.fieldWidth != null && message.hasOwnProperty("fieldWidth"))
                object.fieldWidth = message.fieldWidth;
            if (message.goalWidth != null && message.hasOwnProperty("goalWidth"))
                object.goalWidth = message.goalWidth;
            if (message.goalDepth != null && message.hasOwnProperty("goalDepth"))
                object.goalDepth = message.goalDepth;
            if (message.boundaryWidth != null && message.hasOwnProperty("boundaryWidth"))
                object.boundaryWidth = message.boundaryWidth;
            if (message.fieldLines && message.fieldLines.length) {
                object.fieldLines = [];
                for (let j = 0; j < message.fieldLines.length; ++j)
                    object.fieldLines[j] = $root.proto.SSL_FieldLineSegment.toObject(message.fieldLines[j], options);
            }
            if (message.fieldArcs && message.fieldArcs.length) {
                object.fieldArcs = [];
                for (let j = 0; j < message.fieldArcs.length; ++j)
                    object.fieldArcs[j] = $root.proto.SSL_FieldCircularArc.toObject(message.fieldArcs[j], options);
            }
            if (message.penaltyAreaDepth != null && message.hasOwnProperty("penaltyAreaDepth"))
                object.penaltyAreaDepth = message.penaltyAreaDepth;
            if (message.penaltyAreaWidth != null && message.hasOwnProperty("penaltyAreaWidth"))
                object.penaltyAreaWidth = message.penaltyAreaWidth;
            return object;
        };

        /**
         * Converts this SSL_GeometryFieldSize to JSON.
         * @function toJSON
         * @memberof proto.SSL_GeometryFieldSize
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SSL_GeometryFieldSize.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SSL_GeometryFieldSize
         * @function getTypeUrl
         * @memberof proto.SSL_GeometryFieldSize
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SSL_GeometryFieldSize.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SSL_GeometryFieldSize";
        };

        return SSL_GeometryFieldSize;
    })();

    proto.SSL_GeometryCameraCalibration = (function() {

        /**
         * Properties of a SSL_GeometryCameraCalibration.
         * @memberof proto
         * @interface ISSL_GeometryCameraCalibration
         * @property {number} cameraId SSL_GeometryCameraCalibration cameraId
         * @property {number} focalLength SSL_GeometryCameraCalibration focalLength
         * @property {number} principalPointX SSL_GeometryCameraCalibration principalPointX
         * @property {number} principalPointY SSL_GeometryCameraCalibration principalPointY
         * @property {number} distortion SSL_GeometryCameraCalibration distortion
         * @property {number} q0 SSL_GeometryCameraCalibration q0
         * @property {number} q1 SSL_GeometryCameraCalibration q1
         * @property {number} q2 SSL_GeometryCameraCalibration q2
         * @property {number} q3 SSL_GeometryCameraCalibration q3
         * @property {number} tx SSL_GeometryCameraCalibration tx
         * @property {number} ty SSL_GeometryCameraCalibration ty
         * @property {number} tz SSL_GeometryCameraCalibration tz
         * @property {number|null} [derivedCameraWorldTx] SSL_GeometryCameraCalibration derivedCameraWorldTx
         * @property {number|null} [derivedCameraWorldTy] SSL_GeometryCameraCalibration derivedCameraWorldTy
         * @property {number|null} [derivedCameraWorldTz] SSL_GeometryCameraCalibration derivedCameraWorldTz
         * @property {number|null} [pixelImageWidth] SSL_GeometryCameraCalibration pixelImageWidth
         * @property {number|null} [pixelImageHeight] SSL_GeometryCameraCalibration pixelImageHeight
         */

        /**
         * Constructs a new SSL_GeometryCameraCalibration.
         * @memberof proto
         * @classdesc Represents a SSL_GeometryCameraCalibration.
         * @implements ISSL_GeometryCameraCalibration
         * @constructor
         * @param {proto.ISSL_GeometryCameraCalibration=} [properties] Properties to set
         */
        function SSL_GeometryCameraCalibration(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SSL_GeometryCameraCalibration cameraId.
         * @member {number} cameraId
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.cameraId = 0;

        /**
         * SSL_GeometryCameraCalibration focalLength.
         * @member {number} focalLength
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.focalLength = 0;

        /**
         * SSL_GeometryCameraCalibration principalPointX.
         * @member {number} principalPointX
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.principalPointX = 0;

        /**
         * SSL_GeometryCameraCalibration principalPointY.
         * @member {number} principalPointY
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.principalPointY = 0;

        /**
         * SSL_GeometryCameraCalibration distortion.
         * @member {number} distortion
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.distortion = 0;

        /**
         * SSL_GeometryCameraCalibration q0.
         * @member {number} q0
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.q0 = 0;

        /**
         * SSL_GeometryCameraCalibration q1.
         * @member {number} q1
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.q1 = 0;

        /**
         * SSL_GeometryCameraCalibration q2.
         * @member {number} q2
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.q2 = 0;

        /**
         * SSL_GeometryCameraCalibration q3.
         * @member {number} q3
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.q3 = 0;

        /**
         * SSL_GeometryCameraCalibration tx.
         * @member {number} tx
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.tx = 0;

        /**
         * SSL_GeometryCameraCalibration ty.
         * @member {number} ty
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.ty = 0;

        /**
         * SSL_GeometryCameraCalibration tz.
         * @member {number} tz
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.tz = 0;

        /**
         * SSL_GeometryCameraCalibration derivedCameraWorldTx.
         * @member {number} derivedCameraWorldTx
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.derivedCameraWorldTx = 0;

        /**
         * SSL_GeometryCameraCalibration derivedCameraWorldTy.
         * @member {number} derivedCameraWorldTy
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.derivedCameraWorldTy = 0;

        /**
         * SSL_GeometryCameraCalibration derivedCameraWorldTz.
         * @member {number} derivedCameraWorldTz
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.derivedCameraWorldTz = 0;

        /**
         * SSL_GeometryCameraCalibration pixelImageWidth.
         * @member {number} pixelImageWidth
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.pixelImageWidth = 0;

        /**
         * SSL_GeometryCameraCalibration pixelImageHeight.
         * @member {number} pixelImageHeight
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         */
        SSL_GeometryCameraCalibration.prototype.pixelImageHeight = 0;

        /**
         * Creates a new SSL_GeometryCameraCalibration instance using the specified properties.
         * @function create
         * @memberof proto.SSL_GeometryCameraCalibration
         * @static
         * @param {proto.ISSL_GeometryCameraCalibration=} [properties] Properties to set
         * @returns {proto.SSL_GeometryCameraCalibration} SSL_GeometryCameraCalibration instance
         */
        SSL_GeometryCameraCalibration.create = function create(properties) {
            return new SSL_GeometryCameraCalibration(properties);
        };

        /**
         * Encodes the specified SSL_GeometryCameraCalibration message. Does not implicitly {@link proto.SSL_GeometryCameraCalibration.verify|verify} messages.
         * @function encode
         * @memberof proto.SSL_GeometryCameraCalibration
         * @static
         * @param {proto.ISSL_GeometryCameraCalibration} message SSL_GeometryCameraCalibration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_GeometryCameraCalibration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.cameraId);
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.focalLength);
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.principalPointX);
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.principalPointY);
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.distortion);
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.q0);
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.q1);
            writer.uint32(/* id 8, wireType 5 =*/69).float(message.q2);
            writer.uint32(/* id 9, wireType 5 =*/77).float(message.q3);
            writer.uint32(/* id 10, wireType 5 =*/85).float(message.tx);
            writer.uint32(/* id 11, wireType 5 =*/93).float(message.ty);
            writer.uint32(/* id 12, wireType 5 =*/101).float(message.tz);
            if (message.derivedCameraWorldTx != null && Object.hasOwnProperty.call(message, "derivedCameraWorldTx"))
                writer.uint32(/* id 13, wireType 5 =*/109).float(message.derivedCameraWorldTx);
            if (message.derivedCameraWorldTy != null && Object.hasOwnProperty.call(message, "derivedCameraWorldTy"))
                writer.uint32(/* id 14, wireType 5 =*/117).float(message.derivedCameraWorldTy);
            if (message.derivedCameraWorldTz != null && Object.hasOwnProperty.call(message, "derivedCameraWorldTz"))
                writer.uint32(/* id 15, wireType 5 =*/125).float(message.derivedCameraWorldTz);
            if (message.pixelImageWidth != null && Object.hasOwnProperty.call(message, "pixelImageWidth"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.pixelImageWidth);
            if (message.pixelImageHeight != null && Object.hasOwnProperty.call(message, "pixelImageHeight"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.pixelImageHeight);
            return writer;
        };

        /**
         * Encodes the specified SSL_GeometryCameraCalibration message, length delimited. Does not implicitly {@link proto.SSL_GeometryCameraCalibration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SSL_GeometryCameraCalibration
         * @static
         * @param {proto.ISSL_GeometryCameraCalibration} message SSL_GeometryCameraCalibration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_GeometryCameraCalibration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SSL_GeometryCameraCalibration message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SSL_GeometryCameraCalibration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SSL_GeometryCameraCalibration} SSL_GeometryCameraCalibration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_GeometryCameraCalibration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SSL_GeometryCameraCalibration();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cameraId = reader.uint32();
                        break;
                    }
                case 2: {
                        message.focalLength = reader.float();
                        break;
                    }
                case 3: {
                        message.principalPointX = reader.float();
                        break;
                    }
                case 4: {
                        message.principalPointY = reader.float();
                        break;
                    }
                case 5: {
                        message.distortion = reader.float();
                        break;
                    }
                case 6: {
                        message.q0 = reader.float();
                        break;
                    }
                case 7: {
                        message.q1 = reader.float();
                        break;
                    }
                case 8: {
                        message.q2 = reader.float();
                        break;
                    }
                case 9: {
                        message.q3 = reader.float();
                        break;
                    }
                case 10: {
                        message.tx = reader.float();
                        break;
                    }
                case 11: {
                        message.ty = reader.float();
                        break;
                    }
                case 12: {
                        message.tz = reader.float();
                        break;
                    }
                case 13: {
                        message.derivedCameraWorldTx = reader.float();
                        break;
                    }
                case 14: {
                        message.derivedCameraWorldTy = reader.float();
                        break;
                    }
                case 15: {
                        message.derivedCameraWorldTz = reader.float();
                        break;
                    }
                case 16: {
                        message.pixelImageWidth = reader.uint32();
                        break;
                    }
                case 17: {
                        message.pixelImageHeight = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("cameraId"))
                throw $util.ProtocolError("missing required 'cameraId'", { instance: message });
            if (!message.hasOwnProperty("focalLength"))
                throw $util.ProtocolError("missing required 'focalLength'", { instance: message });
            if (!message.hasOwnProperty("principalPointX"))
                throw $util.ProtocolError("missing required 'principalPointX'", { instance: message });
            if (!message.hasOwnProperty("principalPointY"))
                throw $util.ProtocolError("missing required 'principalPointY'", { instance: message });
            if (!message.hasOwnProperty("distortion"))
                throw $util.ProtocolError("missing required 'distortion'", { instance: message });
            if (!message.hasOwnProperty("q0"))
                throw $util.ProtocolError("missing required 'q0'", { instance: message });
            if (!message.hasOwnProperty("q1"))
                throw $util.ProtocolError("missing required 'q1'", { instance: message });
            if (!message.hasOwnProperty("q2"))
                throw $util.ProtocolError("missing required 'q2'", { instance: message });
            if (!message.hasOwnProperty("q3"))
                throw $util.ProtocolError("missing required 'q3'", { instance: message });
            if (!message.hasOwnProperty("tx"))
                throw $util.ProtocolError("missing required 'tx'", { instance: message });
            if (!message.hasOwnProperty("ty"))
                throw $util.ProtocolError("missing required 'ty'", { instance: message });
            if (!message.hasOwnProperty("tz"))
                throw $util.ProtocolError("missing required 'tz'", { instance: message });
            return message;
        };

        /**
         * Decodes a SSL_GeometryCameraCalibration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SSL_GeometryCameraCalibration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SSL_GeometryCameraCalibration} SSL_GeometryCameraCalibration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_GeometryCameraCalibration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SSL_GeometryCameraCalibration message.
         * @function verify
         * @memberof proto.SSL_GeometryCameraCalibration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SSL_GeometryCameraCalibration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.cameraId))
                return "cameraId: integer expected";
            if (typeof message.focalLength !== "number")
                return "focalLength: number expected";
            if (typeof message.principalPointX !== "number")
                return "principalPointX: number expected";
            if (typeof message.principalPointY !== "number")
                return "principalPointY: number expected";
            if (typeof message.distortion !== "number")
                return "distortion: number expected";
            if (typeof message.q0 !== "number")
                return "q0: number expected";
            if (typeof message.q1 !== "number")
                return "q1: number expected";
            if (typeof message.q2 !== "number")
                return "q2: number expected";
            if (typeof message.q3 !== "number")
                return "q3: number expected";
            if (typeof message.tx !== "number")
                return "tx: number expected";
            if (typeof message.ty !== "number")
                return "ty: number expected";
            if (typeof message.tz !== "number")
                return "tz: number expected";
            if (message.derivedCameraWorldTx != null && message.hasOwnProperty("derivedCameraWorldTx"))
                if (typeof message.derivedCameraWorldTx !== "number")
                    return "derivedCameraWorldTx: number expected";
            if (message.derivedCameraWorldTy != null && message.hasOwnProperty("derivedCameraWorldTy"))
                if (typeof message.derivedCameraWorldTy !== "number")
                    return "derivedCameraWorldTy: number expected";
            if (message.derivedCameraWorldTz != null && message.hasOwnProperty("derivedCameraWorldTz"))
                if (typeof message.derivedCameraWorldTz !== "number")
                    return "derivedCameraWorldTz: number expected";
            if (message.pixelImageWidth != null && message.hasOwnProperty("pixelImageWidth"))
                if (!$util.isInteger(message.pixelImageWidth))
                    return "pixelImageWidth: integer expected";
            if (message.pixelImageHeight != null && message.hasOwnProperty("pixelImageHeight"))
                if (!$util.isInteger(message.pixelImageHeight))
                    return "pixelImageHeight: integer expected";
            return null;
        };

        /**
         * Creates a SSL_GeometryCameraCalibration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SSL_GeometryCameraCalibration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SSL_GeometryCameraCalibration} SSL_GeometryCameraCalibration
         */
        SSL_GeometryCameraCalibration.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SSL_GeometryCameraCalibration)
                return object;
            let message = new $root.proto.SSL_GeometryCameraCalibration();
            if (object.cameraId != null)
                message.cameraId = object.cameraId >>> 0;
            if (object.focalLength != null)
                message.focalLength = Number(object.focalLength);
            if (object.principalPointX != null)
                message.principalPointX = Number(object.principalPointX);
            if (object.principalPointY != null)
                message.principalPointY = Number(object.principalPointY);
            if (object.distortion != null)
                message.distortion = Number(object.distortion);
            if (object.q0 != null)
                message.q0 = Number(object.q0);
            if (object.q1 != null)
                message.q1 = Number(object.q1);
            if (object.q2 != null)
                message.q2 = Number(object.q2);
            if (object.q3 != null)
                message.q3 = Number(object.q3);
            if (object.tx != null)
                message.tx = Number(object.tx);
            if (object.ty != null)
                message.ty = Number(object.ty);
            if (object.tz != null)
                message.tz = Number(object.tz);
            if (object.derivedCameraWorldTx != null)
                message.derivedCameraWorldTx = Number(object.derivedCameraWorldTx);
            if (object.derivedCameraWorldTy != null)
                message.derivedCameraWorldTy = Number(object.derivedCameraWorldTy);
            if (object.derivedCameraWorldTz != null)
                message.derivedCameraWorldTz = Number(object.derivedCameraWorldTz);
            if (object.pixelImageWidth != null)
                message.pixelImageWidth = object.pixelImageWidth >>> 0;
            if (object.pixelImageHeight != null)
                message.pixelImageHeight = object.pixelImageHeight >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a SSL_GeometryCameraCalibration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SSL_GeometryCameraCalibration
         * @static
         * @param {proto.SSL_GeometryCameraCalibration} message SSL_GeometryCameraCalibration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SSL_GeometryCameraCalibration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.cameraId = 0;
                object.focalLength = 0;
                object.principalPointX = 0;
                object.principalPointY = 0;
                object.distortion = 0;
                object.q0 = 0;
                object.q1 = 0;
                object.q2 = 0;
                object.q3 = 0;
                object.tx = 0;
                object.ty = 0;
                object.tz = 0;
                object.derivedCameraWorldTx = 0;
                object.derivedCameraWorldTy = 0;
                object.derivedCameraWorldTz = 0;
                object.pixelImageWidth = 0;
                object.pixelImageHeight = 0;
            }
            if (message.cameraId != null && message.hasOwnProperty("cameraId"))
                object.cameraId = message.cameraId;
            if (message.focalLength != null && message.hasOwnProperty("focalLength"))
                object.focalLength = options.json && !isFinite(message.focalLength) ? String(message.focalLength) : message.focalLength;
            if (message.principalPointX != null && message.hasOwnProperty("principalPointX"))
                object.principalPointX = options.json && !isFinite(message.principalPointX) ? String(message.principalPointX) : message.principalPointX;
            if (message.principalPointY != null && message.hasOwnProperty("principalPointY"))
                object.principalPointY = options.json && !isFinite(message.principalPointY) ? String(message.principalPointY) : message.principalPointY;
            if (message.distortion != null && message.hasOwnProperty("distortion"))
                object.distortion = options.json && !isFinite(message.distortion) ? String(message.distortion) : message.distortion;
            if (message.q0 != null && message.hasOwnProperty("q0"))
                object.q0 = options.json && !isFinite(message.q0) ? String(message.q0) : message.q0;
            if (message.q1 != null && message.hasOwnProperty("q1"))
                object.q1 = options.json && !isFinite(message.q1) ? String(message.q1) : message.q1;
            if (message.q2 != null && message.hasOwnProperty("q2"))
                object.q2 = options.json && !isFinite(message.q2) ? String(message.q2) : message.q2;
            if (message.q3 != null && message.hasOwnProperty("q3"))
                object.q3 = options.json && !isFinite(message.q3) ? String(message.q3) : message.q3;
            if (message.tx != null && message.hasOwnProperty("tx"))
                object.tx = options.json && !isFinite(message.tx) ? String(message.tx) : message.tx;
            if (message.ty != null && message.hasOwnProperty("ty"))
                object.ty = options.json && !isFinite(message.ty) ? String(message.ty) : message.ty;
            if (message.tz != null && message.hasOwnProperty("tz"))
                object.tz = options.json && !isFinite(message.tz) ? String(message.tz) : message.tz;
            if (message.derivedCameraWorldTx != null && message.hasOwnProperty("derivedCameraWorldTx"))
                object.derivedCameraWorldTx = options.json && !isFinite(message.derivedCameraWorldTx) ? String(message.derivedCameraWorldTx) : message.derivedCameraWorldTx;
            if (message.derivedCameraWorldTy != null && message.hasOwnProperty("derivedCameraWorldTy"))
                object.derivedCameraWorldTy = options.json && !isFinite(message.derivedCameraWorldTy) ? String(message.derivedCameraWorldTy) : message.derivedCameraWorldTy;
            if (message.derivedCameraWorldTz != null && message.hasOwnProperty("derivedCameraWorldTz"))
                object.derivedCameraWorldTz = options.json && !isFinite(message.derivedCameraWorldTz) ? String(message.derivedCameraWorldTz) : message.derivedCameraWorldTz;
            if (message.pixelImageWidth != null && message.hasOwnProperty("pixelImageWidth"))
                object.pixelImageWidth = message.pixelImageWidth;
            if (message.pixelImageHeight != null && message.hasOwnProperty("pixelImageHeight"))
                object.pixelImageHeight = message.pixelImageHeight;
            return object;
        };

        /**
         * Converts this SSL_GeometryCameraCalibration to JSON.
         * @function toJSON
         * @memberof proto.SSL_GeometryCameraCalibration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SSL_GeometryCameraCalibration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SSL_GeometryCameraCalibration
         * @function getTypeUrl
         * @memberof proto.SSL_GeometryCameraCalibration
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SSL_GeometryCameraCalibration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SSL_GeometryCameraCalibration";
        };

        return SSL_GeometryCameraCalibration;
    })();

    proto.SSL_GeometryData = (function() {

        /**
         * Properties of a SSL_GeometryData.
         * @memberof proto
         * @interface ISSL_GeometryData
         * @property {proto.ISSL_GeometryFieldSize} field SSL_GeometryData field
         * @property {Array.<proto.ISSL_GeometryCameraCalibration>|null} [calib] SSL_GeometryData calib
         */

        /**
         * Constructs a new SSL_GeometryData.
         * @memberof proto
         * @classdesc Represents a SSL_GeometryData.
         * @implements ISSL_GeometryData
         * @constructor
         * @param {proto.ISSL_GeometryData=} [properties] Properties to set
         */
        function SSL_GeometryData(properties) {
            this.calib = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SSL_GeometryData field.
         * @member {proto.ISSL_GeometryFieldSize} field
         * @memberof proto.SSL_GeometryData
         * @instance
         */
        SSL_GeometryData.prototype.field = null;

        /**
         * SSL_GeometryData calib.
         * @member {Array.<proto.ISSL_GeometryCameraCalibration>} calib
         * @memberof proto.SSL_GeometryData
         * @instance
         */
        SSL_GeometryData.prototype.calib = $util.emptyArray;

        /**
         * Creates a new SSL_GeometryData instance using the specified properties.
         * @function create
         * @memberof proto.SSL_GeometryData
         * @static
         * @param {proto.ISSL_GeometryData=} [properties] Properties to set
         * @returns {proto.SSL_GeometryData} SSL_GeometryData instance
         */
        SSL_GeometryData.create = function create(properties) {
            return new SSL_GeometryData(properties);
        };

        /**
         * Encodes the specified SSL_GeometryData message. Does not implicitly {@link proto.SSL_GeometryData.verify|verify} messages.
         * @function encode
         * @memberof proto.SSL_GeometryData
         * @static
         * @param {proto.ISSL_GeometryData} message SSL_GeometryData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_GeometryData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.proto.SSL_GeometryFieldSize.encode(message.field, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.calib != null && message.calib.length)
                for (let i = 0; i < message.calib.length; ++i)
                    $root.proto.SSL_GeometryCameraCalibration.encode(message.calib[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SSL_GeometryData message, length delimited. Does not implicitly {@link proto.SSL_GeometryData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SSL_GeometryData
         * @static
         * @param {proto.ISSL_GeometryData} message SSL_GeometryData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_GeometryData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SSL_GeometryData message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SSL_GeometryData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SSL_GeometryData} SSL_GeometryData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_GeometryData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SSL_GeometryData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.field = $root.proto.SSL_GeometryFieldSize.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        if (!(message.calib && message.calib.length))
                            message.calib = [];
                        message.calib.push($root.proto.SSL_GeometryCameraCalibration.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("field"))
                throw $util.ProtocolError("missing required 'field'", { instance: message });
            return message;
        };

        /**
         * Decodes a SSL_GeometryData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SSL_GeometryData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SSL_GeometryData} SSL_GeometryData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_GeometryData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SSL_GeometryData message.
         * @function verify
         * @memberof proto.SSL_GeometryData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SSL_GeometryData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                let error = $root.proto.SSL_GeometryFieldSize.verify(message.field);
                if (error)
                    return "field." + error;
            }
            if (message.calib != null && message.hasOwnProperty("calib")) {
                if (!Array.isArray(message.calib))
                    return "calib: array expected";
                for (let i = 0; i < message.calib.length; ++i) {
                    let error = $root.proto.SSL_GeometryCameraCalibration.verify(message.calib[i]);
                    if (error)
                        return "calib." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SSL_GeometryData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SSL_GeometryData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SSL_GeometryData} SSL_GeometryData
         */
        SSL_GeometryData.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SSL_GeometryData)
                return object;
            let message = new $root.proto.SSL_GeometryData();
            if (object.field != null) {
                if (typeof object.field !== "object")
                    throw TypeError(".proto.SSL_GeometryData.field: object expected");
                message.field = $root.proto.SSL_GeometryFieldSize.fromObject(object.field);
            }
            if (object.calib) {
                if (!Array.isArray(object.calib))
                    throw TypeError(".proto.SSL_GeometryData.calib: array expected");
                message.calib = [];
                for (let i = 0; i < object.calib.length; ++i) {
                    if (typeof object.calib[i] !== "object")
                        throw TypeError(".proto.SSL_GeometryData.calib: object expected");
                    message.calib[i] = $root.proto.SSL_GeometryCameraCalibration.fromObject(object.calib[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SSL_GeometryData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SSL_GeometryData
         * @static
         * @param {proto.SSL_GeometryData} message SSL_GeometryData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SSL_GeometryData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.calib = [];
            if (options.defaults)
                object.field = null;
            if (message.field != null && message.hasOwnProperty("field"))
                object.field = $root.proto.SSL_GeometryFieldSize.toObject(message.field, options);
            if (message.calib && message.calib.length) {
                object.calib = [];
                for (let j = 0; j < message.calib.length; ++j)
                    object.calib[j] = $root.proto.SSL_GeometryCameraCalibration.toObject(message.calib[j], options);
            }
            return object;
        };

        /**
         * Converts this SSL_GeometryData to JSON.
         * @function toJSON
         * @memberof proto.SSL_GeometryData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SSL_GeometryData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SSL_GeometryData
         * @function getTypeUrl
         * @memberof proto.SSL_GeometryData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SSL_GeometryData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SSL_GeometryData";
        };

        return SSL_GeometryData;
    })();

    /**
     * SSL_FieldShapeType enum.
     * @name proto.SSL_FieldShapeType
     * @enum {number}
     * @property {number} Undefined=0 Undefined value
     * @property {number} CenterCircle=1 CenterCircle value
     * @property {number} TopTouchLine=2 TopTouchLine value
     * @property {number} BottomTouchLine=3 BottomTouchLine value
     * @property {number} LeftGoalLine=4 LeftGoalLine value
     * @property {number} RightGoalLine=5 RightGoalLine value
     * @property {number} HalfwayLine=6 HalfwayLine value
     * @property {number} CenterLine=7 CenterLine value
     * @property {number} LeftPenaltyStretch=8 LeftPenaltyStretch value
     * @property {number} RightPenaltyStretch=9 RightPenaltyStretch value
     * @property {number} LeftFieldLeftPenaltyStretch=10 LeftFieldLeftPenaltyStretch value
     * @property {number} LeftFieldRightPenaltyStretch=11 LeftFieldRightPenaltyStretch value
     * @property {number} RightFieldLeftPenaltyStretch=12 RightFieldLeftPenaltyStretch value
     * @property {number} RightFieldRightPenaltyStretch=13 RightFieldRightPenaltyStretch value
     */
    proto.SSL_FieldShapeType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Undefined"] = 0;
        values[valuesById[1] = "CenterCircle"] = 1;
        values[valuesById[2] = "TopTouchLine"] = 2;
        values[valuesById[3] = "BottomTouchLine"] = 3;
        values[valuesById[4] = "LeftGoalLine"] = 4;
        values[valuesById[5] = "RightGoalLine"] = 5;
        values[valuesById[6] = "HalfwayLine"] = 6;
        values[valuesById[7] = "CenterLine"] = 7;
        values[valuesById[8] = "LeftPenaltyStretch"] = 8;
        values[valuesById[9] = "RightPenaltyStretch"] = 9;
        values[valuesById[10] = "LeftFieldLeftPenaltyStretch"] = 10;
        values[valuesById[11] = "LeftFieldRightPenaltyStretch"] = 11;
        values[valuesById[12] = "RightFieldLeftPenaltyStretch"] = 12;
        values[valuesById[13] = "RightFieldRightPenaltyStretch"] = 13;
        return values;
    })();

    proto.Vector2f = (function() {

        /**
         * Properties of a Vector2f.
         * @memberof proto
         * @interface IVector2f
         * @property {number|null} [x] Vector2f x
         * @property {number|null} [y] Vector2f y
         */

        /**
         * Constructs a new Vector2f.
         * @memberof proto
         * @classdesc Represents a Vector2f.
         * @implements IVector2f
         * @constructor
         * @param {proto.IVector2f=} [properties] Properties to set
         */
        function Vector2f(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vector2f x.
         * @member {number} x
         * @memberof proto.Vector2f
         * @instance
         */
        Vector2f.prototype.x = 0;

        /**
         * Vector2f y.
         * @member {number} y
         * @memberof proto.Vector2f
         * @instance
         */
        Vector2f.prototype.y = 0;

        /**
         * Creates a new Vector2f instance using the specified properties.
         * @function create
         * @memberof proto.Vector2f
         * @static
         * @param {proto.IVector2f=} [properties] Properties to set
         * @returns {proto.Vector2f} Vector2f instance
         */
        Vector2f.create = function create(properties) {
            return new Vector2f(properties);
        };

        /**
         * Encodes the specified Vector2f message. Does not implicitly {@link proto.Vector2f.verify|verify} messages.
         * @function encode
         * @memberof proto.Vector2f
         * @static
         * @param {proto.IVector2f} message Vector2f message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vector2f.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            return writer;
        };

        /**
         * Encodes the specified Vector2f message, length delimited. Does not implicitly {@link proto.Vector2f.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Vector2f
         * @static
         * @param {proto.IVector2f} message Vector2f message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vector2f.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vector2f message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Vector2f
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Vector2f} Vector2f
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vector2f.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Vector2f();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Vector2f message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Vector2f
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Vector2f} Vector2f
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vector2f.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vector2f message.
         * @function verify
         * @memberof proto.Vector2f
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vector2f.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };

        /**
         * Creates a Vector2f message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Vector2f
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Vector2f} Vector2f
         */
        Vector2f.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Vector2f)
                return object;
            let message = new $root.proto.Vector2f();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };

        /**
         * Creates a plain object from a Vector2f message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Vector2f
         * @static
         * @param {proto.Vector2f} message Vector2f
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vector2f.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };

        /**
         * Converts this Vector2f to JSON.
         * @function toJSON
         * @memberof proto.Vector2f
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vector2f.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Vector2f
         * @function getTypeUrl
         * @memberof proto.Vector2f
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Vector2f.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Vector2f";
        };

        return Vector2f;
    })();

    proto.SSL_Referee = (function() {

        /**
         * Properties of a SSL_Referee.
         * @memberof proto
         * @interface ISSL_Referee
         * @property {number|Long} packetTimestamp SSL_Referee packetTimestamp
         * @property {proto.SSL_Referee.Stage} stage SSL_Referee stage
         * @property {number|null} [stageTimeLeft] SSL_Referee stageTimeLeft
         * @property {proto.SSL_Referee.Command} command SSL_Referee command
         * @property {number} commandCounter SSL_Referee commandCounter
         * @property {number|Long} commandTimestamp SSL_Referee commandTimestamp
         * @property {proto.SSL_Referee.ITeamInfo} yellow SSL_Referee yellow
         * @property {proto.SSL_Referee.ITeamInfo} blue SSL_Referee blue
         * @property {proto.SSL_Referee.IPoint|null} [designatedPosition] SSL_Referee designatedPosition
         * @property {boolean|null} [blueTeamOnPositiveHalf] SSL_Referee blueTeamOnPositiveHalf
         * @property {proto.SSL_Referee.Command|null} [nextCommand] SSL_Referee nextCommand
         * @property {Array.<proto.IGameEvent>|null} [gameEvents] SSL_Referee gameEvents
         * @property {Array.<proto.IGameEventProposalGroup>|null} [gameEventProposals] SSL_Referee gameEventProposals
         * @property {number|null} [currentActionTimeRemaining] SSL_Referee currentActionTimeRemaining
         */

        /**
         * Constructs a new SSL_Referee.
         * @memberof proto
         * @classdesc Represents a SSL_Referee.
         * @implements ISSL_Referee
         * @constructor
         * @param {proto.ISSL_Referee=} [properties] Properties to set
         */
        function SSL_Referee(properties) {
            this.gameEvents = [];
            this.gameEventProposals = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SSL_Referee packetTimestamp.
         * @member {number|Long} packetTimestamp
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.packetTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SSL_Referee stage.
         * @member {proto.SSL_Referee.Stage} stage
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.stage = 0;

        /**
         * SSL_Referee stageTimeLeft.
         * @member {number} stageTimeLeft
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.stageTimeLeft = 0;

        /**
         * SSL_Referee command.
         * @member {proto.SSL_Referee.Command} command
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.command = 0;

        /**
         * SSL_Referee commandCounter.
         * @member {number} commandCounter
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.commandCounter = 0;

        /**
         * SSL_Referee commandTimestamp.
         * @member {number|Long} commandTimestamp
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.commandTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SSL_Referee yellow.
         * @member {proto.SSL_Referee.ITeamInfo} yellow
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.yellow = null;

        /**
         * SSL_Referee blue.
         * @member {proto.SSL_Referee.ITeamInfo} blue
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.blue = null;

        /**
         * SSL_Referee designatedPosition.
         * @member {proto.SSL_Referee.IPoint|null|undefined} designatedPosition
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.designatedPosition = null;

        /**
         * SSL_Referee blueTeamOnPositiveHalf.
         * @member {boolean} blueTeamOnPositiveHalf
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.blueTeamOnPositiveHalf = false;

        /**
         * SSL_Referee nextCommand.
         * @member {proto.SSL_Referee.Command} nextCommand
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.nextCommand = 0;

        /**
         * SSL_Referee gameEvents.
         * @member {Array.<proto.IGameEvent>} gameEvents
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.gameEvents = $util.emptyArray;

        /**
         * SSL_Referee gameEventProposals.
         * @member {Array.<proto.IGameEventProposalGroup>} gameEventProposals
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.gameEventProposals = $util.emptyArray;

        /**
         * SSL_Referee currentActionTimeRemaining.
         * @member {number} currentActionTimeRemaining
         * @memberof proto.SSL_Referee
         * @instance
         */
        SSL_Referee.prototype.currentActionTimeRemaining = 0;

        /**
         * Creates a new SSL_Referee instance using the specified properties.
         * @function create
         * @memberof proto.SSL_Referee
         * @static
         * @param {proto.ISSL_Referee=} [properties] Properties to set
         * @returns {proto.SSL_Referee} SSL_Referee instance
         */
        SSL_Referee.create = function create(properties) {
            return new SSL_Referee(properties);
        };

        /**
         * Encodes the specified SSL_Referee message. Does not implicitly {@link proto.SSL_Referee.verify|verify} messages.
         * @function encode
         * @memberof proto.SSL_Referee
         * @static
         * @param {proto.ISSL_Referee} message SSL_Referee message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_Referee.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.packetTimestamp);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.stage);
            if (message.stageTimeLeft != null && Object.hasOwnProperty.call(message, "stageTimeLeft"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.stageTimeLeft);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.command);
            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.commandCounter);
            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.commandTimestamp);
            $root.proto.SSL_Referee.TeamInfo.encode(message.yellow, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            $root.proto.SSL_Referee.TeamInfo.encode(message.blue, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.designatedPosition != null && Object.hasOwnProperty.call(message, "designatedPosition"))
                $root.proto.SSL_Referee.Point.encode(message.designatedPosition, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.blueTeamOnPositiveHalf != null && Object.hasOwnProperty.call(message, "blueTeamOnPositiveHalf"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.blueTeamOnPositiveHalf);
            if (message.nextCommand != null && Object.hasOwnProperty.call(message, "nextCommand"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.nextCommand);
            if (message.currentActionTimeRemaining != null && Object.hasOwnProperty.call(message, "currentActionTimeRemaining"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.currentActionTimeRemaining);
            if (message.gameEvents != null && message.gameEvents.length)
                for (let i = 0; i < message.gameEvents.length; ++i)
                    $root.proto.GameEvent.encode(message.gameEvents[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.gameEventProposals != null && message.gameEventProposals.length)
                for (let i = 0; i < message.gameEventProposals.length; ++i)
                    $root.proto.GameEventProposalGroup.encode(message.gameEventProposals[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SSL_Referee message, length delimited. Does not implicitly {@link proto.SSL_Referee.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SSL_Referee
         * @static
         * @param {proto.ISSL_Referee} message SSL_Referee message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_Referee.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SSL_Referee message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SSL_Referee
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SSL_Referee} SSL_Referee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_Referee.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SSL_Referee();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.packetTimestamp = reader.uint64();
                        break;
                    }
                case 2: {
                        message.stage = reader.int32();
                        break;
                    }
                case 3: {
                        message.stageTimeLeft = reader.sint32();
                        break;
                    }
                case 4: {
                        message.command = reader.int32();
                        break;
                    }
                case 5: {
                        message.commandCounter = reader.uint32();
                        break;
                    }
                case 6: {
                        message.commandTimestamp = reader.uint64();
                        break;
                    }
                case 7: {
                        message.yellow = $root.proto.SSL_Referee.TeamInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.blue = $root.proto.SSL_Referee.TeamInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.designatedPosition = $root.proto.SSL_Referee.Point.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.blueTeamOnPositiveHalf = reader.bool();
                        break;
                    }
                case 12: {
                        message.nextCommand = reader.int32();
                        break;
                    }
                case 16: {
                        if (!(message.gameEvents && message.gameEvents.length))
                            message.gameEvents = [];
                        message.gameEvents.push($root.proto.GameEvent.decode(reader, reader.uint32()));
                        break;
                    }
                case 17: {
                        if (!(message.gameEventProposals && message.gameEventProposals.length))
                            message.gameEventProposals = [];
                        message.gameEventProposals.push($root.proto.GameEventProposalGroup.decode(reader, reader.uint32()));
                        break;
                    }
                case 15: {
                        message.currentActionTimeRemaining = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("packetTimestamp"))
                throw $util.ProtocolError("missing required 'packetTimestamp'", { instance: message });
            if (!message.hasOwnProperty("stage"))
                throw $util.ProtocolError("missing required 'stage'", { instance: message });
            if (!message.hasOwnProperty("command"))
                throw $util.ProtocolError("missing required 'command'", { instance: message });
            if (!message.hasOwnProperty("commandCounter"))
                throw $util.ProtocolError("missing required 'commandCounter'", { instance: message });
            if (!message.hasOwnProperty("commandTimestamp"))
                throw $util.ProtocolError("missing required 'commandTimestamp'", { instance: message });
            if (!message.hasOwnProperty("yellow"))
                throw $util.ProtocolError("missing required 'yellow'", { instance: message });
            if (!message.hasOwnProperty("blue"))
                throw $util.ProtocolError("missing required 'blue'", { instance: message });
            return message;
        };

        /**
         * Decodes a SSL_Referee message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SSL_Referee
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SSL_Referee} SSL_Referee
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_Referee.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SSL_Referee message.
         * @function verify
         * @memberof proto.SSL_Referee
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SSL_Referee.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.packetTimestamp) && !(message.packetTimestamp && $util.isInteger(message.packetTimestamp.low) && $util.isInteger(message.packetTimestamp.high)))
                return "packetTimestamp: integer|Long expected";
            switch (message.stage) {
            default:
                return "stage: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
                break;
            }
            if (message.stageTimeLeft != null && message.hasOwnProperty("stageTimeLeft"))
                if (!$util.isInteger(message.stageTimeLeft))
                    return "stageTimeLeft: integer expected";
            switch (message.command) {
            default:
                return "command: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 16:
            case 17:
                break;
            }
            if (!$util.isInteger(message.commandCounter))
                return "commandCounter: integer expected";
            if (!$util.isInteger(message.commandTimestamp) && !(message.commandTimestamp && $util.isInteger(message.commandTimestamp.low) && $util.isInteger(message.commandTimestamp.high)))
                return "commandTimestamp: integer|Long expected";
            {
                let error = $root.proto.SSL_Referee.TeamInfo.verify(message.yellow);
                if (error)
                    return "yellow." + error;
            }
            {
                let error = $root.proto.SSL_Referee.TeamInfo.verify(message.blue);
                if (error)
                    return "blue." + error;
            }
            if (message.designatedPosition != null && message.hasOwnProperty("designatedPosition")) {
                let error = $root.proto.SSL_Referee.Point.verify(message.designatedPosition);
                if (error)
                    return "designatedPosition." + error;
            }
            if (message.blueTeamOnPositiveHalf != null && message.hasOwnProperty("blueTeamOnPositiveHalf"))
                if (typeof message.blueTeamOnPositiveHalf !== "boolean")
                    return "blueTeamOnPositiveHalf: boolean expected";
            if (message.nextCommand != null && message.hasOwnProperty("nextCommand"))
                switch (message.nextCommand) {
                default:
                    return "nextCommand: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 16:
                case 17:
                    break;
                }
            if (message.gameEvents != null && message.hasOwnProperty("gameEvents")) {
                if (!Array.isArray(message.gameEvents))
                    return "gameEvents: array expected";
                for (let i = 0; i < message.gameEvents.length; ++i) {
                    let error = $root.proto.GameEvent.verify(message.gameEvents[i]);
                    if (error)
                        return "gameEvents." + error;
                }
            }
            if (message.gameEventProposals != null && message.hasOwnProperty("gameEventProposals")) {
                if (!Array.isArray(message.gameEventProposals))
                    return "gameEventProposals: array expected";
                for (let i = 0; i < message.gameEventProposals.length; ++i) {
                    let error = $root.proto.GameEventProposalGroup.verify(message.gameEventProposals[i]);
                    if (error)
                        return "gameEventProposals." + error;
                }
            }
            if (message.currentActionTimeRemaining != null && message.hasOwnProperty("currentActionTimeRemaining"))
                if (!$util.isInteger(message.currentActionTimeRemaining))
                    return "currentActionTimeRemaining: integer expected";
            return null;
        };

        /**
         * Creates a SSL_Referee message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SSL_Referee
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SSL_Referee} SSL_Referee
         */
        SSL_Referee.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SSL_Referee)
                return object;
            let message = new $root.proto.SSL_Referee();
            if (object.packetTimestamp != null)
                if ($util.Long)
                    (message.packetTimestamp = $util.Long.fromValue(object.packetTimestamp)).unsigned = true;
                else if (typeof object.packetTimestamp === "string")
                    message.packetTimestamp = parseInt(object.packetTimestamp, 10);
                else if (typeof object.packetTimestamp === "number")
                    message.packetTimestamp = object.packetTimestamp;
                else if (typeof object.packetTimestamp === "object")
                    message.packetTimestamp = new $util.LongBits(object.packetTimestamp.low >>> 0, object.packetTimestamp.high >>> 0).toNumber(true);
            switch (object.stage) {
            default:
                if (typeof object.stage === "number") {
                    message.stage = object.stage;
                    break;
                }
                break;
            case "NORMAL_FIRST_HALF_PRE":
            case 0:
                message.stage = 0;
                break;
            case "NORMAL_FIRST_HALF":
            case 1:
                message.stage = 1;
                break;
            case "NORMAL_HALF_TIME":
            case 2:
                message.stage = 2;
                break;
            case "NORMAL_SECOND_HALF_PRE":
            case 3:
                message.stage = 3;
                break;
            case "NORMAL_SECOND_HALF":
            case 4:
                message.stage = 4;
                break;
            case "EXTRA_TIME_BREAK":
            case 5:
                message.stage = 5;
                break;
            case "EXTRA_FIRST_HALF_PRE":
            case 6:
                message.stage = 6;
                break;
            case "EXTRA_FIRST_HALF":
            case 7:
                message.stage = 7;
                break;
            case "EXTRA_HALF_TIME":
            case 8:
                message.stage = 8;
                break;
            case "EXTRA_SECOND_HALF_PRE":
            case 9:
                message.stage = 9;
                break;
            case "EXTRA_SECOND_HALF":
            case 10:
                message.stage = 10;
                break;
            case "PENALTY_SHOOTOUT_BREAK":
            case 11:
                message.stage = 11;
                break;
            case "PENALTY_SHOOTOUT":
            case 12:
                message.stage = 12;
                break;
            case "POST_GAME":
            case 13:
                message.stage = 13;
                break;
            }
            if (object.stageTimeLeft != null)
                message.stageTimeLeft = object.stageTimeLeft | 0;
            switch (object.command) {
            default:
                if (typeof object.command === "number") {
                    message.command = object.command;
                    break;
                }
                break;
            case "HALT":
            case 0:
                message.command = 0;
                break;
            case "STOP":
            case 1:
                message.command = 1;
                break;
            case "NORMAL_START":
            case 2:
                message.command = 2;
                break;
            case "FORCE_START":
            case 3:
                message.command = 3;
                break;
            case "PREPARE_KICKOFF_YELLOW":
            case 4:
                message.command = 4;
                break;
            case "PREPARE_KICKOFF_BLUE":
            case 5:
                message.command = 5;
                break;
            case "PREPARE_PENALTY_YELLOW":
            case 6:
                message.command = 6;
                break;
            case "PREPARE_PENALTY_BLUE":
            case 7:
                message.command = 7;
                break;
            case "DIRECT_FREE_YELLOW":
            case 8:
                message.command = 8;
                break;
            case "DIRECT_FREE_BLUE":
            case 9:
                message.command = 9;
                break;
            case "INDIRECT_FREE_YELLOW":
            case 10:
                message.command = 10;
                break;
            case "INDIRECT_FREE_BLUE":
            case 11:
                message.command = 11;
                break;
            case "TIMEOUT_YELLOW":
            case 12:
                message.command = 12;
                break;
            case "TIMEOUT_BLUE":
            case 13:
                message.command = 13;
                break;
            case "BALL_PLACEMENT_YELLOW":
            case 16:
                message.command = 16;
                break;
            case "BALL_PLACEMENT_BLUE":
            case 17:
                message.command = 17;
                break;
            }
            if (object.commandCounter != null)
                message.commandCounter = object.commandCounter >>> 0;
            if (object.commandTimestamp != null)
                if ($util.Long)
                    (message.commandTimestamp = $util.Long.fromValue(object.commandTimestamp)).unsigned = true;
                else if (typeof object.commandTimestamp === "string")
                    message.commandTimestamp = parseInt(object.commandTimestamp, 10);
                else if (typeof object.commandTimestamp === "number")
                    message.commandTimestamp = object.commandTimestamp;
                else if (typeof object.commandTimestamp === "object")
                    message.commandTimestamp = new $util.LongBits(object.commandTimestamp.low >>> 0, object.commandTimestamp.high >>> 0).toNumber(true);
            if (object.yellow != null) {
                if (typeof object.yellow !== "object")
                    throw TypeError(".proto.SSL_Referee.yellow: object expected");
                message.yellow = $root.proto.SSL_Referee.TeamInfo.fromObject(object.yellow);
            }
            if (object.blue != null) {
                if (typeof object.blue !== "object")
                    throw TypeError(".proto.SSL_Referee.blue: object expected");
                message.blue = $root.proto.SSL_Referee.TeamInfo.fromObject(object.blue);
            }
            if (object.designatedPosition != null) {
                if (typeof object.designatedPosition !== "object")
                    throw TypeError(".proto.SSL_Referee.designatedPosition: object expected");
                message.designatedPosition = $root.proto.SSL_Referee.Point.fromObject(object.designatedPosition);
            }
            if (object.blueTeamOnPositiveHalf != null)
                message.blueTeamOnPositiveHalf = Boolean(object.blueTeamOnPositiveHalf);
            switch (object.nextCommand) {
            default:
                if (typeof object.nextCommand === "number") {
                    message.nextCommand = object.nextCommand;
                    break;
                }
                break;
            case "HALT":
            case 0:
                message.nextCommand = 0;
                break;
            case "STOP":
            case 1:
                message.nextCommand = 1;
                break;
            case "NORMAL_START":
            case 2:
                message.nextCommand = 2;
                break;
            case "FORCE_START":
            case 3:
                message.nextCommand = 3;
                break;
            case "PREPARE_KICKOFF_YELLOW":
            case 4:
                message.nextCommand = 4;
                break;
            case "PREPARE_KICKOFF_BLUE":
            case 5:
                message.nextCommand = 5;
                break;
            case "PREPARE_PENALTY_YELLOW":
            case 6:
                message.nextCommand = 6;
                break;
            case "PREPARE_PENALTY_BLUE":
            case 7:
                message.nextCommand = 7;
                break;
            case "DIRECT_FREE_YELLOW":
            case 8:
                message.nextCommand = 8;
                break;
            case "DIRECT_FREE_BLUE":
            case 9:
                message.nextCommand = 9;
                break;
            case "INDIRECT_FREE_YELLOW":
            case 10:
                message.nextCommand = 10;
                break;
            case "INDIRECT_FREE_BLUE":
            case 11:
                message.nextCommand = 11;
                break;
            case "TIMEOUT_YELLOW":
            case 12:
                message.nextCommand = 12;
                break;
            case "TIMEOUT_BLUE":
            case 13:
                message.nextCommand = 13;
                break;
            case "BALL_PLACEMENT_YELLOW":
            case 16:
                message.nextCommand = 16;
                break;
            case "BALL_PLACEMENT_BLUE":
            case 17:
                message.nextCommand = 17;
                break;
            }
            if (object.gameEvents) {
                if (!Array.isArray(object.gameEvents))
                    throw TypeError(".proto.SSL_Referee.gameEvents: array expected");
                message.gameEvents = [];
                for (let i = 0; i < object.gameEvents.length; ++i) {
                    if (typeof object.gameEvents[i] !== "object")
                        throw TypeError(".proto.SSL_Referee.gameEvents: object expected");
                    message.gameEvents[i] = $root.proto.GameEvent.fromObject(object.gameEvents[i]);
                }
            }
            if (object.gameEventProposals) {
                if (!Array.isArray(object.gameEventProposals))
                    throw TypeError(".proto.SSL_Referee.gameEventProposals: array expected");
                message.gameEventProposals = [];
                for (let i = 0; i < object.gameEventProposals.length; ++i) {
                    if (typeof object.gameEventProposals[i] !== "object")
                        throw TypeError(".proto.SSL_Referee.gameEventProposals: object expected");
                    message.gameEventProposals[i] = $root.proto.GameEventProposalGroup.fromObject(object.gameEventProposals[i]);
                }
            }
            if (object.currentActionTimeRemaining != null)
                message.currentActionTimeRemaining = object.currentActionTimeRemaining | 0;
            return message;
        };

        /**
         * Creates a plain object from a SSL_Referee message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SSL_Referee
         * @static
         * @param {proto.SSL_Referee} message SSL_Referee
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SSL_Referee.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.gameEvents = [];
                object.gameEventProposals = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.packetTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.packetTimestamp = options.longs === String ? "0" : 0;
                object.stage = options.enums === String ? "NORMAL_FIRST_HALF_PRE" : 0;
                object.stageTimeLeft = 0;
                object.command = options.enums === String ? "HALT" : 0;
                object.commandCounter = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.commandTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.commandTimestamp = options.longs === String ? "0" : 0;
                object.yellow = null;
                object.blue = null;
                object.designatedPosition = null;
                object.blueTeamOnPositiveHalf = false;
                object.nextCommand = options.enums === String ? "HALT" : 0;
                object.currentActionTimeRemaining = 0;
            }
            if (message.packetTimestamp != null && message.hasOwnProperty("packetTimestamp"))
                if (typeof message.packetTimestamp === "number")
                    object.packetTimestamp = options.longs === String ? String(message.packetTimestamp) : message.packetTimestamp;
                else
                    object.packetTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.packetTimestamp) : options.longs === Number ? new $util.LongBits(message.packetTimestamp.low >>> 0, message.packetTimestamp.high >>> 0).toNumber(true) : message.packetTimestamp;
            if (message.stage != null && message.hasOwnProperty("stage"))
                object.stage = options.enums === String ? $root.proto.SSL_Referee.Stage[message.stage] === undefined ? message.stage : $root.proto.SSL_Referee.Stage[message.stage] : message.stage;
            if (message.stageTimeLeft != null && message.hasOwnProperty("stageTimeLeft"))
                object.stageTimeLeft = message.stageTimeLeft;
            if (message.command != null && message.hasOwnProperty("command"))
                object.command = options.enums === String ? $root.proto.SSL_Referee.Command[message.command] === undefined ? message.command : $root.proto.SSL_Referee.Command[message.command] : message.command;
            if (message.commandCounter != null && message.hasOwnProperty("commandCounter"))
                object.commandCounter = message.commandCounter;
            if (message.commandTimestamp != null && message.hasOwnProperty("commandTimestamp"))
                if (typeof message.commandTimestamp === "number")
                    object.commandTimestamp = options.longs === String ? String(message.commandTimestamp) : message.commandTimestamp;
                else
                    object.commandTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.commandTimestamp) : options.longs === Number ? new $util.LongBits(message.commandTimestamp.low >>> 0, message.commandTimestamp.high >>> 0).toNumber(true) : message.commandTimestamp;
            if (message.yellow != null && message.hasOwnProperty("yellow"))
                object.yellow = $root.proto.SSL_Referee.TeamInfo.toObject(message.yellow, options);
            if (message.blue != null && message.hasOwnProperty("blue"))
                object.blue = $root.proto.SSL_Referee.TeamInfo.toObject(message.blue, options);
            if (message.designatedPosition != null && message.hasOwnProperty("designatedPosition"))
                object.designatedPosition = $root.proto.SSL_Referee.Point.toObject(message.designatedPosition, options);
            if (message.blueTeamOnPositiveHalf != null && message.hasOwnProperty("blueTeamOnPositiveHalf"))
                object.blueTeamOnPositiveHalf = message.blueTeamOnPositiveHalf;
            if (message.nextCommand != null && message.hasOwnProperty("nextCommand"))
                object.nextCommand = options.enums === String ? $root.proto.SSL_Referee.Command[message.nextCommand] === undefined ? message.nextCommand : $root.proto.SSL_Referee.Command[message.nextCommand] : message.nextCommand;
            if (message.currentActionTimeRemaining != null && message.hasOwnProperty("currentActionTimeRemaining"))
                object.currentActionTimeRemaining = message.currentActionTimeRemaining;
            if (message.gameEvents && message.gameEvents.length) {
                object.gameEvents = [];
                for (let j = 0; j < message.gameEvents.length; ++j)
                    object.gameEvents[j] = $root.proto.GameEvent.toObject(message.gameEvents[j], options);
            }
            if (message.gameEventProposals && message.gameEventProposals.length) {
                object.gameEventProposals = [];
                for (let j = 0; j < message.gameEventProposals.length; ++j)
                    object.gameEventProposals[j] = $root.proto.GameEventProposalGroup.toObject(message.gameEventProposals[j], options);
            }
            return object;
        };

        /**
         * Converts this SSL_Referee to JSON.
         * @function toJSON
         * @memberof proto.SSL_Referee
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SSL_Referee.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SSL_Referee
         * @function getTypeUrl
         * @memberof proto.SSL_Referee
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SSL_Referee.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SSL_Referee";
        };

        /**
         * Stage enum.
         * @name proto.SSL_Referee.Stage
         * @enum {number}
         * @property {number} NORMAL_FIRST_HALF_PRE=0 NORMAL_FIRST_HALF_PRE value
         * @property {number} NORMAL_FIRST_HALF=1 NORMAL_FIRST_HALF value
         * @property {number} NORMAL_HALF_TIME=2 NORMAL_HALF_TIME value
         * @property {number} NORMAL_SECOND_HALF_PRE=3 NORMAL_SECOND_HALF_PRE value
         * @property {number} NORMAL_SECOND_HALF=4 NORMAL_SECOND_HALF value
         * @property {number} EXTRA_TIME_BREAK=5 EXTRA_TIME_BREAK value
         * @property {number} EXTRA_FIRST_HALF_PRE=6 EXTRA_FIRST_HALF_PRE value
         * @property {number} EXTRA_FIRST_HALF=7 EXTRA_FIRST_HALF value
         * @property {number} EXTRA_HALF_TIME=8 EXTRA_HALF_TIME value
         * @property {number} EXTRA_SECOND_HALF_PRE=9 EXTRA_SECOND_HALF_PRE value
         * @property {number} EXTRA_SECOND_HALF=10 EXTRA_SECOND_HALF value
         * @property {number} PENALTY_SHOOTOUT_BREAK=11 PENALTY_SHOOTOUT_BREAK value
         * @property {number} PENALTY_SHOOTOUT=12 PENALTY_SHOOTOUT value
         * @property {number} POST_GAME=13 POST_GAME value
         */
        SSL_Referee.Stage = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NORMAL_FIRST_HALF_PRE"] = 0;
            values[valuesById[1] = "NORMAL_FIRST_HALF"] = 1;
            values[valuesById[2] = "NORMAL_HALF_TIME"] = 2;
            values[valuesById[3] = "NORMAL_SECOND_HALF_PRE"] = 3;
            values[valuesById[4] = "NORMAL_SECOND_HALF"] = 4;
            values[valuesById[5] = "EXTRA_TIME_BREAK"] = 5;
            values[valuesById[6] = "EXTRA_FIRST_HALF_PRE"] = 6;
            values[valuesById[7] = "EXTRA_FIRST_HALF"] = 7;
            values[valuesById[8] = "EXTRA_HALF_TIME"] = 8;
            values[valuesById[9] = "EXTRA_SECOND_HALF_PRE"] = 9;
            values[valuesById[10] = "EXTRA_SECOND_HALF"] = 10;
            values[valuesById[11] = "PENALTY_SHOOTOUT_BREAK"] = 11;
            values[valuesById[12] = "PENALTY_SHOOTOUT"] = 12;
            values[valuesById[13] = "POST_GAME"] = 13;
            return values;
        })();

        /**
         * Command enum.
         * @name proto.SSL_Referee.Command
         * @enum {number}
         * @property {number} HALT=0 HALT value
         * @property {number} STOP=1 STOP value
         * @property {number} NORMAL_START=2 NORMAL_START value
         * @property {number} FORCE_START=3 FORCE_START value
         * @property {number} PREPARE_KICKOFF_YELLOW=4 PREPARE_KICKOFF_YELLOW value
         * @property {number} PREPARE_KICKOFF_BLUE=5 PREPARE_KICKOFF_BLUE value
         * @property {number} PREPARE_PENALTY_YELLOW=6 PREPARE_PENALTY_YELLOW value
         * @property {number} PREPARE_PENALTY_BLUE=7 PREPARE_PENALTY_BLUE value
         * @property {number} DIRECT_FREE_YELLOW=8 DIRECT_FREE_YELLOW value
         * @property {number} DIRECT_FREE_BLUE=9 DIRECT_FREE_BLUE value
         * @property {number} INDIRECT_FREE_YELLOW=10 INDIRECT_FREE_YELLOW value
         * @property {number} INDIRECT_FREE_BLUE=11 INDIRECT_FREE_BLUE value
         * @property {number} TIMEOUT_YELLOW=12 TIMEOUT_YELLOW value
         * @property {number} TIMEOUT_BLUE=13 TIMEOUT_BLUE value
         * @property {number} BALL_PLACEMENT_YELLOW=16 BALL_PLACEMENT_YELLOW value
         * @property {number} BALL_PLACEMENT_BLUE=17 BALL_PLACEMENT_BLUE value
         */
        SSL_Referee.Command = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "HALT"] = 0;
            values[valuesById[1] = "STOP"] = 1;
            values[valuesById[2] = "NORMAL_START"] = 2;
            values[valuesById[3] = "FORCE_START"] = 3;
            values[valuesById[4] = "PREPARE_KICKOFF_YELLOW"] = 4;
            values[valuesById[5] = "PREPARE_KICKOFF_BLUE"] = 5;
            values[valuesById[6] = "PREPARE_PENALTY_YELLOW"] = 6;
            values[valuesById[7] = "PREPARE_PENALTY_BLUE"] = 7;
            values[valuesById[8] = "DIRECT_FREE_YELLOW"] = 8;
            values[valuesById[9] = "DIRECT_FREE_BLUE"] = 9;
            values[valuesById[10] = "INDIRECT_FREE_YELLOW"] = 10;
            values[valuesById[11] = "INDIRECT_FREE_BLUE"] = 11;
            values[valuesById[12] = "TIMEOUT_YELLOW"] = 12;
            values[valuesById[13] = "TIMEOUT_BLUE"] = 13;
            values[valuesById[16] = "BALL_PLACEMENT_YELLOW"] = 16;
            values[valuesById[17] = "BALL_PLACEMENT_BLUE"] = 17;
            return values;
        })();

        SSL_Referee.TeamInfo = (function() {

            /**
             * Properties of a TeamInfo.
             * @memberof proto.SSL_Referee
             * @interface ITeamInfo
             * @property {string} name TeamInfo name
             * @property {number} score TeamInfo score
             * @property {number} redCards TeamInfo redCards
             * @property {Array.<number>|null} [yellowCardTimes] TeamInfo yellowCardTimes
             * @property {number} yellowCards TeamInfo yellowCards
             * @property {number} timeouts TeamInfo timeouts
             * @property {number} timeoutTime TeamInfo timeoutTime
             * @property {number} goalkeeper TeamInfo goalkeeper
             * @property {number|null} [foulCounter] TeamInfo foulCounter
             * @property {number|null} [ballPlacementFailures] TeamInfo ballPlacementFailures
             * @property {boolean|null} [canPlaceBall] TeamInfo canPlaceBall
             * @property {number|null} [maxAllowedBots] TeamInfo maxAllowedBots
             * @property {boolean|null} [botSubstitutionIntent] TeamInfo botSubstitutionIntent
             * @property {boolean|null} [ballPlacementFailuresReached] TeamInfo ballPlacementFailuresReached
             */

            /**
             * Constructs a new TeamInfo.
             * @memberof proto.SSL_Referee
             * @classdesc Represents a TeamInfo.
             * @implements ITeamInfo
             * @constructor
             * @param {proto.SSL_Referee.ITeamInfo=} [properties] Properties to set
             */
            function TeamInfo(properties) {
                this.yellowCardTimes = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TeamInfo name.
             * @member {string} name
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.name = "";

            /**
             * TeamInfo score.
             * @member {number} score
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.score = 0;

            /**
             * TeamInfo redCards.
             * @member {number} redCards
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.redCards = 0;

            /**
             * TeamInfo yellowCardTimes.
             * @member {Array.<number>} yellowCardTimes
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.yellowCardTimes = $util.emptyArray;

            /**
             * TeamInfo yellowCards.
             * @member {number} yellowCards
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.yellowCards = 0;

            /**
             * TeamInfo timeouts.
             * @member {number} timeouts
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.timeouts = 0;

            /**
             * TeamInfo timeoutTime.
             * @member {number} timeoutTime
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.timeoutTime = 0;

            /**
             * TeamInfo goalkeeper.
             * @member {number} goalkeeper
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.goalkeeper = 0;

            /**
             * TeamInfo foulCounter.
             * @member {number} foulCounter
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.foulCounter = 0;

            /**
             * TeamInfo ballPlacementFailures.
             * @member {number} ballPlacementFailures
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.ballPlacementFailures = 0;

            /**
             * TeamInfo canPlaceBall.
             * @member {boolean} canPlaceBall
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.canPlaceBall = false;

            /**
             * TeamInfo maxAllowedBots.
             * @member {number} maxAllowedBots
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.maxAllowedBots = 0;

            /**
             * TeamInfo botSubstitutionIntent.
             * @member {boolean} botSubstitutionIntent
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.botSubstitutionIntent = false;

            /**
             * TeamInfo ballPlacementFailuresReached.
             * @member {boolean} ballPlacementFailuresReached
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             */
            TeamInfo.prototype.ballPlacementFailuresReached = false;

            /**
             * Creates a new TeamInfo instance using the specified properties.
             * @function create
             * @memberof proto.SSL_Referee.TeamInfo
             * @static
             * @param {proto.SSL_Referee.ITeamInfo=} [properties] Properties to set
             * @returns {proto.SSL_Referee.TeamInfo} TeamInfo instance
             */
            TeamInfo.create = function create(properties) {
                return new TeamInfo(properties);
            };

            /**
             * Encodes the specified TeamInfo message. Does not implicitly {@link proto.SSL_Referee.TeamInfo.verify|verify} messages.
             * @function encode
             * @memberof proto.SSL_Referee.TeamInfo
             * @static
             * @param {proto.SSL_Referee.ITeamInfo} message TeamInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TeamInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.score);
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.redCards);
                if (message.yellowCardTimes != null && message.yellowCardTimes.length) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork();
                    for (let i = 0; i < message.yellowCardTimes.length; ++i)
                        writer.uint32(message.yellowCardTimes[i]);
                    writer.ldelim();
                }
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.yellowCards);
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.timeouts);
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.timeoutTime);
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.goalkeeper);
                if (message.foulCounter != null && Object.hasOwnProperty.call(message, "foulCounter"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.foulCounter);
                if (message.ballPlacementFailures != null && Object.hasOwnProperty.call(message, "ballPlacementFailures"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.ballPlacementFailures);
                if (message.canPlaceBall != null && Object.hasOwnProperty.call(message, "canPlaceBall"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.canPlaceBall);
                if (message.maxAllowedBots != null && Object.hasOwnProperty.call(message, "maxAllowedBots"))
                    writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.maxAllowedBots);
                if (message.botSubstitutionIntent != null && Object.hasOwnProperty.call(message, "botSubstitutionIntent"))
                    writer.uint32(/* id 14, wireType 0 =*/112).bool(message.botSubstitutionIntent);
                if (message.ballPlacementFailuresReached != null && Object.hasOwnProperty.call(message, "ballPlacementFailuresReached"))
                    writer.uint32(/* id 15, wireType 0 =*/120).bool(message.ballPlacementFailuresReached);
                return writer;
            };

            /**
             * Encodes the specified TeamInfo message, length delimited. Does not implicitly {@link proto.SSL_Referee.TeamInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SSL_Referee.TeamInfo
             * @static
             * @param {proto.SSL_Referee.ITeamInfo} message TeamInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TeamInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TeamInfo message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SSL_Referee.TeamInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SSL_Referee.TeamInfo} TeamInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TeamInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SSL_Referee.TeamInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.score = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.redCards = reader.uint32();
                            break;
                        }
                    case 4: {
                            if (!(message.yellowCardTimes && message.yellowCardTimes.length))
                                message.yellowCardTimes = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.yellowCardTimes.push(reader.uint32());
                            } else
                                message.yellowCardTimes.push(reader.uint32());
                            break;
                        }
                    case 5: {
                            message.yellowCards = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.timeouts = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.timeoutTime = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.goalkeeper = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.foulCounter = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.ballPlacementFailures = reader.uint32();
                            break;
                        }
                    case 12: {
                            message.canPlaceBall = reader.bool();
                            break;
                        }
                    case 13: {
                            message.maxAllowedBots = reader.uint32();
                            break;
                        }
                    case 14: {
                            message.botSubstitutionIntent = reader.bool();
                            break;
                        }
                    case 15: {
                            message.ballPlacementFailuresReached = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("name"))
                    throw $util.ProtocolError("missing required 'name'", { instance: message });
                if (!message.hasOwnProperty("score"))
                    throw $util.ProtocolError("missing required 'score'", { instance: message });
                if (!message.hasOwnProperty("redCards"))
                    throw $util.ProtocolError("missing required 'redCards'", { instance: message });
                if (!message.hasOwnProperty("yellowCards"))
                    throw $util.ProtocolError("missing required 'yellowCards'", { instance: message });
                if (!message.hasOwnProperty("timeouts"))
                    throw $util.ProtocolError("missing required 'timeouts'", { instance: message });
                if (!message.hasOwnProperty("timeoutTime"))
                    throw $util.ProtocolError("missing required 'timeoutTime'", { instance: message });
                if (!message.hasOwnProperty("goalkeeper"))
                    throw $util.ProtocolError("missing required 'goalkeeper'", { instance: message });
                return message;
            };

            /**
             * Decodes a TeamInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SSL_Referee.TeamInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SSL_Referee.TeamInfo} TeamInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TeamInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TeamInfo message.
             * @function verify
             * @memberof proto.SSL_Referee.TeamInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TeamInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (!$util.isString(message.name))
                    return "name: string expected";
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
                if (!$util.isInteger(message.redCards))
                    return "redCards: integer expected";
                if (message.yellowCardTimes != null && message.hasOwnProperty("yellowCardTimes")) {
                    if (!Array.isArray(message.yellowCardTimes))
                        return "yellowCardTimes: array expected";
                    for (let i = 0; i < message.yellowCardTimes.length; ++i)
                        if (!$util.isInteger(message.yellowCardTimes[i]))
                            return "yellowCardTimes: integer[] expected";
                }
                if (!$util.isInteger(message.yellowCards))
                    return "yellowCards: integer expected";
                if (!$util.isInteger(message.timeouts))
                    return "timeouts: integer expected";
                if (!$util.isInteger(message.timeoutTime))
                    return "timeoutTime: integer expected";
                if (!$util.isInteger(message.goalkeeper))
                    return "goalkeeper: integer expected";
                if (message.foulCounter != null && message.hasOwnProperty("foulCounter"))
                    if (!$util.isInteger(message.foulCounter))
                        return "foulCounter: integer expected";
                if (message.ballPlacementFailures != null && message.hasOwnProperty("ballPlacementFailures"))
                    if (!$util.isInteger(message.ballPlacementFailures))
                        return "ballPlacementFailures: integer expected";
                if (message.canPlaceBall != null && message.hasOwnProperty("canPlaceBall"))
                    if (typeof message.canPlaceBall !== "boolean")
                        return "canPlaceBall: boolean expected";
                if (message.maxAllowedBots != null && message.hasOwnProperty("maxAllowedBots"))
                    if (!$util.isInteger(message.maxAllowedBots))
                        return "maxAllowedBots: integer expected";
                if (message.botSubstitutionIntent != null && message.hasOwnProperty("botSubstitutionIntent"))
                    if (typeof message.botSubstitutionIntent !== "boolean")
                        return "botSubstitutionIntent: boolean expected";
                if (message.ballPlacementFailuresReached != null && message.hasOwnProperty("ballPlacementFailuresReached"))
                    if (typeof message.ballPlacementFailuresReached !== "boolean")
                        return "ballPlacementFailuresReached: boolean expected";
                return null;
            };

            /**
             * Creates a TeamInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SSL_Referee.TeamInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SSL_Referee.TeamInfo} TeamInfo
             */
            TeamInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SSL_Referee.TeamInfo)
                    return object;
                let message = new $root.proto.SSL_Referee.TeamInfo();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.score != null)
                    message.score = object.score >>> 0;
                if (object.redCards != null)
                    message.redCards = object.redCards >>> 0;
                if (object.yellowCardTimes) {
                    if (!Array.isArray(object.yellowCardTimes))
                        throw TypeError(".proto.SSL_Referee.TeamInfo.yellowCardTimes: array expected");
                    message.yellowCardTimes = [];
                    for (let i = 0; i < object.yellowCardTimes.length; ++i)
                        message.yellowCardTimes[i] = object.yellowCardTimes[i] >>> 0;
                }
                if (object.yellowCards != null)
                    message.yellowCards = object.yellowCards >>> 0;
                if (object.timeouts != null)
                    message.timeouts = object.timeouts >>> 0;
                if (object.timeoutTime != null)
                    message.timeoutTime = object.timeoutTime >>> 0;
                if (object.goalkeeper != null)
                    message.goalkeeper = object.goalkeeper >>> 0;
                if (object.foulCounter != null)
                    message.foulCounter = object.foulCounter >>> 0;
                if (object.ballPlacementFailures != null)
                    message.ballPlacementFailures = object.ballPlacementFailures >>> 0;
                if (object.canPlaceBall != null)
                    message.canPlaceBall = Boolean(object.canPlaceBall);
                if (object.maxAllowedBots != null)
                    message.maxAllowedBots = object.maxAllowedBots >>> 0;
                if (object.botSubstitutionIntent != null)
                    message.botSubstitutionIntent = Boolean(object.botSubstitutionIntent);
                if (object.ballPlacementFailuresReached != null)
                    message.ballPlacementFailuresReached = Boolean(object.ballPlacementFailuresReached);
                return message;
            };

            /**
             * Creates a plain object from a TeamInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SSL_Referee.TeamInfo
             * @static
             * @param {proto.SSL_Referee.TeamInfo} message TeamInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TeamInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.yellowCardTimes = [];
                if (options.defaults) {
                    object.name = "";
                    object.score = 0;
                    object.redCards = 0;
                    object.yellowCards = 0;
                    object.timeouts = 0;
                    object.timeoutTime = 0;
                    object.goalkeeper = 0;
                    object.foulCounter = 0;
                    object.ballPlacementFailures = 0;
                    object.canPlaceBall = false;
                    object.maxAllowedBots = 0;
                    object.botSubstitutionIntent = false;
                    object.ballPlacementFailuresReached = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.score != null && message.hasOwnProperty("score"))
                    object.score = message.score;
                if (message.redCards != null && message.hasOwnProperty("redCards"))
                    object.redCards = message.redCards;
                if (message.yellowCardTimes && message.yellowCardTimes.length) {
                    object.yellowCardTimes = [];
                    for (let j = 0; j < message.yellowCardTimes.length; ++j)
                        object.yellowCardTimes[j] = message.yellowCardTimes[j];
                }
                if (message.yellowCards != null && message.hasOwnProperty("yellowCards"))
                    object.yellowCards = message.yellowCards;
                if (message.timeouts != null && message.hasOwnProperty("timeouts"))
                    object.timeouts = message.timeouts;
                if (message.timeoutTime != null && message.hasOwnProperty("timeoutTime"))
                    object.timeoutTime = message.timeoutTime;
                if (message.goalkeeper != null && message.hasOwnProperty("goalkeeper"))
                    object.goalkeeper = message.goalkeeper;
                if (message.foulCounter != null && message.hasOwnProperty("foulCounter"))
                    object.foulCounter = message.foulCounter;
                if (message.ballPlacementFailures != null && message.hasOwnProperty("ballPlacementFailures"))
                    object.ballPlacementFailures = message.ballPlacementFailures;
                if (message.canPlaceBall != null && message.hasOwnProperty("canPlaceBall"))
                    object.canPlaceBall = message.canPlaceBall;
                if (message.maxAllowedBots != null && message.hasOwnProperty("maxAllowedBots"))
                    object.maxAllowedBots = message.maxAllowedBots;
                if (message.botSubstitutionIntent != null && message.hasOwnProperty("botSubstitutionIntent"))
                    object.botSubstitutionIntent = message.botSubstitutionIntent;
                if (message.ballPlacementFailuresReached != null && message.hasOwnProperty("ballPlacementFailuresReached"))
                    object.ballPlacementFailuresReached = message.ballPlacementFailuresReached;
                return object;
            };

            /**
             * Converts this TeamInfo to JSON.
             * @function toJSON
             * @memberof proto.SSL_Referee.TeamInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TeamInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TeamInfo
             * @function getTypeUrl
             * @memberof proto.SSL_Referee.TeamInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TeamInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.SSL_Referee.TeamInfo";
            };

            return TeamInfo;
        })();

        SSL_Referee.Point = (function() {

            /**
             * Properties of a Point.
             * @memberof proto.SSL_Referee
             * @interface IPoint
             * @property {number} x Point x
             * @property {number} y Point y
             */

            /**
             * Constructs a new Point.
             * @memberof proto.SSL_Referee
             * @classdesc Represents a Point.
             * @implements IPoint
             * @constructor
             * @param {proto.SSL_Referee.IPoint=} [properties] Properties to set
             */
            function Point(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Point x.
             * @member {number} x
             * @memberof proto.SSL_Referee.Point
             * @instance
             */
            Point.prototype.x = 0;

            /**
             * Point y.
             * @member {number} y
             * @memberof proto.SSL_Referee.Point
             * @instance
             */
            Point.prototype.y = 0;

            /**
             * Creates a new Point instance using the specified properties.
             * @function create
             * @memberof proto.SSL_Referee.Point
             * @static
             * @param {proto.SSL_Referee.IPoint=} [properties] Properties to set
             * @returns {proto.SSL_Referee.Point} Point instance
             */
            Point.create = function create(properties) {
                return new Point(properties);
            };

            /**
             * Encodes the specified Point message. Does not implicitly {@link proto.SSL_Referee.Point.verify|verify} messages.
             * @function encode
             * @memberof proto.SSL_Referee.Point
             * @static
             * @param {proto.SSL_Referee.IPoint} message Point message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Point.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
                return writer;
            };

            /**
             * Encodes the specified Point message, length delimited. Does not implicitly {@link proto.SSL_Referee.Point.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.SSL_Referee.Point
             * @static
             * @param {proto.SSL_Referee.IPoint} message Point message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Point.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Point message from the specified reader or buffer.
             * @function decode
             * @memberof proto.SSL_Referee.Point
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.SSL_Referee.Point} Point
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Point.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SSL_Referee.Point();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.x = reader.float();
                            break;
                        }
                    case 2: {
                            message.y = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("x"))
                    throw $util.ProtocolError("missing required 'x'", { instance: message });
                if (!message.hasOwnProperty("y"))
                    throw $util.ProtocolError("missing required 'y'", { instance: message });
                return message;
            };

            /**
             * Decodes a Point message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.SSL_Referee.Point
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.SSL_Referee.Point} Point
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Point.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Point message.
             * @function verify
             * @memberof proto.SSL_Referee.Point
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Point.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (typeof message.x !== "number")
                    return "x: number expected";
                if (typeof message.y !== "number")
                    return "y: number expected";
                return null;
            };

            /**
             * Creates a Point message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.SSL_Referee.Point
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.SSL_Referee.Point} Point
             */
            Point.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.SSL_Referee.Point)
                    return object;
                let message = new $root.proto.SSL_Referee.Point();
                if (object.x != null)
                    message.x = Number(object.x);
                if (object.y != null)
                    message.y = Number(object.y);
                return message;
            };

            /**
             * Creates a plain object from a Point message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.SSL_Referee.Point
             * @static
             * @param {proto.SSL_Referee.Point} message Point
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Point.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.x = 0;
                    object.y = 0;
                }
                if (message.x != null && message.hasOwnProperty("x"))
                    object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                if (message.y != null && message.hasOwnProperty("y"))
                    object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                return object;
            };

            /**
             * Converts this Point to JSON.
             * @function toJSON
             * @memberof proto.SSL_Referee.Point
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Point.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Point
             * @function getTypeUrl
             * @memberof proto.SSL_Referee.Point
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Point.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.SSL_Referee.Point";
            };

            return Point;
        })();

        return SSL_Referee;
    })();

    proto.GameEventProposalGroup = (function() {

        /**
         * Properties of a GameEventProposalGroup.
         * @memberof proto
         * @interface IGameEventProposalGroup
         * @property {Array.<proto.IGameEvent>|null} [gameEvent] GameEventProposalGroup gameEvent
         * @property {boolean|null} [accepted] GameEventProposalGroup accepted
         */

        /**
         * Constructs a new GameEventProposalGroup.
         * @memberof proto
         * @classdesc Represents a GameEventProposalGroup.
         * @implements IGameEventProposalGroup
         * @constructor
         * @param {proto.IGameEventProposalGroup=} [properties] Properties to set
         */
        function GameEventProposalGroup(properties) {
            this.gameEvent = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameEventProposalGroup gameEvent.
         * @member {Array.<proto.IGameEvent>} gameEvent
         * @memberof proto.GameEventProposalGroup
         * @instance
         */
        GameEventProposalGroup.prototype.gameEvent = $util.emptyArray;

        /**
         * GameEventProposalGroup accepted.
         * @member {boolean} accepted
         * @memberof proto.GameEventProposalGroup
         * @instance
         */
        GameEventProposalGroup.prototype.accepted = false;

        /**
         * Creates a new GameEventProposalGroup instance using the specified properties.
         * @function create
         * @memberof proto.GameEventProposalGroup
         * @static
         * @param {proto.IGameEventProposalGroup=} [properties] Properties to set
         * @returns {proto.GameEventProposalGroup} GameEventProposalGroup instance
         */
        GameEventProposalGroup.create = function create(properties) {
            return new GameEventProposalGroup(properties);
        };

        /**
         * Encodes the specified GameEventProposalGroup message. Does not implicitly {@link proto.GameEventProposalGroup.verify|verify} messages.
         * @function encode
         * @memberof proto.GameEventProposalGroup
         * @static
         * @param {proto.IGameEventProposalGroup} message GameEventProposalGroup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameEventProposalGroup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameEvent != null && message.gameEvent.length)
                for (let i = 0; i < message.gameEvent.length; ++i)
                    $root.proto.GameEvent.encode(message.gameEvent[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.accepted != null && Object.hasOwnProperty.call(message, "accepted"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.accepted);
            return writer;
        };

        /**
         * Encodes the specified GameEventProposalGroup message, length delimited. Does not implicitly {@link proto.GameEventProposalGroup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.GameEventProposalGroup
         * @static
         * @param {proto.IGameEventProposalGroup} message GameEventProposalGroup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameEventProposalGroup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GameEventProposalGroup message from the specified reader or buffer.
         * @function decode
         * @memberof proto.GameEventProposalGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.GameEventProposalGroup} GameEventProposalGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameEventProposalGroup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.GameEventProposalGroup();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.gameEvent && message.gameEvent.length))
                            message.gameEvent = [];
                        message.gameEvent.push($root.proto.GameEvent.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.accepted = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GameEventProposalGroup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.GameEventProposalGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.GameEventProposalGroup} GameEventProposalGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameEventProposalGroup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GameEventProposalGroup message.
         * @function verify
         * @memberof proto.GameEventProposalGroup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GameEventProposalGroup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameEvent != null && message.hasOwnProperty("gameEvent")) {
                if (!Array.isArray(message.gameEvent))
                    return "gameEvent: array expected";
                for (let i = 0; i < message.gameEvent.length; ++i) {
                    let error = $root.proto.GameEvent.verify(message.gameEvent[i]);
                    if (error)
                        return "gameEvent." + error;
                }
            }
            if (message.accepted != null && message.hasOwnProperty("accepted"))
                if (typeof message.accepted !== "boolean")
                    return "accepted: boolean expected";
            return null;
        };

        /**
         * Creates a GameEventProposalGroup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.GameEventProposalGroup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.GameEventProposalGroup} GameEventProposalGroup
         */
        GameEventProposalGroup.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.GameEventProposalGroup)
                return object;
            let message = new $root.proto.GameEventProposalGroup();
            if (object.gameEvent) {
                if (!Array.isArray(object.gameEvent))
                    throw TypeError(".proto.GameEventProposalGroup.gameEvent: array expected");
                message.gameEvent = [];
                for (let i = 0; i < object.gameEvent.length; ++i) {
                    if (typeof object.gameEvent[i] !== "object")
                        throw TypeError(".proto.GameEventProposalGroup.gameEvent: object expected");
                    message.gameEvent[i] = $root.proto.GameEvent.fromObject(object.gameEvent[i]);
                }
            }
            if (object.accepted != null)
                message.accepted = Boolean(object.accepted);
            return message;
        };

        /**
         * Creates a plain object from a GameEventProposalGroup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.GameEventProposalGroup
         * @static
         * @param {proto.GameEventProposalGroup} message GameEventProposalGroup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GameEventProposalGroup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.gameEvent = [];
            if (options.defaults)
                object.accepted = false;
            if (message.gameEvent && message.gameEvent.length) {
                object.gameEvent = [];
                for (let j = 0; j < message.gameEvent.length; ++j)
                    object.gameEvent[j] = $root.proto.GameEvent.toObject(message.gameEvent[j], options);
            }
            if (message.accepted != null && message.hasOwnProperty("accepted"))
                object.accepted = message.accepted;
            return object;
        };

        /**
         * Converts this GameEventProposalGroup to JSON.
         * @function toJSON
         * @memberof proto.GameEventProposalGroup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GameEventProposalGroup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GameEventProposalGroup
         * @function getTypeUrl
         * @memberof proto.GameEventProposalGroup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GameEventProposalGroup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.GameEventProposalGroup";
        };

        return GameEventProposalGroup;
    })();

    proto.SSL_WrapperPacket = (function() {

        /**
         * Properties of a SSL_WrapperPacket.
         * @memberof proto
         * @interface ISSL_WrapperPacket
         * @property {proto.ISSL_DetectionFrame|null} [detection] SSL_WrapperPacket detection
         * @property {proto.ISSL_GeometryData|null} [geometry] SSL_WrapperPacket geometry
         */

        /**
         * Constructs a new SSL_WrapperPacket.
         * @memberof proto
         * @classdesc Represents a SSL_WrapperPacket.
         * @implements ISSL_WrapperPacket
         * @constructor
         * @param {proto.ISSL_WrapperPacket=} [properties] Properties to set
         */
        function SSL_WrapperPacket(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SSL_WrapperPacket detection.
         * @member {proto.ISSL_DetectionFrame|null|undefined} detection
         * @memberof proto.SSL_WrapperPacket
         * @instance
         */
        SSL_WrapperPacket.prototype.detection = null;

        /**
         * SSL_WrapperPacket geometry.
         * @member {proto.ISSL_GeometryData|null|undefined} geometry
         * @memberof proto.SSL_WrapperPacket
         * @instance
         */
        SSL_WrapperPacket.prototype.geometry = null;

        /**
         * Creates a new SSL_WrapperPacket instance using the specified properties.
         * @function create
         * @memberof proto.SSL_WrapperPacket
         * @static
         * @param {proto.ISSL_WrapperPacket=} [properties] Properties to set
         * @returns {proto.SSL_WrapperPacket} SSL_WrapperPacket instance
         */
        SSL_WrapperPacket.create = function create(properties) {
            return new SSL_WrapperPacket(properties);
        };

        /**
         * Encodes the specified SSL_WrapperPacket message. Does not implicitly {@link proto.SSL_WrapperPacket.verify|verify} messages.
         * @function encode
         * @memberof proto.SSL_WrapperPacket
         * @static
         * @param {proto.ISSL_WrapperPacket} message SSL_WrapperPacket message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_WrapperPacket.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.detection != null && Object.hasOwnProperty.call(message, "detection"))
                $root.proto.SSL_DetectionFrame.encode(message.detection, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.geometry != null && Object.hasOwnProperty.call(message, "geometry"))
                $root.proto.SSL_GeometryData.encode(message.geometry, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SSL_WrapperPacket message, length delimited. Does not implicitly {@link proto.SSL_WrapperPacket.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SSL_WrapperPacket
         * @static
         * @param {proto.ISSL_WrapperPacket} message SSL_WrapperPacket message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SSL_WrapperPacket.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SSL_WrapperPacket message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SSL_WrapperPacket
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SSL_WrapperPacket} SSL_WrapperPacket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_WrapperPacket.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SSL_WrapperPacket();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.detection = $root.proto.SSL_DetectionFrame.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.geometry = $root.proto.SSL_GeometryData.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SSL_WrapperPacket message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SSL_WrapperPacket
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SSL_WrapperPacket} SSL_WrapperPacket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SSL_WrapperPacket.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SSL_WrapperPacket message.
         * @function verify
         * @memberof proto.SSL_WrapperPacket
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SSL_WrapperPacket.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.detection != null && message.hasOwnProperty("detection")) {
                let error = $root.proto.SSL_DetectionFrame.verify(message.detection);
                if (error)
                    return "detection." + error;
            }
            if (message.geometry != null && message.hasOwnProperty("geometry")) {
                let error = $root.proto.SSL_GeometryData.verify(message.geometry);
                if (error)
                    return "geometry." + error;
            }
            return null;
        };

        /**
         * Creates a SSL_WrapperPacket message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SSL_WrapperPacket
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SSL_WrapperPacket} SSL_WrapperPacket
         */
        SSL_WrapperPacket.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SSL_WrapperPacket)
                return object;
            let message = new $root.proto.SSL_WrapperPacket();
            if (object.detection != null) {
                if (typeof object.detection !== "object")
                    throw TypeError(".proto.SSL_WrapperPacket.detection: object expected");
                message.detection = $root.proto.SSL_DetectionFrame.fromObject(object.detection);
            }
            if (object.geometry != null) {
                if (typeof object.geometry !== "object")
                    throw TypeError(".proto.SSL_WrapperPacket.geometry: object expected");
                message.geometry = $root.proto.SSL_GeometryData.fromObject(object.geometry);
            }
            return message;
        };

        /**
         * Creates a plain object from a SSL_WrapperPacket message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SSL_WrapperPacket
         * @static
         * @param {proto.SSL_WrapperPacket} message SSL_WrapperPacket
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SSL_WrapperPacket.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.detection = null;
                object.geometry = null;
            }
            if (message.detection != null && message.hasOwnProperty("detection"))
                object.detection = $root.proto.SSL_DetectionFrame.toObject(message.detection, options);
            if (message.geometry != null && message.hasOwnProperty("geometry"))
                object.geometry = $root.proto.SSL_GeometryData.toObject(message.geometry, options);
            return object;
        };

        /**
         * Converts this SSL_WrapperPacket to JSON.
         * @function toJSON
         * @memberof proto.SSL_WrapperPacket
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SSL_WrapperPacket.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SSL_WrapperPacket
         * @function getTypeUrl
         * @memberof proto.SSL_WrapperPacket
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SSL_WrapperPacket.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SSL_WrapperPacket";
        };

        return SSL_WrapperPacket;
    })();

    proto.Drawing = (function() {

        /**
         * Properties of a Drawing.
         * @memberof proto
         * @interface IDrawing
         * @property {number|null} [retainForTicks] Drawing retainForTicks
         * @property {string|null} [label] Drawing label
         * @property {proto.Drawing.Color|null} [color] Drawing color
         * @property {proto.Drawing.Method|null} [method] Drawing method
         * @property {Array.<proto.IVector2f>|null} [points] Drawing points
         * @property {proto.Drawing.Category|null} [category] Drawing category
         * @property {number|null} [forRobotId] Drawing forRobotId
         * @property {number|null} [size] Drawing size
         * @property {number|null} [thickness] Drawing thickness
         */

        /**
         * Constructs a new Drawing.
         * @memberof proto
         * @classdesc Represents a Drawing.
         * @implements IDrawing
         * @constructor
         * @param {proto.IDrawing=} [properties] Properties to set
         */
        function Drawing(properties) {
            this.points = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Drawing retainForTicks.
         * @member {number} retainForTicks
         * @memberof proto.Drawing
         * @instance
         */
        Drawing.prototype.retainForTicks = 0;

        /**
         * Drawing label.
         * @member {string} label
         * @memberof proto.Drawing
         * @instance
         */
        Drawing.prototype.label = "";

        /**
         * Drawing color.
         * @member {proto.Drawing.Color} color
         * @memberof proto.Drawing
         * @instance
         */
        Drawing.prototype.color = 0;

        /**
         * Drawing method.
         * @member {proto.Drawing.Method} method
         * @memberof proto.Drawing
         * @instance
         */
        Drawing.prototype.method = 0;

        /**
         * Drawing points.
         * @member {Array.<proto.IVector2f>} points
         * @memberof proto.Drawing
         * @instance
         */
        Drawing.prototype.points = $util.emptyArray;

        /**
         * Drawing category.
         * @member {proto.Drawing.Category} category
         * @memberof proto.Drawing
         * @instance
         */
        Drawing.prototype.category = 0;

        /**
         * Drawing forRobotId.
         * @member {number} forRobotId
         * @memberof proto.Drawing
         * @instance
         */
        Drawing.prototype.forRobotId = 0;

        /**
         * Drawing size.
         * @member {number} size
         * @memberof proto.Drawing
         * @instance
         */
        Drawing.prototype.size = 0;

        /**
         * Drawing thickness.
         * @member {number} thickness
         * @memberof proto.Drawing
         * @instance
         */
        Drawing.prototype.thickness = 0;

        /**
         * Creates a new Drawing instance using the specified properties.
         * @function create
         * @memberof proto.Drawing
         * @static
         * @param {proto.IDrawing=} [properties] Properties to set
         * @returns {proto.Drawing} Drawing instance
         */
        Drawing.create = function create(properties) {
            return new Drawing(properties);
        };

        /**
         * Encodes the specified Drawing message. Does not implicitly {@link proto.Drawing.verify|verify} messages.
         * @function encode
         * @memberof proto.Drawing
         * @static
         * @param {proto.IDrawing} message Drawing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Drawing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.retainForTicks != null && Object.hasOwnProperty.call(message, "retainForTicks"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.retainForTicks);
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.label);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.color);
            if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.method);
            if (message.points != null && message.points.length)
                for (let i = 0; i < message.points.length; ++i)
                    $root.proto.Vector2f.encode(message.points[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.category != null && Object.hasOwnProperty.call(message, "category"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.category);
            if (message.forRobotId != null && Object.hasOwnProperty.call(message, "forRobotId"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.forRobotId);
            if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.size);
            if (message.thickness != null && Object.hasOwnProperty.call(message, "thickness"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.thickness);
            return writer;
        };

        /**
         * Encodes the specified Drawing message, length delimited. Does not implicitly {@link proto.Drawing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Drawing
         * @static
         * @param {proto.IDrawing} message Drawing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Drawing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Drawing message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Drawing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Drawing} Drawing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Drawing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Drawing();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.retainForTicks = reader.uint32();
                        break;
                    }
                case 2: {
                        message.label = reader.string();
                        break;
                    }
                case 3: {
                        message.color = reader.int32();
                        break;
                    }
                case 4: {
                        message.method = reader.int32();
                        break;
                    }
                case 5: {
                        if (!(message.points && message.points.length))
                            message.points = [];
                        message.points.push($root.proto.Vector2f.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        message.category = reader.int32();
                        break;
                    }
                case 7: {
                        message.forRobotId = reader.uint32();
                        break;
                    }
                case 8: {
                        message.size = reader.uint32();
                        break;
                    }
                case 9: {
                        message.thickness = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Drawing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Drawing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Drawing} Drawing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Drawing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Drawing message.
         * @function verify
         * @memberof proto.Drawing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Drawing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.retainForTicks != null && message.hasOwnProperty("retainForTicks"))
                if (!$util.isInteger(message.retainForTicks))
                    return "retainForTicks: integer expected";
            if (message.label != null && message.hasOwnProperty("label"))
                if (!$util.isString(message.label))
                    return "label: string expected";
            if (message.color != null && message.hasOwnProperty("color"))
                switch (message.color) {
                default:
                    return "color: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.method != null && message.hasOwnProperty("method"))
                switch (message.method) {
                default:
                    return "method: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.points != null && message.hasOwnProperty("points")) {
                if (!Array.isArray(message.points))
                    return "points: array expected";
                for (let i = 0; i < message.points.length; ++i) {
                    let error = $root.proto.Vector2f.verify(message.points[i]);
                    if (error)
                        return "points." + error;
                }
            }
            if (message.category != null && message.hasOwnProperty("category"))
                switch (message.category) {
                default:
                    return "category: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.forRobotId != null && message.hasOwnProperty("forRobotId"))
                if (!$util.isInteger(message.forRobotId))
                    return "forRobotId: integer expected";
            if (message.size != null && message.hasOwnProperty("size"))
                if (!$util.isInteger(message.size))
                    return "size: integer expected";
            if (message.thickness != null && message.hasOwnProperty("thickness"))
                if (!$util.isInteger(message.thickness))
                    return "thickness: integer expected";
            return null;
        };

        /**
         * Creates a Drawing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Drawing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Drawing} Drawing
         */
        Drawing.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Drawing)
                return object;
            let message = new $root.proto.Drawing();
            if (object.retainForTicks != null)
                message.retainForTicks = object.retainForTicks >>> 0;
            if (object.label != null)
                message.label = String(object.label);
            switch (object.color) {
            default:
                if (typeof object.color === "number") {
                    message.color = object.color;
                    break;
                }
                break;
            case "RED":
            case 0:
                message.color = 0;
                break;
            case "GREEN":
            case 1:
                message.color = 1;
                break;
            case "BLUE":
            case 2:
                message.color = 2;
                break;
            case "YELLOW":
            case 3:
                message.color = 3;
                break;
            case "CYAN":
            case 4:
                message.color = 4;
                break;
            case "MAGENTA":
            case 5:
                message.color = 5;
                break;
            case "WHITE":
            case 6:
                message.color = 6;
                break;
            case "BLACK":
            case 7:
                message.color = 7;
                break;
            }
            switch (object.method) {
            default:
                if (typeof object.method === "number") {
                    message.method = object.method;
                    break;
                }
                break;
            case "LINES_CONNECTED":
            case 0:
                message.method = 0;
                break;
            case "DOTS":
            case 1:
                message.method = 1;
                break;
            case "CROSSES":
            case 2:
                message.method = 2;
                break;
            case "PLUSES":
            case 3:
                message.method = 3;
                break;
            case "CIRCLES":
            case 4:
                message.method = 4;
                break;
            }
            if (object.points) {
                if (!Array.isArray(object.points))
                    throw TypeError(".proto.Drawing.points: array expected");
                message.points = [];
                for (let i = 0; i < object.points.length; ++i) {
                    if (typeof object.points[i] !== "object")
                        throw TypeError(".proto.Drawing.points: object expected");
                    message.points[i] = $root.proto.Vector2f.fromObject(object.points[i]);
                }
            }
            switch (object.category) {
            default:
                if (typeof object.category === "number") {
                    message.category = object.category;
                    break;
                }
                break;
            case "PATH_PLANNING":
            case 0:
                message.category = 0;
                break;
            case "DEBUG":
            case 1:
                message.category = 1;
                break;
            }
            if (object.forRobotId != null)
                message.forRobotId = object.forRobotId >>> 0;
            if (object.size != null)
                message.size = object.size >>> 0;
            if (object.thickness != null)
                message.thickness = object.thickness >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Drawing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Drawing
         * @static
         * @param {proto.Drawing} message Drawing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Drawing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.points = [];
            if (options.defaults) {
                object.retainForTicks = 0;
                object.label = "";
                object.color = options.enums === String ? "RED" : 0;
                object.method = options.enums === String ? "LINES_CONNECTED" : 0;
                object.category = options.enums === String ? "PATH_PLANNING" : 0;
                object.forRobotId = 0;
                object.size = 0;
                object.thickness = 0;
            }
            if (message.retainForTicks != null && message.hasOwnProperty("retainForTicks"))
                object.retainForTicks = message.retainForTicks;
            if (message.label != null && message.hasOwnProperty("label"))
                object.label = message.label;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = options.enums === String ? $root.proto.Drawing.Color[message.color] === undefined ? message.color : $root.proto.Drawing.Color[message.color] : message.color;
            if (message.method != null && message.hasOwnProperty("method"))
                object.method = options.enums === String ? $root.proto.Drawing.Method[message.method] === undefined ? message.method : $root.proto.Drawing.Method[message.method] : message.method;
            if (message.points && message.points.length) {
                object.points = [];
                for (let j = 0; j < message.points.length; ++j)
                    object.points[j] = $root.proto.Vector2f.toObject(message.points[j], options);
            }
            if (message.category != null && message.hasOwnProperty("category"))
                object.category = options.enums === String ? $root.proto.Drawing.Category[message.category] === undefined ? message.category : $root.proto.Drawing.Category[message.category] : message.category;
            if (message.forRobotId != null && message.hasOwnProperty("forRobotId"))
                object.forRobotId = message.forRobotId;
            if (message.size != null && message.hasOwnProperty("size"))
                object.size = message.size;
            if (message.thickness != null && message.hasOwnProperty("thickness"))
                object.thickness = message.thickness;
            return object;
        };

        /**
         * Converts this Drawing to JSON.
         * @function toJSON
         * @memberof proto.Drawing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Drawing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Drawing
         * @function getTypeUrl
         * @memberof proto.Drawing
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Drawing.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Drawing";
        };

        /**
         * Method enum.
         * @name proto.Drawing.Method
         * @enum {number}
         * @property {number} LINES_CONNECTED=0 LINES_CONNECTED value
         * @property {number} DOTS=1 DOTS value
         * @property {number} CROSSES=2 CROSSES value
         * @property {number} PLUSES=3 PLUSES value
         * @property {number} CIRCLES=4 CIRCLES value
         */
        Drawing.Method = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "LINES_CONNECTED"] = 0;
            values[valuesById[1] = "DOTS"] = 1;
            values[valuesById[2] = "CROSSES"] = 2;
            values[valuesById[3] = "PLUSES"] = 3;
            values[valuesById[4] = "CIRCLES"] = 4;
            return values;
        })();

        /**
         * Color enum.
         * @name proto.Drawing.Color
         * @enum {number}
         * @property {number} RED=0 RED value
         * @property {number} GREEN=1 GREEN value
         * @property {number} BLUE=2 BLUE value
         * @property {number} YELLOW=3 YELLOW value
         * @property {number} CYAN=4 CYAN value
         * @property {number} MAGENTA=5 MAGENTA value
         * @property {number} WHITE=6 WHITE value
         * @property {number} BLACK=7 BLACK value
         */
        Drawing.Color = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "RED"] = 0;
            values[valuesById[1] = "GREEN"] = 1;
            values[valuesById[2] = "BLUE"] = 2;
            values[valuesById[3] = "YELLOW"] = 3;
            values[valuesById[4] = "CYAN"] = 4;
            values[valuesById[5] = "MAGENTA"] = 5;
            values[valuesById[6] = "WHITE"] = 6;
            values[valuesById[7] = "BLACK"] = 7;
            return values;
        })();

        /**
         * Category enum.
         * @name proto.Drawing.Category
         * @enum {number}
         * @property {number} PATH_PLANNING=0 PATH_PLANNING value
         * @property {number} DEBUG=1 DEBUG value
         */
        Drawing.Category = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PATH_PLANNING"] = 0;
            values[valuesById[1] = "DEBUG"] = 1;
            return values;
        })();

        return Drawing;
    })();

    proto.Metric = (function() {

        /**
         * Properties of a Metric.
         * @memberof proto
         * @interface IMetric
         * @property {string|null} [label] Metric label
         * @property {proto.Metric.IBoundedValue|null} [boundedValue] Metric boundedValue
         * @property {proto.Metric.IDecimal|null} [decimal] Metric decimal
         */

        /**
         * Constructs a new Metric.
         * @memberof proto
         * @classdesc Represents a Metric.
         * @implements IMetric
         * @constructor
         * @param {proto.IMetric=} [properties] Properties to set
         */
        function Metric(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Metric label.
         * @member {string} label
         * @memberof proto.Metric
         * @instance
         */
        Metric.prototype.label = "";

        /**
         * Metric boundedValue.
         * @member {proto.Metric.IBoundedValue|null|undefined} boundedValue
         * @memberof proto.Metric
         * @instance
         */
        Metric.prototype.boundedValue = null;

        /**
         * Metric decimal.
         * @member {proto.Metric.IDecimal|null|undefined} decimal
         * @memberof proto.Metric
         * @instance
         */
        Metric.prototype.decimal = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Metric value.
         * @member {"boundedValue"|"decimal"|undefined} value
         * @memberof proto.Metric
         * @instance
         */
        Object.defineProperty(Metric.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["boundedValue", "decimal"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Metric instance using the specified properties.
         * @function create
         * @memberof proto.Metric
         * @static
         * @param {proto.IMetric=} [properties] Properties to set
         * @returns {proto.Metric} Metric instance
         */
        Metric.create = function create(properties) {
            return new Metric(properties);
        };

        /**
         * Encodes the specified Metric message. Does not implicitly {@link proto.Metric.verify|verify} messages.
         * @function encode
         * @memberof proto.Metric
         * @static
         * @param {proto.IMetric} message Metric message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Metric.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
            if (message.boundedValue != null && Object.hasOwnProperty.call(message, "boundedValue"))
                $root.proto.Metric.BoundedValue.encode(message.boundedValue, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.decimal != null && Object.hasOwnProperty.call(message, "decimal"))
                $root.proto.Metric.Decimal.encode(message.decimal, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Metric message, length delimited. Does not implicitly {@link proto.Metric.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.Metric
         * @static
         * @param {proto.IMetric} message Metric message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Metric.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Metric message from the specified reader or buffer.
         * @function decode
         * @memberof proto.Metric
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.Metric} Metric
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Metric.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Metric();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.label = reader.string();
                        break;
                    }
                case 2: {
                        message.boundedValue = $root.proto.Metric.BoundedValue.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.decimal = $root.proto.Metric.Decimal.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Metric message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.Metric
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.Metric} Metric
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Metric.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Metric message.
         * @function verify
         * @memberof proto.Metric
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Metric.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.label != null && message.hasOwnProperty("label"))
                if (!$util.isString(message.label))
                    return "label: string expected";
            if (message.boundedValue != null && message.hasOwnProperty("boundedValue")) {
                properties.value = 1;
                {
                    let error = $root.proto.Metric.BoundedValue.verify(message.boundedValue);
                    if (error)
                        return "boundedValue." + error;
                }
            }
            if (message.decimal != null && message.hasOwnProperty("decimal")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                {
                    let error = $root.proto.Metric.Decimal.verify(message.decimal);
                    if (error)
                        return "decimal." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Metric message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.Metric
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.Metric} Metric
         */
        Metric.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.Metric)
                return object;
            let message = new $root.proto.Metric();
            if (object.label != null)
                message.label = String(object.label);
            if (object.boundedValue != null) {
                if (typeof object.boundedValue !== "object")
                    throw TypeError(".proto.Metric.boundedValue: object expected");
                message.boundedValue = $root.proto.Metric.BoundedValue.fromObject(object.boundedValue);
            }
            if (object.decimal != null) {
                if (typeof object.decimal !== "object")
                    throw TypeError(".proto.Metric.decimal: object expected");
                message.decimal = $root.proto.Metric.Decimal.fromObject(object.decimal);
            }
            return message;
        };

        /**
         * Creates a plain object from a Metric message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.Metric
         * @static
         * @param {proto.Metric} message Metric
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Metric.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.label = "";
            if (message.label != null && message.hasOwnProperty("label"))
                object.label = message.label;
            if (message.boundedValue != null && message.hasOwnProperty("boundedValue")) {
                object.boundedValue = $root.proto.Metric.BoundedValue.toObject(message.boundedValue, options);
                if (options.oneofs)
                    object.value = "boundedValue";
            }
            if (message.decimal != null && message.hasOwnProperty("decimal")) {
                object.decimal = $root.proto.Metric.Decimal.toObject(message.decimal, options);
                if (options.oneofs)
                    object.value = "decimal";
            }
            return object;
        };

        /**
         * Converts this Metric to JSON.
         * @function toJSON
         * @memberof proto.Metric
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Metric.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Metric
         * @function getTypeUrl
         * @memberof proto.Metric
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Metric.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.Metric";
        };

        Metric.BoundedValue = (function() {

            /**
             * Properties of a BoundedValue.
             * @memberof proto.Metric
             * @interface IBoundedValue
             * @property {number|null} [value] BoundedValue value
             * @property {number|null} [min] BoundedValue min
             * @property {number|null} [max] BoundedValue max
             * @property {string|null} [unit] BoundedValue unit
             */

            /**
             * Constructs a new BoundedValue.
             * @memberof proto.Metric
             * @classdesc Represents a BoundedValue.
             * @implements IBoundedValue
             * @constructor
             * @param {proto.Metric.IBoundedValue=} [properties] Properties to set
             */
            function BoundedValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BoundedValue value.
             * @member {number} value
             * @memberof proto.Metric.BoundedValue
             * @instance
             */
            BoundedValue.prototype.value = 0;

            /**
             * BoundedValue min.
             * @member {number} min
             * @memberof proto.Metric.BoundedValue
             * @instance
             */
            BoundedValue.prototype.min = 0;

            /**
             * BoundedValue max.
             * @member {number} max
             * @memberof proto.Metric.BoundedValue
             * @instance
             */
            BoundedValue.prototype.max = 0;

            /**
             * BoundedValue unit.
             * @member {string} unit
             * @memberof proto.Metric.BoundedValue
             * @instance
             */
            BoundedValue.prototype.unit = "";

            /**
             * Creates a new BoundedValue instance using the specified properties.
             * @function create
             * @memberof proto.Metric.BoundedValue
             * @static
             * @param {proto.Metric.IBoundedValue=} [properties] Properties to set
             * @returns {proto.Metric.BoundedValue} BoundedValue instance
             */
            BoundedValue.create = function create(properties) {
                return new BoundedValue(properties);
            };

            /**
             * Encodes the specified BoundedValue message. Does not implicitly {@link proto.Metric.BoundedValue.verify|verify} messages.
             * @function encode
             * @memberof proto.Metric.BoundedValue
             * @static
             * @param {proto.Metric.IBoundedValue} message BoundedValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoundedValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                if (message.min != null && Object.hasOwnProperty.call(message, "min"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.min);
                if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.max);
                if (message.unit != null && Object.hasOwnProperty.call(message, "unit"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.unit);
                return writer;
            };

            /**
             * Encodes the specified BoundedValue message, length delimited. Does not implicitly {@link proto.Metric.BoundedValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Metric.BoundedValue
             * @static
             * @param {proto.Metric.IBoundedValue} message BoundedValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoundedValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BoundedValue message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Metric.BoundedValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Metric.BoundedValue} BoundedValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoundedValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Metric.BoundedValue();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.double();
                            break;
                        }
                    case 2: {
                            message.min = reader.double();
                            break;
                        }
                    case 3: {
                            message.max = reader.double();
                            break;
                        }
                    case 4: {
                            message.unit = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BoundedValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Metric.BoundedValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Metric.BoundedValue} BoundedValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoundedValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BoundedValue message.
             * @function verify
             * @memberof proto.Metric.BoundedValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BoundedValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                if (message.min != null && message.hasOwnProperty("min"))
                    if (typeof message.min !== "number")
                        return "min: number expected";
                if (message.max != null && message.hasOwnProperty("max"))
                    if (typeof message.max !== "number")
                        return "max: number expected";
                if (message.unit != null && message.hasOwnProperty("unit"))
                    if (!$util.isString(message.unit))
                        return "unit: string expected";
                return null;
            };

            /**
             * Creates a BoundedValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Metric.BoundedValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Metric.BoundedValue} BoundedValue
             */
            BoundedValue.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Metric.BoundedValue)
                    return object;
                let message = new $root.proto.Metric.BoundedValue();
                if (object.value != null)
                    message.value = Number(object.value);
                if (object.min != null)
                    message.min = Number(object.min);
                if (object.max != null)
                    message.max = Number(object.max);
                if (object.unit != null)
                    message.unit = String(object.unit);
                return message;
            };

            /**
             * Creates a plain object from a BoundedValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Metric.BoundedValue
             * @static
             * @param {proto.Metric.BoundedValue} message BoundedValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BoundedValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.value = 0;
                    object.min = 0;
                    object.max = 0;
                    object.unit = "";
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (message.min != null && message.hasOwnProperty("min"))
                    object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;
                if (message.max != null && message.hasOwnProperty("max"))
                    object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;
                if (message.unit != null && message.hasOwnProperty("unit"))
                    object.unit = message.unit;
                return object;
            };

            /**
             * Converts this BoundedValue to JSON.
             * @function toJSON
             * @memberof proto.Metric.BoundedValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BoundedValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BoundedValue
             * @function getTypeUrl
             * @memberof proto.Metric.BoundedValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BoundedValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.Metric.BoundedValue";
            };

            return BoundedValue;
        })();

        Metric.Decimal = (function() {

            /**
             * Properties of a Decimal.
             * @memberof proto.Metric
             * @interface IDecimal
             * @property {number|null} [value] Decimal value
             * @property {number|null} [minRecorded] Decimal minRecorded
             * @property {number|null} [maxRecorded] Decimal maxRecorded
             * @property {string|null} [unit] Decimal unit
             */

            /**
             * Constructs a new Decimal.
             * @memberof proto.Metric
             * @classdesc Represents a Decimal.
             * @implements IDecimal
             * @constructor
             * @param {proto.Metric.IDecimal=} [properties] Properties to set
             */
            function Decimal(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Decimal value.
             * @member {number} value
             * @memberof proto.Metric.Decimal
             * @instance
             */
            Decimal.prototype.value = 0;

            /**
             * Decimal minRecorded.
             * @member {number} minRecorded
             * @memberof proto.Metric.Decimal
             * @instance
             */
            Decimal.prototype.minRecorded = 0;

            /**
             * Decimal maxRecorded.
             * @member {number} maxRecorded
             * @memberof proto.Metric.Decimal
             * @instance
             */
            Decimal.prototype.maxRecorded = 0;

            /**
             * Decimal unit.
             * @member {string} unit
             * @memberof proto.Metric.Decimal
             * @instance
             */
            Decimal.prototype.unit = "";

            /**
             * Creates a new Decimal instance using the specified properties.
             * @function create
             * @memberof proto.Metric.Decimal
             * @static
             * @param {proto.Metric.IDecimal=} [properties] Properties to set
             * @returns {proto.Metric.Decimal} Decimal instance
             */
            Decimal.create = function create(properties) {
                return new Decimal(properties);
            };

            /**
             * Encodes the specified Decimal message. Does not implicitly {@link proto.Metric.Decimal.verify|verify} messages.
             * @function encode
             * @memberof proto.Metric.Decimal
             * @static
             * @param {proto.Metric.IDecimal} message Decimal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Decimal.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                if (message.minRecorded != null && Object.hasOwnProperty.call(message, "minRecorded"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.minRecorded);
                if (message.maxRecorded != null && Object.hasOwnProperty.call(message, "maxRecorded"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.maxRecorded);
                if (message.unit != null && Object.hasOwnProperty.call(message, "unit"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.unit);
                return writer;
            };

            /**
             * Encodes the specified Decimal message, length delimited. Does not implicitly {@link proto.Metric.Decimal.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.Metric.Decimal
             * @static
             * @param {proto.Metric.IDecimal} message Decimal message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Decimal.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Decimal message from the specified reader or buffer.
             * @function decode
             * @memberof proto.Metric.Decimal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.Metric.Decimal} Decimal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Decimal.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.Metric.Decimal();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.double();
                            break;
                        }
                    case 2: {
                            message.minRecorded = reader.double();
                            break;
                        }
                    case 3: {
                            message.maxRecorded = reader.double();
                            break;
                        }
                    case 4: {
                            message.unit = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Decimal message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.Metric.Decimal
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.Metric.Decimal} Decimal
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Decimal.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Decimal message.
             * @function verify
             * @memberof proto.Metric.Decimal
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Decimal.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                if (message.minRecorded != null && message.hasOwnProperty("minRecorded"))
                    if (typeof message.minRecorded !== "number")
                        return "minRecorded: number expected";
                if (message.maxRecorded != null && message.hasOwnProperty("maxRecorded"))
                    if (typeof message.maxRecorded !== "number")
                        return "maxRecorded: number expected";
                if (message.unit != null && message.hasOwnProperty("unit"))
                    if (!$util.isString(message.unit))
                        return "unit: string expected";
                return null;
            };

            /**
             * Creates a Decimal message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.Metric.Decimal
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.Metric.Decimal} Decimal
             */
            Decimal.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.Metric.Decimal)
                    return object;
                let message = new $root.proto.Metric.Decimal();
                if (object.value != null)
                    message.value = Number(object.value);
                if (object.minRecorded != null)
                    message.minRecorded = Number(object.minRecorded);
                if (object.maxRecorded != null)
                    message.maxRecorded = Number(object.maxRecorded);
                if (object.unit != null)
                    message.unit = String(object.unit);
                return message;
            };

            /**
             * Creates a plain object from a Decimal message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.Metric.Decimal
             * @static
             * @param {proto.Metric.Decimal} message Decimal
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Decimal.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.value = 0;
                    object.minRecorded = 0;
                    object.maxRecorded = 0;
                    object.unit = "";
                }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                if (message.minRecorded != null && message.hasOwnProperty("minRecorded"))
                    object.minRecorded = options.json && !isFinite(message.minRecorded) ? String(message.minRecorded) : message.minRecorded;
                if (message.maxRecorded != null && message.hasOwnProperty("maxRecorded"))
                    object.maxRecorded = options.json && !isFinite(message.maxRecorded) ? String(message.maxRecorded) : message.maxRecorded;
                if (message.unit != null && message.hasOwnProperty("unit"))
                    object.unit = message.unit;
                return object;
            };

            /**
             * Converts this Decimal to JSON.
             * @function toJSON
             * @memberof proto.Metric.Decimal
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Decimal.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Decimal
             * @function getTypeUrl
             * @memberof proto.Metric.Decimal
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Decimal.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.Metric.Decimal";
            };

            return Decimal;
        })();

        return Metric;
    })();

    proto.STPStatus = (function() {

        /**
         * Properties of a STPStatus.
         * @memberof proto
         * @interface ISTPStatus
         * @property {proto.IPlayInfo|null} [currentPlay] STPStatus currentPlay
         * @property {number|null} [score] STPStatus score
         * @property {Object.<string,proto.STPStatus.ISTPRobot>|null} [robots] STPStatus robots
         * @property {Array.<proto.STPStatus.IScoredPlay>|null} [scoredPlays] STPStatus scoredPlays
         * @property {number|null} [currentTick] STPStatus currentTick
         */

        /**
         * Constructs a new STPStatus.
         * @memberof proto
         * @classdesc Represents a STPStatus.
         * @implements ISTPStatus
         * @constructor
         * @param {proto.ISTPStatus=} [properties] Properties to set
         */
        function STPStatus(properties) {
            this.robots = {};
            this.scoredPlays = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * STPStatus currentPlay.
         * @member {proto.IPlayInfo|null|undefined} currentPlay
         * @memberof proto.STPStatus
         * @instance
         */
        STPStatus.prototype.currentPlay = null;

        /**
         * STPStatus score.
         * @member {number} score
         * @memberof proto.STPStatus
         * @instance
         */
        STPStatus.prototype.score = 0;

        /**
         * STPStatus robots.
         * @member {Object.<string,proto.STPStatus.ISTPRobot>} robots
         * @memberof proto.STPStatus
         * @instance
         */
        STPStatus.prototype.robots = $util.emptyObject;

        /**
         * STPStatus scoredPlays.
         * @member {Array.<proto.STPStatus.IScoredPlay>} scoredPlays
         * @memberof proto.STPStatus
         * @instance
         */
        STPStatus.prototype.scoredPlays = $util.emptyArray;

        /**
         * STPStatus currentTick.
         * @member {number} currentTick
         * @memberof proto.STPStatus
         * @instance
         */
        STPStatus.prototype.currentTick = 0;

        /**
         * Creates a new STPStatus instance using the specified properties.
         * @function create
         * @memberof proto.STPStatus
         * @static
         * @param {proto.ISTPStatus=} [properties] Properties to set
         * @returns {proto.STPStatus} STPStatus instance
         */
        STPStatus.create = function create(properties) {
            return new STPStatus(properties);
        };

        /**
         * Encodes the specified STPStatus message. Does not implicitly {@link proto.STPStatus.verify|verify} messages.
         * @function encode
         * @memberof proto.STPStatus
         * @static
         * @param {proto.ISTPStatus} message STPStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        STPStatus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentPlay != null && Object.hasOwnProperty.call(message, "currentPlay"))
                $root.proto.PlayInfo.encode(message.currentPlay, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.score);
            if (message.robots != null && Object.hasOwnProperty.call(message, "robots"))
                for (let keys = Object.keys(message.robots), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 0 =*/8).int32(keys[i]);
                    $root.proto.STPStatus.STPRobot.encode(message.robots[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.scoredPlays != null && message.scoredPlays.length)
                for (let i = 0; i < message.scoredPlays.length; ++i)
                    $root.proto.STPStatus.ScoredPlay.encode(message.scoredPlays[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.currentTick != null && Object.hasOwnProperty.call(message, "currentTick"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.currentTick);
            return writer;
        };

        /**
         * Encodes the specified STPStatus message, length delimited. Does not implicitly {@link proto.STPStatus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.STPStatus
         * @static
         * @param {proto.ISTPStatus} message STPStatus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        STPStatus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a STPStatus message from the specified reader or buffer.
         * @function decode
         * @memberof proto.STPStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.STPStatus} STPStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        STPStatus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.STPStatus(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.currentPlay = $root.proto.PlayInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.score = reader.uint32();
                        break;
                    }
                case 4: {
                        if (message.robots === $util.emptyObject)
                            message.robots = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = 0;
                        value = null;
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.int32();
                                break;
                            case 2:
                                value = $root.proto.STPStatus.STPRobot.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.robots[key] = value;
                        break;
                    }
                case 5: {
                        if (!(message.scoredPlays && message.scoredPlays.length))
                            message.scoredPlays = [];
                        message.scoredPlays.push($root.proto.STPStatus.ScoredPlay.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        message.currentTick = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a STPStatus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.STPStatus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.STPStatus} STPStatus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        STPStatus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a STPStatus message.
         * @function verify
         * @memberof proto.STPStatus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        STPStatus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentPlay != null && message.hasOwnProperty("currentPlay")) {
                let error = $root.proto.PlayInfo.verify(message.currentPlay);
                if (error)
                    return "currentPlay." + error;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.robots != null && message.hasOwnProperty("robots")) {
                if (!$util.isObject(message.robots))
                    return "robots: object expected";
                let key = Object.keys(message.robots);
                for (let i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "robots: integer key{k:int32} expected";
                    {
                        let error = $root.proto.STPStatus.STPRobot.verify(message.robots[key[i]]);
                        if (error)
                            return "robots." + error;
                    }
                }
            }
            if (message.scoredPlays != null && message.hasOwnProperty("scoredPlays")) {
                if (!Array.isArray(message.scoredPlays))
                    return "scoredPlays: array expected";
                for (let i = 0; i < message.scoredPlays.length; ++i) {
                    let error = $root.proto.STPStatus.ScoredPlay.verify(message.scoredPlays[i]);
                    if (error)
                        return "scoredPlays." + error;
                }
            }
            if (message.currentTick != null && message.hasOwnProperty("currentTick"))
                if (!$util.isInteger(message.currentTick))
                    return "currentTick: integer expected";
            return null;
        };

        /**
         * Creates a STPStatus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.STPStatus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.STPStatus} STPStatus
         */
        STPStatus.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.STPStatus)
                return object;
            let message = new $root.proto.STPStatus();
            if (object.currentPlay != null) {
                if (typeof object.currentPlay !== "object")
                    throw TypeError(".proto.STPStatus.currentPlay: object expected");
                message.currentPlay = $root.proto.PlayInfo.fromObject(object.currentPlay);
            }
            if (object.score != null)
                message.score = object.score >>> 0;
            if (object.robots) {
                if (typeof object.robots !== "object")
                    throw TypeError(".proto.STPStatus.robots: object expected");
                message.robots = {};
                for (let keys = Object.keys(object.robots), i = 0; i < keys.length; ++i) {
                    if (typeof object.robots[keys[i]] !== "object")
                        throw TypeError(".proto.STPStatus.robots: object expected");
                    message.robots[keys[i]] = $root.proto.STPStatus.STPRobot.fromObject(object.robots[keys[i]]);
                }
            }
            if (object.scoredPlays) {
                if (!Array.isArray(object.scoredPlays))
                    throw TypeError(".proto.STPStatus.scoredPlays: array expected");
                message.scoredPlays = [];
                for (let i = 0; i < object.scoredPlays.length; ++i) {
                    if (typeof object.scoredPlays[i] !== "object")
                        throw TypeError(".proto.STPStatus.scoredPlays: object expected");
                    message.scoredPlays[i] = $root.proto.STPStatus.ScoredPlay.fromObject(object.scoredPlays[i]);
                }
            }
            if (object.currentTick != null)
                message.currentTick = object.currentTick | 0;
            return message;
        };

        /**
         * Creates a plain object from a STPStatus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.STPStatus
         * @static
         * @param {proto.STPStatus} message STPStatus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        STPStatus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.scoredPlays = [];
            if (options.objects || options.defaults)
                object.robots = {};
            if (options.defaults) {
                object.currentPlay = null;
                object.score = 0;
                object.currentTick = 0;
            }
            if (message.currentPlay != null && message.hasOwnProperty("currentPlay"))
                object.currentPlay = $root.proto.PlayInfo.toObject(message.currentPlay, options);
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            let keys2;
            if (message.robots && (keys2 = Object.keys(message.robots)).length) {
                object.robots = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.robots[keys2[j]] = $root.proto.STPStatus.STPRobot.toObject(message.robots[keys2[j]], options);
            }
            if (message.scoredPlays && message.scoredPlays.length) {
                object.scoredPlays = [];
                for (let j = 0; j < message.scoredPlays.length; ++j)
                    object.scoredPlays[j] = $root.proto.STPStatus.ScoredPlay.toObject(message.scoredPlays[j], options);
            }
            if (message.currentTick != null && message.hasOwnProperty("currentTick"))
                object.currentTick = message.currentTick;
            return object;
        };

        /**
         * Converts this STPStatus to JSON.
         * @function toJSON
         * @memberof proto.STPStatus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        STPStatus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for STPStatus
         * @function getTypeUrl
         * @memberof proto.STPStatus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        STPStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.STPStatus";
        };

        STPStatus.STPRobot = (function() {

            /**
             * Properties of a STPRobot.
             * @memberof proto.STPStatus
             * @interface ISTPRobot
             * @property {number|null} [id] STPRobot id
             * @property {proto.STPStatus.STPRobot.IRole|null} [role] STPRobot role
             * @property {proto.STPStatus.STPRobot.ITactic|null} [tactic] STPRobot tactic
             * @property {proto.STPStatus.STPRobot.ISkill|null} [skill] STPRobot skill
             */

            /**
             * Constructs a new STPRobot.
             * @memberof proto.STPStatus
             * @classdesc Represents a STPRobot.
             * @implements ISTPRobot
             * @constructor
             * @param {proto.STPStatus.ISTPRobot=} [properties] Properties to set
             */
            function STPRobot(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * STPRobot id.
             * @member {number} id
             * @memberof proto.STPStatus.STPRobot
             * @instance
             */
            STPRobot.prototype.id = 0;

            /**
             * STPRobot role.
             * @member {proto.STPStatus.STPRobot.IRole|null|undefined} role
             * @memberof proto.STPStatus.STPRobot
             * @instance
             */
            STPRobot.prototype.role = null;

            /**
             * STPRobot tactic.
             * @member {proto.STPStatus.STPRobot.ITactic|null|undefined} tactic
             * @memberof proto.STPStatus.STPRobot
             * @instance
             */
            STPRobot.prototype.tactic = null;

            /**
             * STPRobot skill.
             * @member {proto.STPStatus.STPRobot.ISkill|null|undefined} skill
             * @memberof proto.STPStatus.STPRobot
             * @instance
             */
            STPRobot.prototype.skill = null;

            /**
             * Creates a new STPRobot instance using the specified properties.
             * @function create
             * @memberof proto.STPStatus.STPRobot
             * @static
             * @param {proto.STPStatus.ISTPRobot=} [properties] Properties to set
             * @returns {proto.STPStatus.STPRobot} STPRobot instance
             */
            STPRobot.create = function create(properties) {
                return new STPRobot(properties);
            };

            /**
             * Encodes the specified STPRobot message. Does not implicitly {@link proto.STPStatus.STPRobot.verify|verify} messages.
             * @function encode
             * @memberof proto.STPStatus.STPRobot
             * @static
             * @param {proto.STPStatus.ISTPRobot} message STPRobot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            STPRobot.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                    $root.proto.STPStatus.STPRobot.Role.encode(message.role, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.tactic != null && Object.hasOwnProperty.call(message, "tactic"))
                    $root.proto.STPStatus.STPRobot.Tactic.encode(message.tactic, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.skill != null && Object.hasOwnProperty.call(message, "skill"))
                    $root.proto.STPStatus.STPRobot.Skill.encode(message.skill, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified STPRobot message, length delimited. Does not implicitly {@link proto.STPStatus.STPRobot.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.STPStatus.STPRobot
             * @static
             * @param {proto.STPStatus.ISTPRobot} message STPRobot message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            STPRobot.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a STPRobot message from the specified reader or buffer.
             * @function decode
             * @memberof proto.STPStatus.STPRobot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.STPStatus.STPRobot} STPRobot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            STPRobot.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.STPStatus.STPRobot();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.role = $root.proto.STPStatus.STPRobot.Role.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.tactic = $root.proto.STPStatus.STPRobot.Tactic.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.skill = $root.proto.STPStatus.STPRobot.Skill.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a STPRobot message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.STPStatus.STPRobot
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.STPStatus.STPRobot} STPRobot
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            STPRobot.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a STPRobot message.
             * @function verify
             * @memberof proto.STPStatus.STPRobot
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            STPRobot.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.role != null && message.hasOwnProperty("role")) {
                    let error = $root.proto.STPStatus.STPRobot.Role.verify(message.role);
                    if (error)
                        return "role." + error;
                }
                if (message.tactic != null && message.hasOwnProperty("tactic")) {
                    let error = $root.proto.STPStatus.STPRobot.Tactic.verify(message.tactic);
                    if (error)
                        return "tactic." + error;
                }
                if (message.skill != null && message.hasOwnProperty("skill")) {
                    let error = $root.proto.STPStatus.STPRobot.Skill.verify(message.skill);
                    if (error)
                        return "skill." + error;
                }
                return null;
            };

            /**
             * Creates a STPRobot message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.STPStatus.STPRobot
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.STPStatus.STPRobot} STPRobot
             */
            STPRobot.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.STPStatus.STPRobot)
                    return object;
                let message = new $root.proto.STPStatus.STPRobot();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.role != null) {
                    if (typeof object.role !== "object")
                        throw TypeError(".proto.STPStatus.STPRobot.role: object expected");
                    message.role = $root.proto.STPStatus.STPRobot.Role.fromObject(object.role);
                }
                if (object.tactic != null) {
                    if (typeof object.tactic !== "object")
                        throw TypeError(".proto.STPStatus.STPRobot.tactic: object expected");
                    message.tactic = $root.proto.STPStatus.STPRobot.Tactic.fromObject(object.tactic);
                }
                if (object.skill != null) {
                    if (typeof object.skill !== "object")
                        throw TypeError(".proto.STPStatus.STPRobot.skill: object expected");
                    message.skill = $root.proto.STPStatus.STPRobot.Skill.fromObject(object.skill);
                }
                return message;
            };

            /**
             * Creates a plain object from a STPRobot message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.STPStatus.STPRobot
             * @static
             * @param {proto.STPStatus.STPRobot} message STPRobot
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            STPRobot.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.role = null;
                    object.tactic = null;
                    object.skill = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.role != null && message.hasOwnProperty("role"))
                    object.role = $root.proto.STPStatus.STPRobot.Role.toObject(message.role, options);
                if (message.tactic != null && message.hasOwnProperty("tactic"))
                    object.tactic = $root.proto.STPStatus.STPRobot.Tactic.toObject(message.tactic, options);
                if (message.skill != null && message.hasOwnProperty("skill"))
                    object.skill = $root.proto.STPStatus.STPRobot.Skill.toObject(message.skill, options);
                return object;
            };

            /**
             * Converts this STPRobot to JSON.
             * @function toJSON
             * @memberof proto.STPStatus.STPRobot
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            STPRobot.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for STPRobot
             * @function getTypeUrl
             * @memberof proto.STPStatus.STPRobot
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            STPRobot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.STPStatus.STPRobot";
            };

            /**
             * Status enum.
             * @name proto.STPStatus.STPRobot.Status
             * @enum {number}
             * @property {number} WAITING=0 WAITING value
             * @property {number} SUCCESSFUL=1 SUCCESSFUL value
             * @property {number} FAILURE=2 FAILURE value
             * @property {number} RUNNING=3 RUNNING value
             */
            STPRobot.Status = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "WAITING"] = 0;
                values[valuesById[1] = "SUCCESSFUL"] = 1;
                values[valuesById[2] = "FAILURE"] = 2;
                values[valuesById[3] = "RUNNING"] = 3;
                return values;
            })();

            STPRobot.Role = (function() {

                /**
                 * Properties of a Role.
                 * @memberof proto.STPStatus.STPRobot
                 * @interface IRole
                 * @property {string|null} [name] Role name
                 * @property {proto.STPStatus.STPRobot.Status|null} [status] Role status
                 */

                /**
                 * Constructs a new Role.
                 * @memberof proto.STPStatus.STPRobot
                 * @classdesc Represents a Role.
                 * @implements IRole
                 * @constructor
                 * @param {proto.STPStatus.STPRobot.IRole=} [properties] Properties to set
                 */
                function Role(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Role name.
                 * @member {string} name
                 * @memberof proto.STPStatus.STPRobot.Role
                 * @instance
                 */
                Role.prototype.name = "";

                /**
                 * Role status.
                 * @member {proto.STPStatus.STPRobot.Status} status
                 * @memberof proto.STPStatus.STPRobot.Role
                 * @instance
                 */
                Role.prototype.status = 0;

                /**
                 * Creates a new Role instance using the specified properties.
                 * @function create
                 * @memberof proto.STPStatus.STPRobot.Role
                 * @static
                 * @param {proto.STPStatus.STPRobot.IRole=} [properties] Properties to set
                 * @returns {proto.STPStatus.STPRobot.Role} Role instance
                 */
                Role.create = function create(properties) {
                    return new Role(properties);
                };

                /**
                 * Encodes the specified Role message. Does not implicitly {@link proto.STPStatus.STPRobot.Role.verify|verify} messages.
                 * @function encode
                 * @memberof proto.STPStatus.STPRobot.Role
                 * @static
                 * @param {proto.STPStatus.STPRobot.IRole} message Role message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Role.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                    return writer;
                };

                /**
                 * Encodes the specified Role message, length delimited. Does not implicitly {@link proto.STPStatus.STPRobot.Role.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.STPStatus.STPRobot.Role
                 * @static
                 * @param {proto.STPStatus.STPRobot.IRole} message Role message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Role.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Role message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.STPStatus.STPRobot.Role
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.STPStatus.STPRobot.Role} Role
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Role.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.STPStatus.STPRobot.Role();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.status = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Role message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.STPStatus.STPRobot.Role
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.STPStatus.STPRobot.Role} Role
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Role.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Role message.
                 * @function verify
                 * @memberof proto.STPStatus.STPRobot.Role
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Role.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a Role message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.STPStatus.STPRobot.Role
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.STPStatus.STPRobot.Role} Role
                 */
                Role.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.STPStatus.STPRobot.Role)
                        return object;
                    let message = new $root.proto.STPStatus.STPRobot.Role();
                    if (object.name != null)
                        message.name = String(object.name);
                    switch (object.status) {
                    default:
                        if (typeof object.status === "number") {
                            message.status = object.status;
                            break;
                        }
                        break;
                    case "WAITING":
                    case 0:
                        message.status = 0;
                        break;
                    case "SUCCESSFUL":
                    case 1:
                        message.status = 1;
                        break;
                    case "FAILURE":
                    case 2:
                        message.status = 2;
                        break;
                    case "RUNNING":
                    case 3:
                        message.status = 3;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Role message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.STPStatus.STPRobot.Role
                 * @static
                 * @param {proto.STPStatus.STPRobot.Role} message Role
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Role.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.status = options.enums === String ? "WAITING" : 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.proto.STPStatus.STPRobot.Status[message.status] === undefined ? message.status : $root.proto.STPStatus.STPRobot.Status[message.status] : message.status;
                    return object;
                };

                /**
                 * Converts this Role to JSON.
                 * @function toJSON
                 * @memberof proto.STPStatus.STPRobot.Role
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Role.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Role
                 * @function getTypeUrl
                 * @memberof proto.STPStatus.STPRobot.Role
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Role.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/proto.STPStatus.STPRobot.Role";
                };

                return Role;
            })();

            STPRobot.Tactic = (function() {

                /**
                 * Properties of a Tactic.
                 * @memberof proto.STPStatus.STPRobot
                 * @interface ITactic
                 * @property {string|null} [name] Tactic name
                 * @property {proto.STPStatus.STPRobot.Status|null} [status] Tactic status
                 */

                /**
                 * Constructs a new Tactic.
                 * @memberof proto.STPStatus.STPRobot
                 * @classdesc Represents a Tactic.
                 * @implements ITactic
                 * @constructor
                 * @param {proto.STPStatus.STPRobot.ITactic=} [properties] Properties to set
                 */
                function Tactic(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Tactic name.
                 * @member {string} name
                 * @memberof proto.STPStatus.STPRobot.Tactic
                 * @instance
                 */
                Tactic.prototype.name = "";

                /**
                 * Tactic status.
                 * @member {proto.STPStatus.STPRobot.Status} status
                 * @memberof proto.STPStatus.STPRobot.Tactic
                 * @instance
                 */
                Tactic.prototype.status = 0;

                /**
                 * Creates a new Tactic instance using the specified properties.
                 * @function create
                 * @memberof proto.STPStatus.STPRobot.Tactic
                 * @static
                 * @param {proto.STPStatus.STPRobot.ITactic=} [properties] Properties to set
                 * @returns {proto.STPStatus.STPRobot.Tactic} Tactic instance
                 */
                Tactic.create = function create(properties) {
                    return new Tactic(properties);
                };

                /**
                 * Encodes the specified Tactic message. Does not implicitly {@link proto.STPStatus.STPRobot.Tactic.verify|verify} messages.
                 * @function encode
                 * @memberof proto.STPStatus.STPRobot.Tactic
                 * @static
                 * @param {proto.STPStatus.STPRobot.ITactic} message Tactic message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Tactic.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                    return writer;
                };

                /**
                 * Encodes the specified Tactic message, length delimited. Does not implicitly {@link proto.STPStatus.STPRobot.Tactic.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.STPStatus.STPRobot.Tactic
                 * @static
                 * @param {proto.STPStatus.STPRobot.ITactic} message Tactic message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Tactic.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Tactic message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.STPStatus.STPRobot.Tactic
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.STPStatus.STPRobot.Tactic} Tactic
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Tactic.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.STPStatus.STPRobot.Tactic();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.status = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Tactic message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.STPStatus.STPRobot.Tactic
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.STPStatus.STPRobot.Tactic} Tactic
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Tactic.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Tactic message.
                 * @function verify
                 * @memberof proto.STPStatus.STPRobot.Tactic
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Tactic.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a Tactic message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.STPStatus.STPRobot.Tactic
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.STPStatus.STPRobot.Tactic} Tactic
                 */
                Tactic.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.STPStatus.STPRobot.Tactic)
                        return object;
                    let message = new $root.proto.STPStatus.STPRobot.Tactic();
                    if (object.name != null)
                        message.name = String(object.name);
                    switch (object.status) {
                    default:
                        if (typeof object.status === "number") {
                            message.status = object.status;
                            break;
                        }
                        break;
                    case "WAITING":
                    case 0:
                        message.status = 0;
                        break;
                    case "SUCCESSFUL":
                    case 1:
                        message.status = 1;
                        break;
                    case "FAILURE":
                    case 2:
                        message.status = 2;
                        break;
                    case "RUNNING":
                    case 3:
                        message.status = 3;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Tactic message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.STPStatus.STPRobot.Tactic
                 * @static
                 * @param {proto.STPStatus.STPRobot.Tactic} message Tactic
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Tactic.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.status = options.enums === String ? "WAITING" : 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.proto.STPStatus.STPRobot.Status[message.status] === undefined ? message.status : $root.proto.STPStatus.STPRobot.Status[message.status] : message.status;
                    return object;
                };

                /**
                 * Converts this Tactic to JSON.
                 * @function toJSON
                 * @memberof proto.STPStatus.STPRobot.Tactic
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Tactic.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Tactic
                 * @function getTypeUrl
                 * @memberof proto.STPStatus.STPRobot.Tactic
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Tactic.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/proto.STPStatus.STPRobot.Tactic";
                };

                return Tactic;
            })();

            STPRobot.Skill = (function() {

                /**
                 * Properties of a Skill.
                 * @memberof proto.STPStatus.STPRobot
                 * @interface ISkill
                 * @property {string|null} [name] Skill name
                 * @property {proto.STPStatus.STPRobot.Status|null} [status] Skill status
                 */

                /**
                 * Constructs a new Skill.
                 * @memberof proto.STPStatus.STPRobot
                 * @classdesc Represents a Skill.
                 * @implements ISkill
                 * @constructor
                 * @param {proto.STPStatus.STPRobot.ISkill=} [properties] Properties to set
                 */
                function Skill(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Skill name.
                 * @member {string} name
                 * @memberof proto.STPStatus.STPRobot.Skill
                 * @instance
                 */
                Skill.prototype.name = "";

                /**
                 * Skill status.
                 * @member {proto.STPStatus.STPRobot.Status} status
                 * @memberof proto.STPStatus.STPRobot.Skill
                 * @instance
                 */
                Skill.prototype.status = 0;

                /**
                 * Creates a new Skill instance using the specified properties.
                 * @function create
                 * @memberof proto.STPStatus.STPRobot.Skill
                 * @static
                 * @param {proto.STPStatus.STPRobot.ISkill=} [properties] Properties to set
                 * @returns {proto.STPStatus.STPRobot.Skill} Skill instance
                 */
                Skill.create = function create(properties) {
                    return new Skill(properties);
                };

                /**
                 * Encodes the specified Skill message. Does not implicitly {@link proto.STPStatus.STPRobot.Skill.verify|verify} messages.
                 * @function encode
                 * @memberof proto.STPStatus.STPRobot.Skill
                 * @static
                 * @param {proto.STPStatus.STPRobot.ISkill} message Skill message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Skill.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                    return writer;
                };

                /**
                 * Encodes the specified Skill message, length delimited. Does not implicitly {@link proto.STPStatus.STPRobot.Skill.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof proto.STPStatus.STPRobot.Skill
                 * @static
                 * @param {proto.STPStatus.STPRobot.ISkill} message Skill message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Skill.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Skill message from the specified reader or buffer.
                 * @function decode
                 * @memberof proto.STPStatus.STPRobot.Skill
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {proto.STPStatus.STPRobot.Skill} Skill
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Skill.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.STPStatus.STPRobot.Skill();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.name = reader.string();
                                break;
                            }
                        case 2: {
                                message.status = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Skill message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof proto.STPStatus.STPRobot.Skill
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {proto.STPStatus.STPRobot.Skill} Skill
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Skill.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Skill message.
                 * @function verify
                 * @memberof proto.STPStatus.STPRobot.Skill
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Skill.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a Skill message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof proto.STPStatus.STPRobot.Skill
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {proto.STPStatus.STPRobot.Skill} Skill
                 */
                Skill.fromObject = function fromObject(object) {
                    if (object instanceof $root.proto.STPStatus.STPRobot.Skill)
                        return object;
                    let message = new $root.proto.STPStatus.STPRobot.Skill();
                    if (object.name != null)
                        message.name = String(object.name);
                    switch (object.status) {
                    default:
                        if (typeof object.status === "number") {
                            message.status = object.status;
                            break;
                        }
                        break;
                    case "WAITING":
                    case 0:
                        message.status = 0;
                        break;
                    case "SUCCESSFUL":
                    case 1:
                        message.status = 1;
                        break;
                    case "FAILURE":
                    case 2:
                        message.status = 2;
                        break;
                    case "RUNNING":
                    case 3:
                        message.status = 3;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Skill message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof proto.STPStatus.STPRobot.Skill
                 * @static
                 * @param {proto.STPStatus.STPRobot.Skill} message Skill
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Skill.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.status = options.enums === String ? "WAITING" : 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.proto.STPStatus.STPRobot.Status[message.status] === undefined ? message.status : $root.proto.STPStatus.STPRobot.Status[message.status] : message.status;
                    return object;
                };

                /**
                 * Converts this Skill to JSON.
                 * @function toJSON
                 * @memberof proto.STPStatus.STPRobot.Skill
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Skill.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Skill
                 * @function getTypeUrl
                 * @memberof proto.STPStatus.STPRobot.Skill
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Skill.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/proto.STPStatus.STPRobot.Skill";
                };

                return Skill;
            })();

            return STPRobot;
        })();

        STPStatus.ScoredPlay = (function() {

            /**
             * Properties of a ScoredPlay.
             * @memberof proto.STPStatus
             * @interface IScoredPlay
             * @property {string|null} [playName] ScoredPlay playName
             * @property {number|null} [playScore] ScoredPlay playScore
             */

            /**
             * Constructs a new ScoredPlay.
             * @memberof proto.STPStatus
             * @classdesc Represents a ScoredPlay.
             * @implements IScoredPlay
             * @constructor
             * @param {proto.STPStatus.IScoredPlay=} [properties] Properties to set
             */
            function ScoredPlay(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ScoredPlay playName.
             * @member {string} playName
             * @memberof proto.STPStatus.ScoredPlay
             * @instance
             */
            ScoredPlay.prototype.playName = "";

            /**
             * ScoredPlay playScore.
             * @member {number} playScore
             * @memberof proto.STPStatus.ScoredPlay
             * @instance
             */
            ScoredPlay.prototype.playScore = 0;

            /**
             * Creates a new ScoredPlay instance using the specified properties.
             * @function create
             * @memberof proto.STPStatus.ScoredPlay
             * @static
             * @param {proto.STPStatus.IScoredPlay=} [properties] Properties to set
             * @returns {proto.STPStatus.ScoredPlay} ScoredPlay instance
             */
            ScoredPlay.create = function create(properties) {
                return new ScoredPlay(properties);
            };

            /**
             * Encodes the specified ScoredPlay message. Does not implicitly {@link proto.STPStatus.ScoredPlay.verify|verify} messages.
             * @function encode
             * @memberof proto.STPStatus.ScoredPlay
             * @static
             * @param {proto.STPStatus.IScoredPlay} message ScoredPlay message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScoredPlay.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.playName != null && Object.hasOwnProperty.call(message, "playName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.playName);
                if (message.playScore != null && Object.hasOwnProperty.call(message, "playScore"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.playScore);
                return writer;
            };

            /**
             * Encodes the specified ScoredPlay message, length delimited. Does not implicitly {@link proto.STPStatus.ScoredPlay.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.STPStatus.ScoredPlay
             * @static
             * @param {proto.STPStatus.IScoredPlay} message ScoredPlay message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ScoredPlay.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ScoredPlay message from the specified reader or buffer.
             * @function decode
             * @memberof proto.STPStatus.ScoredPlay
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.STPStatus.ScoredPlay} ScoredPlay
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScoredPlay.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.STPStatus.ScoredPlay();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.playName = reader.string();
                            break;
                        }
                    case 2: {
                            message.playScore = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ScoredPlay message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.STPStatus.ScoredPlay
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.STPStatus.ScoredPlay} ScoredPlay
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ScoredPlay.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ScoredPlay message.
             * @function verify
             * @memberof proto.STPStatus.ScoredPlay
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ScoredPlay.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.playName != null && message.hasOwnProperty("playName"))
                    if (!$util.isString(message.playName))
                        return "playName: string expected";
                if (message.playScore != null && message.hasOwnProperty("playScore"))
                    if (!$util.isInteger(message.playScore))
                        return "playScore: integer expected";
                return null;
            };

            /**
             * Creates a ScoredPlay message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.STPStatus.ScoredPlay
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.STPStatus.ScoredPlay} ScoredPlay
             */
            ScoredPlay.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.STPStatus.ScoredPlay)
                    return object;
                let message = new $root.proto.STPStatus.ScoredPlay();
                if (object.playName != null)
                    message.playName = String(object.playName);
                if (object.playScore != null)
                    message.playScore = object.playScore >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ScoredPlay message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.STPStatus.ScoredPlay
             * @static
             * @param {proto.STPStatus.ScoredPlay} message ScoredPlay
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ScoredPlay.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.playName = "";
                    object.playScore = 0;
                }
                if (message.playName != null && message.hasOwnProperty("playName"))
                    object.playName = message.playName;
                if (message.playScore != null && message.hasOwnProperty("playScore"))
                    object.playScore = message.playScore;
                return object;
            };

            /**
             * Converts this ScoredPlay to JSON.
             * @function toJSON
             * @memberof proto.STPStatus.ScoredPlay
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ScoredPlay.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ScoredPlay
             * @function getTypeUrl
             * @memberof proto.STPStatus.ScoredPlay
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ScoredPlay.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.STPStatus.ScoredPlay";
            };

            return ScoredPlay;
        })();

        return STPStatus;
    })();

    proto.RuntimeConfig = (function() {

        /**
         * Properties of a RuntimeConfig.
         * @memberof proto
         * @interface IRuntimeConfig
         * @property {boolean|null} [useReferee] RuntimeConfig useReferee
         * @property {boolean|null} [ignoreInvariants] RuntimeConfig ignoreInvariants
         */

        /**
         * Constructs a new RuntimeConfig.
         * @memberof proto
         * @classdesc Represents a RuntimeConfig.
         * @implements IRuntimeConfig
         * @constructor
         * @param {proto.IRuntimeConfig=} [properties] Properties to set
         */
        function RuntimeConfig(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RuntimeConfig useReferee.
         * @member {boolean} useReferee
         * @memberof proto.RuntimeConfig
         * @instance
         */
        RuntimeConfig.prototype.useReferee = false;

        /**
         * RuntimeConfig ignoreInvariants.
         * @member {boolean} ignoreInvariants
         * @memberof proto.RuntimeConfig
         * @instance
         */
        RuntimeConfig.prototype.ignoreInvariants = false;

        /**
         * Creates a new RuntimeConfig instance using the specified properties.
         * @function create
         * @memberof proto.RuntimeConfig
         * @static
         * @param {proto.IRuntimeConfig=} [properties] Properties to set
         * @returns {proto.RuntimeConfig} RuntimeConfig instance
         */
        RuntimeConfig.create = function create(properties) {
            return new RuntimeConfig(properties);
        };

        /**
         * Encodes the specified RuntimeConfig message. Does not implicitly {@link proto.RuntimeConfig.verify|verify} messages.
         * @function encode
         * @memberof proto.RuntimeConfig
         * @static
         * @param {proto.IRuntimeConfig} message RuntimeConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RuntimeConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.useReferee != null && Object.hasOwnProperty.call(message, "useReferee"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.useReferee);
            if (message.ignoreInvariants != null && Object.hasOwnProperty.call(message, "ignoreInvariants"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ignoreInvariants);
            return writer;
        };

        /**
         * Encodes the specified RuntimeConfig message, length delimited. Does not implicitly {@link proto.RuntimeConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RuntimeConfig
         * @static
         * @param {proto.IRuntimeConfig} message RuntimeConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RuntimeConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RuntimeConfig message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RuntimeConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RuntimeConfig} RuntimeConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RuntimeConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RuntimeConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.useReferee = reader.bool();
                        break;
                    }
                case 2: {
                        message.ignoreInvariants = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RuntimeConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RuntimeConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RuntimeConfig} RuntimeConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RuntimeConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RuntimeConfig message.
         * @function verify
         * @memberof proto.RuntimeConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RuntimeConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.useReferee != null && message.hasOwnProperty("useReferee"))
                if (typeof message.useReferee !== "boolean")
                    return "useReferee: boolean expected";
            if (message.ignoreInvariants != null && message.hasOwnProperty("ignoreInvariants"))
                if (typeof message.ignoreInvariants !== "boolean")
                    return "ignoreInvariants: boolean expected";
            return null;
        };

        /**
         * Creates a RuntimeConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RuntimeConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RuntimeConfig} RuntimeConfig
         */
        RuntimeConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RuntimeConfig)
                return object;
            let message = new $root.proto.RuntimeConfig();
            if (object.useReferee != null)
                message.useReferee = Boolean(object.useReferee);
            if (object.ignoreInvariants != null)
                message.ignoreInvariants = Boolean(object.ignoreInvariants);
            return message;
        };

        /**
         * Creates a plain object from a RuntimeConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RuntimeConfig
         * @static
         * @param {proto.RuntimeConfig} message RuntimeConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RuntimeConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.useReferee = false;
                object.ignoreInvariants = false;
            }
            if (message.useReferee != null && message.hasOwnProperty("useReferee"))
                object.useReferee = message.useReferee;
            if (message.ignoreInvariants != null && message.hasOwnProperty("ignoreInvariants"))
                object.ignoreInvariants = message.ignoreInvariants;
            return object;
        };

        /**
         * Converts this RuntimeConfig to JSON.
         * @function toJSON
         * @memberof proto.RuntimeConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RuntimeConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RuntimeConfig
         * @function getTypeUrl
         * @memberof proto.RuntimeConfig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RuntimeConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RuntimeConfig";
        };

        return RuntimeConfig;
    })();

    proto.AIState = (function() {

        /**
         * Properties of a AIState.
         * @memberof proto
         * @interface IAIState
         * @property {boolean|null} [isPaused] AIState isPaused
         * @property {Array.<string>|null} [plays] AIState plays
         * @property {Array.<string>|null} [ruleSets] AIState ruleSets
         * @property {proto.IGameSettings|null} [gameSettings] AIState gameSettings
         * @property {proto.IRuntimeConfig|null} [runtimeConfig] AIState runtimeConfig
         */

        /**
         * Constructs a new AIState.
         * @memberof proto
         * @classdesc Represents a AIState.
         * @implements IAIState
         * @constructor
         * @param {proto.IAIState=} [properties] Properties to set
         */
        function AIState(properties) {
            this.plays = [];
            this.ruleSets = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AIState isPaused.
         * @member {boolean} isPaused
         * @memberof proto.AIState
         * @instance
         */
        AIState.prototype.isPaused = false;

        /**
         * AIState plays.
         * @member {Array.<string>} plays
         * @memberof proto.AIState
         * @instance
         */
        AIState.prototype.plays = $util.emptyArray;

        /**
         * AIState ruleSets.
         * @member {Array.<string>} ruleSets
         * @memberof proto.AIState
         * @instance
         */
        AIState.prototype.ruleSets = $util.emptyArray;

        /**
         * AIState gameSettings.
         * @member {proto.IGameSettings|null|undefined} gameSettings
         * @memberof proto.AIState
         * @instance
         */
        AIState.prototype.gameSettings = null;

        /**
         * AIState runtimeConfig.
         * @member {proto.IRuntimeConfig|null|undefined} runtimeConfig
         * @memberof proto.AIState
         * @instance
         */
        AIState.prototype.runtimeConfig = null;

        /**
         * Creates a new AIState instance using the specified properties.
         * @function create
         * @memberof proto.AIState
         * @static
         * @param {proto.IAIState=} [properties] Properties to set
         * @returns {proto.AIState} AIState instance
         */
        AIState.create = function create(properties) {
            return new AIState(properties);
        };

        /**
         * Encodes the specified AIState message. Does not implicitly {@link proto.AIState.verify|verify} messages.
         * @function encode
         * @memberof proto.AIState
         * @static
         * @param {proto.IAIState} message AIState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AIState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isPaused != null && Object.hasOwnProperty.call(message, "isPaused"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isPaused);
            if (message.plays != null && message.plays.length)
                for (let i = 0; i < message.plays.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.plays[i]);
            if (message.ruleSets != null && message.ruleSets.length)
                for (let i = 0; i < message.ruleSets.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.ruleSets[i]);
            if (message.gameSettings != null && Object.hasOwnProperty.call(message, "gameSettings"))
                $root.proto.GameSettings.encode(message.gameSettings, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.runtimeConfig != null && Object.hasOwnProperty.call(message, "runtimeConfig"))
                $root.proto.RuntimeConfig.encode(message.runtimeConfig, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AIState message, length delimited. Does not implicitly {@link proto.AIState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.AIState
         * @static
         * @param {proto.IAIState} message AIState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AIState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a AIState message from the specified reader or buffer.
         * @function decode
         * @memberof proto.AIState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.AIState} AIState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AIState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.AIState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.isPaused = reader.bool();
                        break;
                    }
                case 2: {
                        if (!(message.plays && message.plays.length))
                            message.plays = [];
                        message.plays.push(reader.string());
                        break;
                    }
                case 3: {
                        if (!(message.ruleSets && message.ruleSets.length))
                            message.ruleSets = [];
                        message.ruleSets.push(reader.string());
                        break;
                    }
                case 5: {
                        message.gameSettings = $root.proto.GameSettings.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.runtimeConfig = $root.proto.RuntimeConfig.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a AIState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.AIState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.AIState} AIState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AIState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a AIState message.
         * @function verify
         * @memberof proto.AIState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AIState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isPaused != null && message.hasOwnProperty("isPaused"))
                if (typeof message.isPaused !== "boolean")
                    return "isPaused: boolean expected";
            if (message.plays != null && message.hasOwnProperty("plays")) {
                if (!Array.isArray(message.plays))
                    return "plays: array expected";
                for (let i = 0; i < message.plays.length; ++i)
                    if (!$util.isString(message.plays[i]))
                        return "plays: string[] expected";
            }
            if (message.ruleSets != null && message.hasOwnProperty("ruleSets")) {
                if (!Array.isArray(message.ruleSets))
                    return "ruleSets: array expected";
                for (let i = 0; i < message.ruleSets.length; ++i)
                    if (!$util.isString(message.ruleSets[i]))
                        return "ruleSets: string[] expected";
            }
            if (message.gameSettings != null && message.hasOwnProperty("gameSettings")) {
                let error = $root.proto.GameSettings.verify(message.gameSettings);
                if (error)
                    return "gameSettings." + error;
            }
            if (message.runtimeConfig != null && message.hasOwnProperty("runtimeConfig")) {
                let error = $root.proto.RuntimeConfig.verify(message.runtimeConfig);
                if (error)
                    return "runtimeConfig." + error;
            }
            return null;
        };

        /**
         * Creates a AIState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.AIState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.AIState} AIState
         */
        AIState.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.AIState)
                return object;
            let message = new $root.proto.AIState();
            if (object.isPaused != null)
                message.isPaused = Boolean(object.isPaused);
            if (object.plays) {
                if (!Array.isArray(object.plays))
                    throw TypeError(".proto.AIState.plays: array expected");
                message.plays = [];
                for (let i = 0; i < object.plays.length; ++i)
                    message.plays[i] = String(object.plays[i]);
            }
            if (object.ruleSets) {
                if (!Array.isArray(object.ruleSets))
                    throw TypeError(".proto.AIState.ruleSets: array expected");
                message.ruleSets = [];
                for (let i = 0; i < object.ruleSets.length; ++i)
                    message.ruleSets[i] = String(object.ruleSets[i]);
            }
            if (object.gameSettings != null) {
                if (typeof object.gameSettings !== "object")
                    throw TypeError(".proto.AIState.gameSettings: object expected");
                message.gameSettings = $root.proto.GameSettings.fromObject(object.gameSettings);
            }
            if (object.runtimeConfig != null) {
                if (typeof object.runtimeConfig !== "object")
                    throw TypeError(".proto.AIState.runtimeConfig: object expected");
                message.runtimeConfig = $root.proto.RuntimeConfig.fromObject(object.runtimeConfig);
            }
            return message;
        };

        /**
         * Creates a plain object from a AIState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.AIState
         * @static
         * @param {proto.AIState} message AIState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AIState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.plays = [];
                object.ruleSets = [];
            }
            if (options.defaults) {
                object.isPaused = false;
                object.gameSettings = null;
                object.runtimeConfig = null;
            }
            if (message.isPaused != null && message.hasOwnProperty("isPaused"))
                object.isPaused = message.isPaused;
            if (message.plays && message.plays.length) {
                object.plays = [];
                for (let j = 0; j < message.plays.length; ++j)
                    object.plays[j] = message.plays[j];
            }
            if (message.ruleSets && message.ruleSets.length) {
                object.ruleSets = [];
                for (let j = 0; j < message.ruleSets.length; ++j)
                    object.ruleSets[j] = message.ruleSets[j];
            }
            if (message.gameSettings != null && message.hasOwnProperty("gameSettings"))
                object.gameSettings = $root.proto.GameSettings.toObject(message.gameSettings, options);
            if (message.runtimeConfig != null && message.hasOwnProperty("runtimeConfig"))
                object.runtimeConfig = $root.proto.RuntimeConfig.toObject(message.runtimeConfig, options);
            return object;
        };

        /**
         * Converts this AIState to JSON.
         * @function toJSON
         * @memberof proto.AIState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AIState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AIState
         * @function getTypeUrl
         * @memberof proto.AIState
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AIState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.AIState";
        };

        return AIState;
    })();

    proto.PlayInfo = (function() {

        /**
         * Properties of a PlayInfo.
         * @memberof proto
         * @interface IPlayInfo
         * @property {string|null} [playName] PlayInfo playName
         * @property {string|null} [rulesetName] PlayInfo rulesetName
         * @property {number|null} [keeperId] PlayInfo keeperId
         */

        /**
         * Constructs a new PlayInfo.
         * @memberof proto
         * @classdesc Represents a PlayInfo.
         * @implements IPlayInfo
         * @constructor
         * @param {proto.IPlayInfo=} [properties] Properties to set
         */
        function PlayInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayInfo playName.
         * @member {string} playName
         * @memberof proto.PlayInfo
         * @instance
         */
        PlayInfo.prototype.playName = "";

        /**
         * PlayInfo rulesetName.
         * @member {string} rulesetName
         * @memberof proto.PlayInfo
         * @instance
         */
        PlayInfo.prototype.rulesetName = "";

        /**
         * PlayInfo keeperId.
         * @member {number} keeperId
         * @memberof proto.PlayInfo
         * @instance
         */
        PlayInfo.prototype.keeperId = 0;

        /**
         * Creates a new PlayInfo instance using the specified properties.
         * @function create
         * @memberof proto.PlayInfo
         * @static
         * @param {proto.IPlayInfo=} [properties] Properties to set
         * @returns {proto.PlayInfo} PlayInfo instance
         */
        PlayInfo.create = function create(properties) {
            return new PlayInfo(properties);
        };

        /**
         * Encodes the specified PlayInfo message. Does not implicitly {@link proto.PlayInfo.verify|verify} messages.
         * @function encode
         * @memberof proto.PlayInfo
         * @static
         * @param {proto.IPlayInfo} message PlayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.playName != null && Object.hasOwnProperty.call(message, "playName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.playName);
            if (message.rulesetName != null && Object.hasOwnProperty.call(message, "rulesetName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.rulesetName);
            if (message.keeperId != null && Object.hasOwnProperty.call(message, "keeperId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.keeperId);
            return writer;
        };

        /**
         * Encodes the specified PlayInfo message, length delimited. Does not implicitly {@link proto.PlayInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.PlayInfo
         * @static
         * @param {proto.IPlayInfo} message PlayInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayInfo message from the specified reader or buffer.
         * @function decode
         * @memberof proto.PlayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.PlayInfo} PlayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.PlayInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.playName = reader.string();
                        break;
                    }
                case 2: {
                        message.rulesetName = reader.string();
                        break;
                    }
                case 3: {
                        message.keeperId = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.PlayInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.PlayInfo} PlayInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayInfo message.
         * @function verify
         * @memberof proto.PlayInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.playName != null && message.hasOwnProperty("playName"))
                if (!$util.isString(message.playName))
                    return "playName: string expected";
            if (message.rulesetName != null && message.hasOwnProperty("rulesetName"))
                if (!$util.isString(message.rulesetName))
                    return "rulesetName: string expected";
            if (message.keeperId != null && message.hasOwnProperty("keeperId"))
                if (!$util.isInteger(message.keeperId))
                    return "keeperId: integer expected";
            return null;
        };

        /**
         * Creates a PlayInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.PlayInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.PlayInfo} PlayInfo
         */
        PlayInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.PlayInfo)
                return object;
            let message = new $root.proto.PlayInfo();
            if (object.playName != null)
                message.playName = String(object.playName);
            if (object.rulesetName != null)
                message.rulesetName = String(object.rulesetName);
            if (object.keeperId != null)
                message.keeperId = object.keeperId | 0;
            return message;
        };

        /**
         * Creates a plain object from a PlayInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.PlayInfo
         * @static
         * @param {proto.PlayInfo} message PlayInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.playName = "";
                object.rulesetName = "";
                object.keeperId = 0;
            }
            if (message.playName != null && message.hasOwnProperty("playName"))
                object.playName = message.playName;
            if (message.rulesetName != null && message.hasOwnProperty("rulesetName"))
                object.rulesetName = message.rulesetName;
            if (message.keeperId != null && message.hasOwnProperty("keeperId"))
                object.keeperId = message.keeperId;
            return object;
        };

        /**
         * Converts this PlayInfo to JSON.
         * @function toJSON
         * @memberof proto.PlayInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PlayInfo
         * @function getTypeUrl
         * @memberof proto.PlayInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PlayInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.PlayInfo";
        };

        return PlayInfo;
    })();

    proto.MsgToInterface = (function() {

        /**
         * Properties of a MsgToInterface.
         * @memberof proto
         * @interface IMsgToInterface
         * @property {proto.ISTPStatus|null} [stpStatus] MsgToInterface stpStatus
         * @property {proto.IAIState|null} [aiState] MsgToInterface aiState
         * @property {proto.IState|null} [state] MsgToInterface state
         * @property {proto.MsgToInterface.IVisualizationBuffer|null} [visualizations] MsgToInterface visualizations
         */

        /**
         * Constructs a new MsgToInterface.
         * @memberof proto
         * @classdesc Represents a MsgToInterface.
         * @implements IMsgToInterface
         * @constructor
         * @param {proto.IMsgToInterface=} [properties] Properties to set
         */
        function MsgToInterface(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgToInterface stpStatus.
         * @member {proto.ISTPStatus|null|undefined} stpStatus
         * @memberof proto.MsgToInterface
         * @instance
         */
        MsgToInterface.prototype.stpStatus = null;

        /**
         * MsgToInterface aiState.
         * @member {proto.IAIState|null|undefined} aiState
         * @memberof proto.MsgToInterface
         * @instance
         */
        MsgToInterface.prototype.aiState = null;

        /**
         * MsgToInterface state.
         * @member {proto.IState|null|undefined} state
         * @memberof proto.MsgToInterface
         * @instance
         */
        MsgToInterface.prototype.state = null;

        /**
         * MsgToInterface visualizations.
         * @member {proto.MsgToInterface.IVisualizationBuffer|null|undefined} visualizations
         * @memberof proto.MsgToInterface
         * @instance
         */
        MsgToInterface.prototype.visualizations = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * MsgToInterface kind.
         * @member {"stpStatus"|"aiState"|"state"|"visualizations"|undefined} kind
         * @memberof proto.MsgToInterface
         * @instance
         */
        Object.defineProperty(MsgToInterface.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["stpStatus", "aiState", "state", "visualizations"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new MsgToInterface instance using the specified properties.
         * @function create
         * @memberof proto.MsgToInterface
         * @static
         * @param {proto.IMsgToInterface=} [properties] Properties to set
         * @returns {proto.MsgToInterface} MsgToInterface instance
         */
        MsgToInterface.create = function create(properties) {
            return new MsgToInterface(properties);
        };

        /**
         * Encodes the specified MsgToInterface message. Does not implicitly {@link proto.MsgToInterface.verify|verify} messages.
         * @function encode
         * @memberof proto.MsgToInterface
         * @static
         * @param {proto.IMsgToInterface} message MsgToInterface message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgToInterface.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stpStatus != null && Object.hasOwnProperty.call(message, "stpStatus"))
                $root.proto.STPStatus.encode(message.stpStatus, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.aiState != null && Object.hasOwnProperty.call(message, "aiState"))
                $root.proto.AIState.encode(message.aiState, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                $root.proto.State.encode(message.state, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.visualizations != null && Object.hasOwnProperty.call(message, "visualizations"))
                $root.proto.MsgToInterface.VisualizationBuffer.encode(message.visualizations, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MsgToInterface message, length delimited. Does not implicitly {@link proto.MsgToInterface.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.MsgToInterface
         * @static
         * @param {proto.IMsgToInterface} message MsgToInterface message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgToInterface.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgToInterface message from the specified reader or buffer.
         * @function decode
         * @memberof proto.MsgToInterface
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.MsgToInterface} MsgToInterface
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgToInterface.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MsgToInterface();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.stpStatus = $root.proto.STPStatus.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.aiState = $root.proto.AIState.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.state = $root.proto.State.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.visualizations = $root.proto.MsgToInterface.VisualizationBuffer.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MsgToInterface message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.MsgToInterface
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.MsgToInterface} MsgToInterface
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgToInterface.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgToInterface message.
         * @function verify
         * @memberof proto.MsgToInterface
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgToInterface.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.stpStatus != null && message.hasOwnProperty("stpStatus")) {
                properties.kind = 1;
                {
                    let error = $root.proto.STPStatus.verify(message.stpStatus);
                    if (error)
                        return "stpStatus." + error;
                }
            }
            if (message.aiState != null && message.hasOwnProperty("aiState")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    let error = $root.proto.AIState.verify(message.aiState);
                    if (error)
                        return "aiState." + error;
                }
            }
            if (message.state != null && message.hasOwnProperty("state")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    let error = $root.proto.State.verify(message.state);
                    if (error)
                        return "state." + error;
                }
            }
            if (message.visualizations != null && message.hasOwnProperty("visualizations")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    let error = $root.proto.MsgToInterface.VisualizationBuffer.verify(message.visualizations);
                    if (error)
                        return "visualizations." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MsgToInterface message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.MsgToInterface
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.MsgToInterface} MsgToInterface
         */
        MsgToInterface.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.MsgToInterface)
                return object;
            let message = new $root.proto.MsgToInterface();
            if (object.stpStatus != null) {
                if (typeof object.stpStatus !== "object")
                    throw TypeError(".proto.MsgToInterface.stpStatus: object expected");
                message.stpStatus = $root.proto.STPStatus.fromObject(object.stpStatus);
            }
            if (object.aiState != null) {
                if (typeof object.aiState !== "object")
                    throw TypeError(".proto.MsgToInterface.aiState: object expected");
                message.aiState = $root.proto.AIState.fromObject(object.aiState);
            }
            if (object.state != null) {
                if (typeof object.state !== "object")
                    throw TypeError(".proto.MsgToInterface.state: object expected");
                message.state = $root.proto.State.fromObject(object.state);
            }
            if (object.visualizations != null) {
                if (typeof object.visualizations !== "object")
                    throw TypeError(".proto.MsgToInterface.visualizations: object expected");
                message.visualizations = $root.proto.MsgToInterface.VisualizationBuffer.fromObject(object.visualizations);
            }
            return message;
        };

        /**
         * Creates a plain object from a MsgToInterface message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.MsgToInterface
         * @static
         * @param {proto.MsgToInterface} message MsgToInterface
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgToInterface.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.stpStatus != null && message.hasOwnProperty("stpStatus")) {
                object.stpStatus = $root.proto.STPStatus.toObject(message.stpStatus, options);
                if (options.oneofs)
                    object.kind = "stpStatus";
            }
            if (message.aiState != null && message.hasOwnProperty("aiState")) {
                object.aiState = $root.proto.AIState.toObject(message.aiState, options);
                if (options.oneofs)
                    object.kind = "aiState";
            }
            if (message.state != null && message.hasOwnProperty("state")) {
                object.state = $root.proto.State.toObject(message.state, options);
                if (options.oneofs)
                    object.kind = "state";
            }
            if (message.visualizations != null && message.hasOwnProperty("visualizations")) {
                object.visualizations = $root.proto.MsgToInterface.VisualizationBuffer.toObject(message.visualizations, options);
                if (options.oneofs)
                    object.kind = "visualizations";
            }
            return object;
        };

        /**
         * Converts this MsgToInterface to JSON.
         * @function toJSON
         * @memberof proto.MsgToInterface
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgToInterface.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MsgToInterface
         * @function getTypeUrl
         * @memberof proto.MsgToInterface
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MsgToInterface.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.MsgToInterface";
        };

        MsgToInterface.VisualizationBuffer = (function() {

            /**
             * Properties of a VisualizationBuffer.
             * @memberof proto.MsgToInterface
             * @interface IVisualizationBuffer
             * @property {Array.<proto.IDrawing>|null} [drawings] VisualizationBuffer drawings
             * @property {Array.<proto.IMetric>|null} [metrics] VisualizationBuffer metrics
             */

            /**
             * Constructs a new VisualizationBuffer.
             * @memberof proto.MsgToInterface
             * @classdesc Represents a VisualizationBuffer.
             * @implements IVisualizationBuffer
             * @constructor
             * @param {proto.MsgToInterface.IVisualizationBuffer=} [properties] Properties to set
             */
            function VisualizationBuffer(properties) {
                this.drawings = [];
                this.metrics = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VisualizationBuffer drawings.
             * @member {Array.<proto.IDrawing>} drawings
             * @memberof proto.MsgToInterface.VisualizationBuffer
             * @instance
             */
            VisualizationBuffer.prototype.drawings = $util.emptyArray;

            /**
             * VisualizationBuffer metrics.
             * @member {Array.<proto.IMetric>} metrics
             * @memberof proto.MsgToInterface.VisualizationBuffer
             * @instance
             */
            VisualizationBuffer.prototype.metrics = $util.emptyArray;

            /**
             * Creates a new VisualizationBuffer instance using the specified properties.
             * @function create
             * @memberof proto.MsgToInterface.VisualizationBuffer
             * @static
             * @param {proto.MsgToInterface.IVisualizationBuffer=} [properties] Properties to set
             * @returns {proto.MsgToInterface.VisualizationBuffer} VisualizationBuffer instance
             */
            VisualizationBuffer.create = function create(properties) {
                return new VisualizationBuffer(properties);
            };

            /**
             * Encodes the specified VisualizationBuffer message. Does not implicitly {@link proto.MsgToInterface.VisualizationBuffer.verify|verify} messages.
             * @function encode
             * @memberof proto.MsgToInterface.VisualizationBuffer
             * @static
             * @param {proto.MsgToInterface.IVisualizationBuffer} message VisualizationBuffer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VisualizationBuffer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.drawings != null && message.drawings.length)
                    for (let i = 0; i < message.drawings.length; ++i)
                        $root.proto.Drawing.encode(message.drawings[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.metrics != null && message.metrics.length)
                    for (let i = 0; i < message.metrics.length; ++i)
                        $root.proto.Metric.encode(message.metrics[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified VisualizationBuffer message, length delimited. Does not implicitly {@link proto.MsgToInterface.VisualizationBuffer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof proto.MsgToInterface.VisualizationBuffer
             * @static
             * @param {proto.MsgToInterface.IVisualizationBuffer} message VisualizationBuffer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VisualizationBuffer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VisualizationBuffer message from the specified reader or buffer.
             * @function decode
             * @memberof proto.MsgToInterface.VisualizationBuffer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {proto.MsgToInterface.VisualizationBuffer} VisualizationBuffer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VisualizationBuffer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MsgToInterface.VisualizationBuffer();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.drawings && message.drawings.length))
                                message.drawings = [];
                            message.drawings.push($root.proto.Drawing.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.metrics && message.metrics.length))
                                message.metrics = [];
                            message.metrics.push($root.proto.Metric.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VisualizationBuffer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof proto.MsgToInterface.VisualizationBuffer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {proto.MsgToInterface.VisualizationBuffer} VisualizationBuffer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VisualizationBuffer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VisualizationBuffer message.
             * @function verify
             * @memberof proto.MsgToInterface.VisualizationBuffer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VisualizationBuffer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.drawings != null && message.hasOwnProperty("drawings")) {
                    if (!Array.isArray(message.drawings))
                        return "drawings: array expected";
                    for (let i = 0; i < message.drawings.length; ++i) {
                        let error = $root.proto.Drawing.verify(message.drawings[i]);
                        if (error)
                            return "drawings." + error;
                    }
                }
                if (message.metrics != null && message.hasOwnProperty("metrics")) {
                    if (!Array.isArray(message.metrics))
                        return "metrics: array expected";
                    for (let i = 0; i < message.metrics.length; ++i) {
                        let error = $root.proto.Metric.verify(message.metrics[i]);
                        if (error)
                            return "metrics." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a VisualizationBuffer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof proto.MsgToInterface.VisualizationBuffer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {proto.MsgToInterface.VisualizationBuffer} VisualizationBuffer
             */
            VisualizationBuffer.fromObject = function fromObject(object) {
                if (object instanceof $root.proto.MsgToInterface.VisualizationBuffer)
                    return object;
                let message = new $root.proto.MsgToInterface.VisualizationBuffer();
                if (object.drawings) {
                    if (!Array.isArray(object.drawings))
                        throw TypeError(".proto.MsgToInterface.VisualizationBuffer.drawings: array expected");
                    message.drawings = [];
                    for (let i = 0; i < object.drawings.length; ++i) {
                        if (typeof object.drawings[i] !== "object")
                            throw TypeError(".proto.MsgToInterface.VisualizationBuffer.drawings: object expected");
                        message.drawings[i] = $root.proto.Drawing.fromObject(object.drawings[i]);
                    }
                }
                if (object.metrics) {
                    if (!Array.isArray(object.metrics))
                        throw TypeError(".proto.MsgToInterface.VisualizationBuffer.metrics: array expected");
                    message.metrics = [];
                    for (let i = 0; i < object.metrics.length; ++i) {
                        if (typeof object.metrics[i] !== "object")
                            throw TypeError(".proto.MsgToInterface.VisualizationBuffer.metrics: object expected");
                        message.metrics[i] = $root.proto.Metric.fromObject(object.metrics[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a VisualizationBuffer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof proto.MsgToInterface.VisualizationBuffer
             * @static
             * @param {proto.MsgToInterface.VisualizationBuffer} message VisualizationBuffer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VisualizationBuffer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.drawings = [];
                    object.metrics = [];
                }
                if (message.drawings && message.drawings.length) {
                    object.drawings = [];
                    for (let j = 0; j < message.drawings.length; ++j)
                        object.drawings[j] = $root.proto.Drawing.toObject(message.drawings[j], options);
                }
                if (message.metrics && message.metrics.length) {
                    object.metrics = [];
                    for (let j = 0; j < message.metrics.length; ++j)
                        object.metrics[j] = $root.proto.Metric.toObject(message.metrics[j], options);
                }
                return object;
            };

            /**
             * Converts this VisualizationBuffer to JSON.
             * @function toJSON
             * @memberof proto.MsgToInterface.VisualizationBuffer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VisualizationBuffer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VisualizationBuffer
             * @function getTypeUrl
             * @memberof proto.MsgToInterface.VisualizationBuffer
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VisualizationBuffer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/proto.MsgToInterface.VisualizationBuffer";
            };

            return VisualizationBuffer;
        })();

        return MsgToInterface;
    })();

    proto.MsgFromInterface = (function() {

        /**
         * Properties of a MsgFromInterface.
         * @memberof proto
         * @interface IMsgFromInterface
         * @property {proto.IPlayInfo|null} [setPlay] MsgFromInterface setPlay
         * @property {proto.IGameSettings|null} [setGameSettings] MsgFromInterface setGameSettings
         * @property {proto.IRuntimeConfig|null} [setRuntimeConfig] MsgFromInterface setRuntimeConfig
         * @property {boolean|null} [pauseAi] MsgFromInterface pauseAi
         * @property {proto.IVector2f|null} [setBallPos] MsgFromInterface setBallPos
         * @property {ISimulatorCommand|null} [simulatorCommand] MsgFromInterface simulatorCommand
         */

        /**
         * Constructs a new MsgFromInterface.
         * @memberof proto
         * @classdesc Represents a MsgFromInterface.
         * @implements IMsgFromInterface
         * @constructor
         * @param {proto.IMsgFromInterface=} [properties] Properties to set
         */
        function MsgFromInterface(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MsgFromInterface setPlay.
         * @member {proto.IPlayInfo|null|undefined} setPlay
         * @memberof proto.MsgFromInterface
         * @instance
         */
        MsgFromInterface.prototype.setPlay = null;

        /**
         * MsgFromInterface setGameSettings.
         * @member {proto.IGameSettings|null|undefined} setGameSettings
         * @memberof proto.MsgFromInterface
         * @instance
         */
        MsgFromInterface.prototype.setGameSettings = null;

        /**
         * MsgFromInterface setRuntimeConfig.
         * @member {proto.IRuntimeConfig|null|undefined} setRuntimeConfig
         * @memberof proto.MsgFromInterface
         * @instance
         */
        MsgFromInterface.prototype.setRuntimeConfig = null;

        /**
         * MsgFromInterface pauseAi.
         * @member {boolean|null|undefined} pauseAi
         * @memberof proto.MsgFromInterface
         * @instance
         */
        MsgFromInterface.prototype.pauseAi = null;

        /**
         * MsgFromInterface setBallPos.
         * @member {proto.IVector2f|null|undefined} setBallPos
         * @memberof proto.MsgFromInterface
         * @instance
         */
        MsgFromInterface.prototype.setBallPos = null;

        /**
         * MsgFromInterface simulatorCommand.
         * @member {ISimulatorCommand|null|undefined} simulatorCommand
         * @memberof proto.MsgFromInterface
         * @instance
         */
        MsgFromInterface.prototype.simulatorCommand = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * MsgFromInterface kind.
         * @member {"setPlay"|"setGameSettings"|"setRuntimeConfig"|"pauseAi"|"setBallPos"|"simulatorCommand"|undefined} kind
         * @memberof proto.MsgFromInterface
         * @instance
         */
        Object.defineProperty(MsgFromInterface.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["setPlay", "setGameSettings", "setRuntimeConfig", "pauseAi", "setBallPos", "simulatorCommand"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new MsgFromInterface instance using the specified properties.
         * @function create
         * @memberof proto.MsgFromInterface
         * @static
         * @param {proto.IMsgFromInterface=} [properties] Properties to set
         * @returns {proto.MsgFromInterface} MsgFromInterface instance
         */
        MsgFromInterface.create = function create(properties) {
            return new MsgFromInterface(properties);
        };

        /**
         * Encodes the specified MsgFromInterface message. Does not implicitly {@link proto.MsgFromInterface.verify|verify} messages.
         * @function encode
         * @memberof proto.MsgFromInterface
         * @static
         * @param {proto.IMsgFromInterface} message MsgFromInterface message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgFromInterface.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.setPlay != null && Object.hasOwnProperty.call(message, "setPlay"))
                $root.proto.PlayInfo.encode(message.setPlay, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.setGameSettings != null && Object.hasOwnProperty.call(message, "setGameSettings"))
                $root.proto.GameSettings.encode(message.setGameSettings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.setRuntimeConfig != null && Object.hasOwnProperty.call(message, "setRuntimeConfig"))
                $root.proto.RuntimeConfig.encode(message.setRuntimeConfig, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.pauseAi != null && Object.hasOwnProperty.call(message, "pauseAi"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.pauseAi);
            if (message.setBallPos != null && Object.hasOwnProperty.call(message, "setBallPos"))
                $root.proto.Vector2f.encode(message.setBallPos, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.simulatorCommand != null && Object.hasOwnProperty.call(message, "simulatorCommand"))
                $root.SimulatorCommand.encode(message.simulatorCommand, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MsgFromInterface message, length delimited. Does not implicitly {@link proto.MsgFromInterface.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.MsgFromInterface
         * @static
         * @param {proto.IMsgFromInterface} message MsgFromInterface message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MsgFromInterface.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MsgFromInterface message from the specified reader or buffer.
         * @function decode
         * @memberof proto.MsgFromInterface
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.MsgFromInterface} MsgFromInterface
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgFromInterface.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.MsgFromInterface();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.setPlay = $root.proto.PlayInfo.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.setGameSettings = $root.proto.GameSettings.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.setRuntimeConfig = $root.proto.RuntimeConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.pauseAi = reader.bool();
                        break;
                    }
                case 5: {
                        message.setBallPos = $root.proto.Vector2f.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.simulatorCommand = $root.SimulatorCommand.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MsgFromInterface message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.MsgFromInterface
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.MsgFromInterface} MsgFromInterface
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MsgFromInterface.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MsgFromInterface message.
         * @function verify
         * @memberof proto.MsgFromInterface
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MsgFromInterface.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.setPlay != null && message.hasOwnProperty("setPlay")) {
                properties.kind = 1;
                {
                    let error = $root.proto.PlayInfo.verify(message.setPlay);
                    if (error)
                        return "setPlay." + error;
                }
            }
            if (message.setGameSettings != null && message.hasOwnProperty("setGameSettings")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    let error = $root.proto.GameSettings.verify(message.setGameSettings);
                    if (error)
                        return "setGameSettings." + error;
                }
            }
            if (message.setRuntimeConfig != null && message.hasOwnProperty("setRuntimeConfig")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    let error = $root.proto.RuntimeConfig.verify(message.setRuntimeConfig);
                    if (error)
                        return "setRuntimeConfig." + error;
                }
            }
            if (message.pauseAi != null && message.hasOwnProperty("pauseAi")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (typeof message.pauseAi !== "boolean")
                    return "pauseAi: boolean expected";
            }
            if (message.setBallPos != null && message.hasOwnProperty("setBallPos")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    let error = $root.proto.Vector2f.verify(message.setBallPos);
                    if (error)
                        return "setBallPos." + error;
                }
            }
            if (message.simulatorCommand != null && message.hasOwnProperty("simulatorCommand")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    let error = $root.SimulatorCommand.verify(message.simulatorCommand);
                    if (error)
                        return "simulatorCommand." + error;
                }
            }
            return null;
        };

        /**
         * Creates a MsgFromInterface message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.MsgFromInterface
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.MsgFromInterface} MsgFromInterface
         */
        MsgFromInterface.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.MsgFromInterface)
                return object;
            let message = new $root.proto.MsgFromInterface();
            if (object.setPlay != null) {
                if (typeof object.setPlay !== "object")
                    throw TypeError(".proto.MsgFromInterface.setPlay: object expected");
                message.setPlay = $root.proto.PlayInfo.fromObject(object.setPlay);
            }
            if (object.setGameSettings != null) {
                if (typeof object.setGameSettings !== "object")
                    throw TypeError(".proto.MsgFromInterface.setGameSettings: object expected");
                message.setGameSettings = $root.proto.GameSettings.fromObject(object.setGameSettings);
            }
            if (object.setRuntimeConfig != null) {
                if (typeof object.setRuntimeConfig !== "object")
                    throw TypeError(".proto.MsgFromInterface.setRuntimeConfig: object expected");
                message.setRuntimeConfig = $root.proto.RuntimeConfig.fromObject(object.setRuntimeConfig);
            }
            if (object.pauseAi != null)
                message.pauseAi = Boolean(object.pauseAi);
            if (object.setBallPos != null) {
                if (typeof object.setBallPos !== "object")
                    throw TypeError(".proto.MsgFromInterface.setBallPos: object expected");
                message.setBallPos = $root.proto.Vector2f.fromObject(object.setBallPos);
            }
            if (object.simulatorCommand != null) {
                if (typeof object.simulatorCommand !== "object")
                    throw TypeError(".proto.MsgFromInterface.simulatorCommand: object expected");
                message.simulatorCommand = $root.SimulatorCommand.fromObject(object.simulatorCommand);
            }
            return message;
        };

        /**
         * Creates a plain object from a MsgFromInterface message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.MsgFromInterface
         * @static
         * @param {proto.MsgFromInterface} message MsgFromInterface
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MsgFromInterface.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.setPlay != null && message.hasOwnProperty("setPlay")) {
                object.setPlay = $root.proto.PlayInfo.toObject(message.setPlay, options);
                if (options.oneofs)
                    object.kind = "setPlay";
            }
            if (message.setGameSettings != null && message.hasOwnProperty("setGameSettings")) {
                object.setGameSettings = $root.proto.GameSettings.toObject(message.setGameSettings, options);
                if (options.oneofs)
                    object.kind = "setGameSettings";
            }
            if (message.setRuntimeConfig != null && message.hasOwnProperty("setRuntimeConfig")) {
                object.setRuntimeConfig = $root.proto.RuntimeConfig.toObject(message.setRuntimeConfig, options);
                if (options.oneofs)
                    object.kind = "setRuntimeConfig";
            }
            if (message.pauseAi != null && message.hasOwnProperty("pauseAi")) {
                object.pauseAi = message.pauseAi;
                if (options.oneofs)
                    object.kind = "pauseAi";
            }
            if (message.setBallPos != null && message.hasOwnProperty("setBallPos")) {
                object.setBallPos = $root.proto.Vector2f.toObject(message.setBallPos, options);
                if (options.oneofs)
                    object.kind = "setBallPos";
            }
            if (message.simulatorCommand != null && message.hasOwnProperty("simulatorCommand")) {
                object.simulatorCommand = $root.SimulatorCommand.toObject(message.simulatorCommand, options);
                if (options.oneofs)
                    object.kind = "simulatorCommand";
            }
            return object;
        };

        /**
         * Converts this MsgFromInterface to JSON.
         * @function toJSON
         * @memberof proto.MsgFromInterface
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MsgFromInterface.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MsgFromInterface
         * @function getTypeUrl
         * @memberof proto.MsgFromInterface
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MsgFromInterface.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.MsgFromInterface";
        };

        return MsgFromInterface;
    })();

    proto.World = (function() {

        /**
         * Properties of a World.
         * @memberof proto
         * @interface IWorld
         * @property {number|Long|null} [time] World time
         * @property {number|null} [id] World id
         * @property {proto.IWorldBall|null} [ball] World ball
         * @property {Array.<proto.IWorldRobot>|null} [yellow] World yellow
         * @property {Array.<proto.IWorldRobot>|null} [blue] World blue
         * @property {Array.<proto.IFeedbackOnlyRobot>|null} [yellowUnseenRobots] World yellowUnseenRobots
         * @property {Array.<proto.IFeedbackOnlyRobot>|null} [blueUnseenRobots] World blueUnseenRobots
         */

        /**
         * Constructs a new World.
         * @memberof proto
         * @classdesc Represents a World.
         * @implements IWorld
         * @constructor
         * @param {proto.IWorld=} [properties] Properties to set
         */
        function World(properties) {
            this.yellow = [];
            this.blue = [];
            this.yellowUnseenRobots = [];
            this.blueUnseenRobots = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * World time.
         * @member {number|Long} time
         * @memberof proto.World
         * @instance
         */
        World.prototype.time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * World id.
         * @member {number} id
         * @memberof proto.World
         * @instance
         */
        World.prototype.id = 0;

        /**
         * World ball.
         * @member {proto.IWorldBall|null|undefined} ball
         * @memberof proto.World
         * @instance
         */
        World.prototype.ball = null;

        /**
         * World yellow.
         * @member {Array.<proto.IWorldRobot>} yellow
         * @memberof proto.World
         * @instance
         */
        World.prototype.yellow = $util.emptyArray;

        /**
         * World blue.
         * @member {Array.<proto.IWorldRobot>} blue
         * @memberof proto.World
         * @instance
         */
        World.prototype.blue = $util.emptyArray;

        /**
         * World yellowUnseenRobots.
         * @member {Array.<proto.IFeedbackOnlyRobot>} yellowUnseenRobots
         * @memberof proto.World
         * @instance
         */
        World.prototype.yellowUnseenRobots = $util.emptyArray;

        /**
         * World blueUnseenRobots.
         * @member {Array.<proto.IFeedbackOnlyRobot>} blueUnseenRobots
         * @memberof proto.World
         * @instance
         */
        World.prototype.blueUnseenRobots = $util.emptyArray;

        /**
         * Creates a new World instance using the specified properties.
         * @function create
         * @memberof proto.World
         * @static
         * @param {proto.IWorld=} [properties] Properties to set
         * @returns {proto.World} World instance
         */
        World.create = function create(properties) {
            return new World(properties);
        };

        /**
         * Encodes the specified World message. Does not implicitly {@link proto.World.verify|verify} messages.
         * @function encode
         * @memberof proto.World
         * @static
         * @param {proto.IWorld} message World message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        World.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.time);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
            if (message.ball != null && Object.hasOwnProperty.call(message, "ball"))
                $root.proto.WorldBall.encode(message.ball, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.yellow != null && message.yellow.length)
                for (let i = 0; i < message.yellow.length; ++i)
                    $root.proto.WorldRobot.encode(message.yellow[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.blue != null && message.blue.length)
                for (let i = 0; i < message.blue.length; ++i)
                    $root.proto.WorldRobot.encode(message.blue[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.yellowUnseenRobots != null && message.yellowUnseenRobots.length)
                for (let i = 0; i < message.yellowUnseenRobots.length; ++i)
                    $root.proto.FeedbackOnlyRobot.encode(message.yellowUnseenRobots[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.blueUnseenRobots != null && message.blueUnseenRobots.length)
                for (let i = 0; i < message.blueUnseenRobots.length; ++i)
                    $root.proto.FeedbackOnlyRobot.encode(message.blueUnseenRobots[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified World message, length delimited. Does not implicitly {@link proto.World.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.World
         * @static
         * @param {proto.IWorld} message World message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        World.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a World message from the specified reader or buffer.
         * @function decode
         * @memberof proto.World
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.World} World
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        World.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.World();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.time = reader.uint64();
                        break;
                    }
                case 2: {
                        message.id = reader.uint32();
                        break;
                    }
                case 3: {
                        message.ball = $root.proto.WorldBall.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.yellow && message.yellow.length))
                            message.yellow = [];
                        message.yellow.push($root.proto.WorldRobot.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        if (!(message.blue && message.blue.length))
                            message.blue = [];
                        message.blue.push($root.proto.WorldRobot.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        if (!(message.yellowUnseenRobots && message.yellowUnseenRobots.length))
                            message.yellowUnseenRobots = [];
                        message.yellowUnseenRobots.push($root.proto.FeedbackOnlyRobot.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        if (!(message.blueUnseenRobots && message.blueUnseenRobots.length))
                            message.blueUnseenRobots = [];
                        message.blueUnseenRobots.push($root.proto.FeedbackOnlyRobot.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a World message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.World
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.World} World
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        World.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a World message.
         * @function verify
         * @memberof proto.World
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        World.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.ball != null && message.hasOwnProperty("ball")) {
                let error = $root.proto.WorldBall.verify(message.ball);
                if (error)
                    return "ball." + error;
            }
            if (message.yellow != null && message.hasOwnProperty("yellow")) {
                if (!Array.isArray(message.yellow))
                    return "yellow: array expected";
                for (let i = 0; i < message.yellow.length; ++i) {
                    let error = $root.proto.WorldRobot.verify(message.yellow[i]);
                    if (error)
                        return "yellow." + error;
                }
            }
            if (message.blue != null && message.hasOwnProperty("blue")) {
                if (!Array.isArray(message.blue))
                    return "blue: array expected";
                for (let i = 0; i < message.blue.length; ++i) {
                    let error = $root.proto.WorldRobot.verify(message.blue[i]);
                    if (error)
                        return "blue." + error;
                }
            }
            if (message.yellowUnseenRobots != null && message.hasOwnProperty("yellowUnseenRobots")) {
                if (!Array.isArray(message.yellowUnseenRobots))
                    return "yellowUnseenRobots: array expected";
                for (let i = 0; i < message.yellowUnseenRobots.length; ++i) {
                    let error = $root.proto.FeedbackOnlyRobot.verify(message.yellowUnseenRobots[i]);
                    if (error)
                        return "yellowUnseenRobots." + error;
                }
            }
            if (message.blueUnseenRobots != null && message.hasOwnProperty("blueUnseenRobots")) {
                if (!Array.isArray(message.blueUnseenRobots))
                    return "blueUnseenRobots: array expected";
                for (let i = 0; i < message.blueUnseenRobots.length; ++i) {
                    let error = $root.proto.FeedbackOnlyRobot.verify(message.blueUnseenRobots[i]);
                    if (error)
                        return "blueUnseenRobots." + error;
                }
            }
            return null;
        };

        /**
         * Creates a World message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.World
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.World} World
         */
        World.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.World)
                return object;
            let message = new $root.proto.World();
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = true;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber(true);
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.ball != null) {
                if (typeof object.ball !== "object")
                    throw TypeError(".proto.World.ball: object expected");
                message.ball = $root.proto.WorldBall.fromObject(object.ball);
            }
            if (object.yellow) {
                if (!Array.isArray(object.yellow))
                    throw TypeError(".proto.World.yellow: array expected");
                message.yellow = [];
                for (let i = 0; i < object.yellow.length; ++i) {
                    if (typeof object.yellow[i] !== "object")
                        throw TypeError(".proto.World.yellow: object expected");
                    message.yellow[i] = $root.proto.WorldRobot.fromObject(object.yellow[i]);
                }
            }
            if (object.blue) {
                if (!Array.isArray(object.blue))
                    throw TypeError(".proto.World.blue: array expected");
                message.blue = [];
                for (let i = 0; i < object.blue.length; ++i) {
                    if (typeof object.blue[i] !== "object")
                        throw TypeError(".proto.World.blue: object expected");
                    message.blue[i] = $root.proto.WorldRobot.fromObject(object.blue[i]);
                }
            }
            if (object.yellowUnseenRobots) {
                if (!Array.isArray(object.yellowUnseenRobots))
                    throw TypeError(".proto.World.yellowUnseenRobots: array expected");
                message.yellowUnseenRobots = [];
                for (let i = 0; i < object.yellowUnseenRobots.length; ++i) {
                    if (typeof object.yellowUnseenRobots[i] !== "object")
                        throw TypeError(".proto.World.yellowUnseenRobots: object expected");
                    message.yellowUnseenRobots[i] = $root.proto.FeedbackOnlyRobot.fromObject(object.yellowUnseenRobots[i]);
                }
            }
            if (object.blueUnseenRobots) {
                if (!Array.isArray(object.blueUnseenRobots))
                    throw TypeError(".proto.World.blueUnseenRobots: array expected");
                message.blueUnseenRobots = [];
                for (let i = 0; i < object.blueUnseenRobots.length; ++i) {
                    if (typeof object.blueUnseenRobots[i] !== "object")
                        throw TypeError(".proto.World.blueUnseenRobots: object expected");
                    message.blueUnseenRobots[i] = $root.proto.FeedbackOnlyRobot.fromObject(object.blueUnseenRobots[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a World message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.World
         * @static
         * @param {proto.World} message World
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        World.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.yellow = [];
                object.blue = [];
                object.yellowUnseenRobots = [];
                object.blueUnseenRobots = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
                object.id = 0;
                object.ball = null;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber(true) : message.time;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.ball != null && message.hasOwnProperty("ball"))
                object.ball = $root.proto.WorldBall.toObject(message.ball, options);
            if (message.yellow && message.yellow.length) {
                object.yellow = [];
                for (let j = 0; j < message.yellow.length; ++j)
                    object.yellow[j] = $root.proto.WorldRobot.toObject(message.yellow[j], options);
            }
            if (message.blue && message.blue.length) {
                object.blue = [];
                for (let j = 0; j < message.blue.length; ++j)
                    object.blue[j] = $root.proto.WorldRobot.toObject(message.blue[j], options);
            }
            if (message.yellowUnseenRobots && message.yellowUnseenRobots.length) {
                object.yellowUnseenRobots = [];
                for (let j = 0; j < message.yellowUnseenRobots.length; ++j)
                    object.yellowUnseenRobots[j] = $root.proto.FeedbackOnlyRobot.toObject(message.yellowUnseenRobots[j], options);
            }
            if (message.blueUnseenRobots && message.blueUnseenRobots.length) {
                object.blueUnseenRobots = [];
                for (let j = 0; j < message.blueUnseenRobots.length; ++j)
                    object.blueUnseenRobots[j] = $root.proto.FeedbackOnlyRobot.toObject(message.blueUnseenRobots[j], options);
            }
            return object;
        };

        /**
         * Converts this World to JSON.
         * @function toJSON
         * @memberof proto.World
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        World.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for World
         * @function getTypeUrl
         * @memberof proto.World
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        World.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.World";
        };

        return World;
    })();

    proto.WorldBall = (function() {

        /**
         * Properties of a WorldBall.
         * @memberof proto
         * @interface IWorldBall
         * @property {number|null} [area] WorldBall area
         * @property {proto.IVector2f|null} [pos] WorldBall pos
         * @property {number|null} [z] WorldBall z
         * @property {proto.IVector2f|null} [vel] WorldBall vel
         * @property {number|null} [zVel] WorldBall zVel
         * @property {boolean|null} [visible] WorldBall visible
         */

        /**
         * Constructs a new WorldBall.
         * @memberof proto
         * @classdesc Represents a WorldBall.
         * @implements IWorldBall
         * @constructor
         * @param {proto.IWorldBall=} [properties] Properties to set
         */
        function WorldBall(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WorldBall area.
         * @member {number} area
         * @memberof proto.WorldBall
         * @instance
         */
        WorldBall.prototype.area = 0;

        /**
         * WorldBall pos.
         * @member {proto.IVector2f|null|undefined} pos
         * @memberof proto.WorldBall
         * @instance
         */
        WorldBall.prototype.pos = null;

        /**
         * WorldBall z.
         * @member {number} z
         * @memberof proto.WorldBall
         * @instance
         */
        WorldBall.prototype.z = 0;

        /**
         * WorldBall vel.
         * @member {proto.IVector2f|null|undefined} vel
         * @memberof proto.WorldBall
         * @instance
         */
        WorldBall.prototype.vel = null;

        /**
         * WorldBall zVel.
         * @member {number} zVel
         * @memberof proto.WorldBall
         * @instance
         */
        WorldBall.prototype.zVel = 0;

        /**
         * WorldBall visible.
         * @member {boolean} visible
         * @memberof proto.WorldBall
         * @instance
         */
        WorldBall.prototype.visible = false;

        /**
         * Creates a new WorldBall instance using the specified properties.
         * @function create
         * @memberof proto.WorldBall
         * @static
         * @param {proto.IWorldBall=} [properties] Properties to set
         * @returns {proto.WorldBall} WorldBall instance
         */
        WorldBall.create = function create(properties) {
            return new WorldBall(properties);
        };

        /**
         * Encodes the specified WorldBall message. Does not implicitly {@link proto.WorldBall.verify|verify} messages.
         * @function encode
         * @memberof proto.WorldBall
         * @static
         * @param {proto.IWorldBall} message WorldBall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WorldBall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.area != null && Object.hasOwnProperty.call(message, "area"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.area);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.proto.Vector2f.encode(message.pos, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            if (message.vel != null && Object.hasOwnProperty.call(message, "vel"))
                $root.proto.Vector2f.encode(message.vel, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.zVel != null && Object.hasOwnProperty.call(message, "zVel"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.zVel);
            if (message.visible != null && Object.hasOwnProperty.call(message, "visible"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.visible);
            return writer;
        };

        /**
         * Encodes the specified WorldBall message, length delimited. Does not implicitly {@link proto.WorldBall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.WorldBall
         * @static
         * @param {proto.IWorldBall} message WorldBall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WorldBall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WorldBall message from the specified reader or buffer.
         * @function decode
         * @memberof proto.WorldBall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.WorldBall} WorldBall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WorldBall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.WorldBall();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.area = reader.uint32();
                        break;
                    }
                case 2: {
                        message.pos = $root.proto.Vector2f.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.z = reader.float();
                        break;
                    }
                case 4: {
                        message.vel = $root.proto.Vector2f.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.zVel = reader.float();
                        break;
                    }
                case 6: {
                        message.visible = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WorldBall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.WorldBall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.WorldBall} WorldBall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WorldBall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WorldBall message.
         * @function verify
         * @memberof proto.WorldBall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WorldBall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.area != null && message.hasOwnProperty("area"))
                if (!$util.isInteger(message.area))
                    return "area: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                let error = $root.proto.Vector2f.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            if (message.vel != null && message.hasOwnProperty("vel")) {
                let error = $root.proto.Vector2f.verify(message.vel);
                if (error)
                    return "vel." + error;
            }
            if (message.zVel != null && message.hasOwnProperty("zVel"))
                if (typeof message.zVel !== "number")
                    return "zVel: number expected";
            if (message.visible != null && message.hasOwnProperty("visible"))
                if (typeof message.visible !== "boolean")
                    return "visible: boolean expected";
            return null;
        };

        /**
         * Creates a WorldBall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.WorldBall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.WorldBall} WorldBall
         */
        WorldBall.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.WorldBall)
                return object;
            let message = new $root.proto.WorldBall();
            if (object.area != null)
                message.area = object.area >>> 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".proto.WorldBall.pos: object expected");
                message.pos = $root.proto.Vector2f.fromObject(object.pos);
            }
            if (object.z != null)
                message.z = Number(object.z);
            if (object.vel != null) {
                if (typeof object.vel !== "object")
                    throw TypeError(".proto.WorldBall.vel: object expected");
                message.vel = $root.proto.Vector2f.fromObject(object.vel);
            }
            if (object.zVel != null)
                message.zVel = Number(object.zVel);
            if (object.visible != null)
                message.visible = Boolean(object.visible);
            return message;
        };

        /**
         * Creates a plain object from a WorldBall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.WorldBall
         * @static
         * @param {proto.WorldBall} message WorldBall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WorldBall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.area = 0;
                object.pos = null;
                object.z = 0;
                object.vel = null;
                object.zVel = 0;
                object.visible = false;
            }
            if (message.area != null && message.hasOwnProperty("area"))
                object.area = message.area;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.proto.Vector2f.toObject(message.pos, options);
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            if (message.vel != null && message.hasOwnProperty("vel"))
                object.vel = $root.proto.Vector2f.toObject(message.vel, options);
            if (message.zVel != null && message.hasOwnProperty("zVel"))
                object.zVel = options.json && !isFinite(message.zVel) ? String(message.zVel) : message.zVel;
            if (message.visible != null && message.hasOwnProperty("visible"))
                object.visible = message.visible;
            return object;
        };

        /**
         * Converts this WorldBall to JSON.
         * @function toJSON
         * @memberof proto.WorldBall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WorldBall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for WorldBall
         * @function getTypeUrl
         * @memberof proto.WorldBall
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        WorldBall.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.WorldBall";
        };

        return WorldBall;
    })();

    proto.WorldRobot = (function() {

        /**
         * Properties of a WorldRobot.
         * @memberof proto
         * @interface IWorldRobot
         * @property {number|null} [id] WorldRobot id
         * @property {proto.IVector2f|null} [pos] WorldRobot pos
         * @property {number|null} [angle] WorldRobot angle
         * @property {proto.IVector2f|null} [vel] WorldRobot vel
         * @property {number|null} [w] WorldRobot w
         * @property {proto.IRobotProcessedFeedback|null} [feedbackInfo] WorldRobot feedbackInfo
         */

        /**
         * Constructs a new WorldRobot.
         * @memberof proto
         * @classdesc Represents a WorldRobot.
         * @implements IWorldRobot
         * @constructor
         * @param {proto.IWorldRobot=} [properties] Properties to set
         */
        function WorldRobot(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WorldRobot id.
         * @member {number} id
         * @memberof proto.WorldRobot
         * @instance
         */
        WorldRobot.prototype.id = 0;

        /**
         * WorldRobot pos.
         * @member {proto.IVector2f|null|undefined} pos
         * @memberof proto.WorldRobot
         * @instance
         */
        WorldRobot.prototype.pos = null;

        /**
         * WorldRobot angle.
         * @member {number} angle
         * @memberof proto.WorldRobot
         * @instance
         */
        WorldRobot.prototype.angle = 0;

        /**
         * WorldRobot vel.
         * @member {proto.IVector2f|null|undefined} vel
         * @memberof proto.WorldRobot
         * @instance
         */
        WorldRobot.prototype.vel = null;

        /**
         * WorldRobot w.
         * @member {number} w
         * @memberof proto.WorldRobot
         * @instance
         */
        WorldRobot.prototype.w = 0;

        /**
         * WorldRobot feedbackInfo.
         * @member {proto.IRobotProcessedFeedback|null|undefined} feedbackInfo
         * @memberof proto.WorldRobot
         * @instance
         */
        WorldRobot.prototype.feedbackInfo = null;

        /**
         * Creates a new WorldRobot instance using the specified properties.
         * @function create
         * @memberof proto.WorldRobot
         * @static
         * @param {proto.IWorldRobot=} [properties] Properties to set
         * @returns {proto.WorldRobot} WorldRobot instance
         */
        WorldRobot.create = function create(properties) {
            return new WorldRobot(properties);
        };

        /**
         * Encodes the specified WorldRobot message. Does not implicitly {@link proto.WorldRobot.verify|verify} messages.
         * @function encode
         * @memberof proto.WorldRobot
         * @static
         * @param {proto.IWorldRobot} message WorldRobot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WorldRobot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                $root.proto.Vector2f.encode(message.pos, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.angle);
            if (message.vel != null && Object.hasOwnProperty.call(message, "vel"))
                $root.proto.Vector2f.encode(message.vel, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.w != null && Object.hasOwnProperty.call(message, "w"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.w);
            if (message.feedbackInfo != null && Object.hasOwnProperty.call(message, "feedbackInfo"))
                $root.proto.RobotProcessedFeedback.encode(message.feedbackInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WorldRobot message, length delimited. Does not implicitly {@link proto.WorldRobot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.WorldRobot
         * @static
         * @param {proto.IWorldRobot} message WorldRobot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WorldRobot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WorldRobot message from the specified reader or buffer.
         * @function decode
         * @memberof proto.WorldRobot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.WorldRobot} WorldRobot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WorldRobot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.WorldRobot();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.pos = $root.proto.Vector2f.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.angle = reader.float();
                        break;
                    }
                case 4: {
                        message.vel = $root.proto.Vector2f.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.w = reader.float();
                        break;
                    }
                case 6: {
                        message.feedbackInfo = $root.proto.RobotProcessedFeedback.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WorldRobot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.WorldRobot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.WorldRobot} WorldRobot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WorldRobot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WorldRobot message.
         * @function verify
         * @memberof proto.WorldRobot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WorldRobot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                let error = $root.proto.Vector2f.verify(message.pos);
                if (error)
                    return "pos." + error;
            }
            if (message.angle != null && message.hasOwnProperty("angle"))
                if (typeof message.angle !== "number")
                    return "angle: number expected";
            if (message.vel != null && message.hasOwnProperty("vel")) {
                let error = $root.proto.Vector2f.verify(message.vel);
                if (error)
                    return "vel." + error;
            }
            if (message.w != null && message.hasOwnProperty("w"))
                if (typeof message.w !== "number")
                    return "w: number expected";
            if (message.feedbackInfo != null && message.hasOwnProperty("feedbackInfo")) {
                let error = $root.proto.RobotProcessedFeedback.verify(message.feedbackInfo);
                if (error)
                    return "feedbackInfo." + error;
            }
            return null;
        };

        /**
         * Creates a WorldRobot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.WorldRobot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.WorldRobot} WorldRobot
         */
        WorldRobot.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.WorldRobot)
                return object;
            let message = new $root.proto.WorldRobot();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.pos != null) {
                if (typeof object.pos !== "object")
                    throw TypeError(".proto.WorldRobot.pos: object expected");
                message.pos = $root.proto.Vector2f.fromObject(object.pos);
            }
            if (object.angle != null)
                message.angle = Number(object.angle);
            if (object.vel != null) {
                if (typeof object.vel !== "object")
                    throw TypeError(".proto.WorldRobot.vel: object expected");
                message.vel = $root.proto.Vector2f.fromObject(object.vel);
            }
            if (object.w != null)
                message.w = Number(object.w);
            if (object.feedbackInfo != null) {
                if (typeof object.feedbackInfo !== "object")
                    throw TypeError(".proto.WorldRobot.feedbackInfo: object expected");
                message.feedbackInfo = $root.proto.RobotProcessedFeedback.fromObject(object.feedbackInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a WorldRobot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.WorldRobot
         * @static
         * @param {proto.WorldRobot} message WorldRobot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WorldRobot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = 0;
                object.pos = null;
                object.angle = 0;
                object.vel = null;
                object.w = 0;
                object.feedbackInfo = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = $root.proto.Vector2f.toObject(message.pos, options);
            if (message.angle != null && message.hasOwnProperty("angle"))
                object.angle = options.json && !isFinite(message.angle) ? String(message.angle) : message.angle;
            if (message.vel != null && message.hasOwnProperty("vel"))
                object.vel = $root.proto.Vector2f.toObject(message.vel, options);
            if (message.w != null && message.hasOwnProperty("w"))
                object.w = options.json && !isFinite(message.w) ? String(message.w) : message.w;
            if (message.feedbackInfo != null && message.hasOwnProperty("feedbackInfo"))
                object.feedbackInfo = $root.proto.RobotProcessedFeedback.toObject(message.feedbackInfo, options);
            return object;
        };

        /**
         * Converts this WorldRobot to JSON.
         * @function toJSON
         * @memberof proto.WorldRobot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WorldRobot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for WorldRobot
         * @function getTypeUrl
         * @memberof proto.WorldRobot
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        WorldRobot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.WorldRobot";
        };

        return WorldRobot;
    })();

    proto.RobotWheel = (function() {

        /**
         * Properties of a RobotWheel.
         * @memberof proto
         * @interface IRobotWheel
         * @property {boolean|null} [locked] RobotWheel locked
         * @property {boolean|null} [braking] RobotWheel braking
         */

        /**
         * Constructs a new RobotWheel.
         * @memberof proto
         * @classdesc Represents a RobotWheel.
         * @implements IRobotWheel
         * @constructor
         * @param {proto.IRobotWheel=} [properties] Properties to set
         */
        function RobotWheel(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RobotWheel locked.
         * @member {boolean} locked
         * @memberof proto.RobotWheel
         * @instance
         */
        RobotWheel.prototype.locked = false;

        /**
         * RobotWheel braking.
         * @member {boolean} braking
         * @memberof proto.RobotWheel
         * @instance
         */
        RobotWheel.prototype.braking = false;

        /**
         * Creates a new RobotWheel instance using the specified properties.
         * @function create
         * @memberof proto.RobotWheel
         * @static
         * @param {proto.IRobotWheel=} [properties] Properties to set
         * @returns {proto.RobotWheel} RobotWheel instance
         */
        RobotWheel.create = function create(properties) {
            return new RobotWheel(properties);
        };

        /**
         * Encodes the specified RobotWheel message. Does not implicitly {@link proto.RobotWheel.verify|verify} messages.
         * @function encode
         * @memberof proto.RobotWheel
         * @static
         * @param {proto.IRobotWheel} message RobotWheel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotWheel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.locked != null && Object.hasOwnProperty.call(message, "locked"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.locked);
            if (message.braking != null && Object.hasOwnProperty.call(message, "braking"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.braking);
            return writer;
        };

        /**
         * Encodes the specified RobotWheel message, length delimited. Does not implicitly {@link proto.RobotWheel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RobotWheel
         * @static
         * @param {proto.IRobotWheel} message RobotWheel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotWheel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RobotWheel message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RobotWheel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RobotWheel} RobotWheel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotWheel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RobotWheel();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.locked = reader.bool();
                        break;
                    }
                case 2: {
                        message.braking = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RobotWheel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RobotWheel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RobotWheel} RobotWheel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotWheel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RobotWheel message.
         * @function verify
         * @memberof proto.RobotWheel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RobotWheel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.locked != null && message.hasOwnProperty("locked"))
                if (typeof message.locked !== "boolean")
                    return "locked: boolean expected";
            if (message.braking != null && message.hasOwnProperty("braking"))
                if (typeof message.braking !== "boolean")
                    return "braking: boolean expected";
            return null;
        };

        /**
         * Creates a RobotWheel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RobotWheel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RobotWheel} RobotWheel
         */
        RobotWheel.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RobotWheel)
                return object;
            let message = new $root.proto.RobotWheel();
            if (object.locked != null)
                message.locked = Boolean(object.locked);
            if (object.braking != null)
                message.braking = Boolean(object.braking);
            return message;
        };

        /**
         * Creates a plain object from a RobotWheel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RobotWheel
         * @static
         * @param {proto.RobotWheel} message RobotWheel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RobotWheel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.locked = false;
                object.braking = false;
            }
            if (message.locked != null && message.hasOwnProperty("locked"))
                object.locked = message.locked;
            if (message.braking != null && message.hasOwnProperty("braking"))
                object.braking = message.braking;
            return object;
        };

        /**
         * Converts this RobotWheel to JSON.
         * @function toJSON
         * @memberof proto.RobotWheel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RobotWheel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RobotWheel
         * @function getTypeUrl
         * @memberof proto.RobotWheel
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RobotWheel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RobotWheel";
        };

        return RobotWheel;
    })();

    proto.RobotWheels = (function() {

        /**
         * Properties of a RobotWheels.
         * @memberof proto
         * @interface IRobotWheels
         * @property {proto.IRobotWheel|null} [rightFront] RobotWheels rightFront
         * @property {proto.IRobotWheel|null} [rightBack] RobotWheels rightBack
         * @property {proto.IRobotWheel|null} [leftBack] RobotWheels leftBack
         * @property {proto.IRobotWheel|null} [leftFront] RobotWheels leftFront
         */

        /**
         * Constructs a new RobotWheels.
         * @memberof proto
         * @classdesc Represents a RobotWheels.
         * @implements IRobotWheels
         * @constructor
         * @param {proto.IRobotWheels=} [properties] Properties to set
         */
        function RobotWheels(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RobotWheels rightFront.
         * @member {proto.IRobotWheel|null|undefined} rightFront
         * @memberof proto.RobotWheels
         * @instance
         */
        RobotWheels.prototype.rightFront = null;

        /**
         * RobotWheels rightBack.
         * @member {proto.IRobotWheel|null|undefined} rightBack
         * @memberof proto.RobotWheels
         * @instance
         */
        RobotWheels.prototype.rightBack = null;

        /**
         * RobotWheels leftBack.
         * @member {proto.IRobotWheel|null|undefined} leftBack
         * @memberof proto.RobotWheels
         * @instance
         */
        RobotWheels.prototype.leftBack = null;

        /**
         * RobotWheels leftFront.
         * @member {proto.IRobotWheel|null|undefined} leftFront
         * @memberof proto.RobotWheels
         * @instance
         */
        RobotWheels.prototype.leftFront = null;

        /**
         * Creates a new RobotWheels instance using the specified properties.
         * @function create
         * @memberof proto.RobotWheels
         * @static
         * @param {proto.IRobotWheels=} [properties] Properties to set
         * @returns {proto.RobotWheels} RobotWheels instance
         */
        RobotWheels.create = function create(properties) {
            return new RobotWheels(properties);
        };

        /**
         * Encodes the specified RobotWheels message. Does not implicitly {@link proto.RobotWheels.verify|verify} messages.
         * @function encode
         * @memberof proto.RobotWheels
         * @static
         * @param {proto.IRobotWheels} message RobotWheels message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotWheels.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rightFront != null && Object.hasOwnProperty.call(message, "rightFront"))
                $root.proto.RobotWheel.encode(message.rightFront, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rightBack != null && Object.hasOwnProperty.call(message, "rightBack"))
                $root.proto.RobotWheel.encode(message.rightBack, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.leftBack != null && Object.hasOwnProperty.call(message, "leftBack"))
                $root.proto.RobotWheel.encode(message.leftBack, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.leftFront != null && Object.hasOwnProperty.call(message, "leftFront"))
                $root.proto.RobotWheel.encode(message.leftFront, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RobotWheels message, length delimited. Does not implicitly {@link proto.RobotWheels.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RobotWheels
         * @static
         * @param {proto.IRobotWheels} message RobotWheels message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotWheels.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RobotWheels message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RobotWheels
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RobotWheels} RobotWheels
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotWheels.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RobotWheels();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.rightFront = $root.proto.RobotWheel.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.rightBack = $root.proto.RobotWheel.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.leftBack = $root.proto.RobotWheel.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.leftFront = $root.proto.RobotWheel.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RobotWheels message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RobotWheels
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RobotWheels} RobotWheels
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotWheels.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RobotWheels message.
         * @function verify
         * @memberof proto.RobotWheels
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RobotWheels.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rightFront != null && message.hasOwnProperty("rightFront")) {
                let error = $root.proto.RobotWheel.verify(message.rightFront);
                if (error)
                    return "rightFront." + error;
            }
            if (message.rightBack != null && message.hasOwnProperty("rightBack")) {
                let error = $root.proto.RobotWheel.verify(message.rightBack);
                if (error)
                    return "rightBack." + error;
            }
            if (message.leftBack != null && message.hasOwnProperty("leftBack")) {
                let error = $root.proto.RobotWheel.verify(message.leftBack);
                if (error)
                    return "leftBack." + error;
            }
            if (message.leftFront != null && message.hasOwnProperty("leftFront")) {
                let error = $root.proto.RobotWheel.verify(message.leftFront);
                if (error)
                    return "leftFront." + error;
            }
            return null;
        };

        /**
         * Creates a RobotWheels message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RobotWheels
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RobotWheels} RobotWheels
         */
        RobotWheels.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RobotWheels)
                return object;
            let message = new $root.proto.RobotWheels();
            if (object.rightFront != null) {
                if (typeof object.rightFront !== "object")
                    throw TypeError(".proto.RobotWheels.rightFront: object expected");
                message.rightFront = $root.proto.RobotWheel.fromObject(object.rightFront);
            }
            if (object.rightBack != null) {
                if (typeof object.rightBack !== "object")
                    throw TypeError(".proto.RobotWheels.rightBack: object expected");
                message.rightBack = $root.proto.RobotWheel.fromObject(object.rightBack);
            }
            if (object.leftBack != null) {
                if (typeof object.leftBack !== "object")
                    throw TypeError(".proto.RobotWheels.leftBack: object expected");
                message.leftBack = $root.proto.RobotWheel.fromObject(object.leftBack);
            }
            if (object.leftFront != null) {
                if (typeof object.leftFront !== "object")
                    throw TypeError(".proto.RobotWheels.leftFront: object expected");
                message.leftFront = $root.proto.RobotWheel.fromObject(object.leftFront);
            }
            return message;
        };

        /**
         * Creates a plain object from a RobotWheels message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RobotWheels
         * @static
         * @param {proto.RobotWheels} message RobotWheels
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RobotWheels.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.rightFront = null;
                object.rightBack = null;
                object.leftBack = null;
                object.leftFront = null;
            }
            if (message.rightFront != null && message.hasOwnProperty("rightFront"))
                object.rightFront = $root.proto.RobotWheel.toObject(message.rightFront, options);
            if (message.rightBack != null && message.hasOwnProperty("rightBack"))
                object.rightBack = $root.proto.RobotWheel.toObject(message.rightBack, options);
            if (message.leftBack != null && message.hasOwnProperty("leftBack"))
                object.leftBack = $root.proto.RobotWheel.toObject(message.leftBack, options);
            if (message.leftFront != null && message.hasOwnProperty("leftFront"))
                object.leftFront = $root.proto.RobotWheel.toObject(message.leftFront, options);
            return object;
        };

        /**
         * Converts this RobotWheels to JSON.
         * @function toJSON
         * @memberof proto.RobotWheels
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RobotWheels.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RobotWheels
         * @function getTypeUrl
         * @memberof proto.RobotWheels
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RobotWheels.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RobotWheels";
        };

        return RobotWheels;
    })();

    proto.RobotProcessedFeedback = (function() {

        /**
         * Properties of a RobotProcessedFeedback.
         * @memberof proto
         * @interface IRobotProcessedFeedback
         * @property {boolean|null} [ballSensorSeesBall] RobotProcessedFeedback ballSensorSeesBall
         * @property {number|null} [ballPosition] RobotProcessedFeedback ballPosition
         * @property {boolean|null} [ballSensorIsWorking] RobotProcessedFeedback ballSensorIsWorking
         * @property {boolean|null} [dribblerSeesBall] RobotProcessedFeedback dribblerSeesBall
         * @property {boolean|null} [xsensIsCalibrated] RobotProcessedFeedback xsensIsCalibrated
         * @property {boolean|null} [capacitorIsCharged] RobotProcessedFeedback capacitorIsCharged
         * @property {proto.IRobotWheels|null} [wheelInformation] RobotProcessedFeedback wheelInformation
         * @property {number|null} [batteryLevel] RobotProcessedFeedback batteryLevel
         * @property {number|null} [signalStrength] RobotProcessedFeedback signalStrength
         */

        /**
         * Constructs a new RobotProcessedFeedback.
         * @memberof proto
         * @classdesc Represents a RobotProcessedFeedback.
         * @implements IRobotProcessedFeedback
         * @constructor
         * @param {proto.IRobotProcessedFeedback=} [properties] Properties to set
         */
        function RobotProcessedFeedback(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RobotProcessedFeedback ballSensorSeesBall.
         * @member {boolean} ballSensorSeesBall
         * @memberof proto.RobotProcessedFeedback
         * @instance
         */
        RobotProcessedFeedback.prototype.ballSensorSeesBall = false;

        /**
         * RobotProcessedFeedback ballPosition.
         * @member {number} ballPosition
         * @memberof proto.RobotProcessedFeedback
         * @instance
         */
        RobotProcessedFeedback.prototype.ballPosition = 0;

        /**
         * RobotProcessedFeedback ballSensorIsWorking.
         * @member {boolean} ballSensorIsWorking
         * @memberof proto.RobotProcessedFeedback
         * @instance
         */
        RobotProcessedFeedback.prototype.ballSensorIsWorking = false;

        /**
         * RobotProcessedFeedback dribblerSeesBall.
         * @member {boolean} dribblerSeesBall
         * @memberof proto.RobotProcessedFeedback
         * @instance
         */
        RobotProcessedFeedback.prototype.dribblerSeesBall = false;

        /**
         * RobotProcessedFeedback xsensIsCalibrated.
         * @member {boolean} xsensIsCalibrated
         * @memberof proto.RobotProcessedFeedback
         * @instance
         */
        RobotProcessedFeedback.prototype.xsensIsCalibrated = false;

        /**
         * RobotProcessedFeedback capacitorIsCharged.
         * @member {boolean} capacitorIsCharged
         * @memberof proto.RobotProcessedFeedback
         * @instance
         */
        RobotProcessedFeedback.prototype.capacitorIsCharged = false;

        /**
         * RobotProcessedFeedback wheelInformation.
         * @member {proto.IRobotWheels|null|undefined} wheelInformation
         * @memberof proto.RobotProcessedFeedback
         * @instance
         */
        RobotProcessedFeedback.prototype.wheelInformation = null;

        /**
         * RobotProcessedFeedback batteryLevel.
         * @member {number} batteryLevel
         * @memberof proto.RobotProcessedFeedback
         * @instance
         */
        RobotProcessedFeedback.prototype.batteryLevel = 0;

        /**
         * RobotProcessedFeedback signalStrength.
         * @member {number} signalStrength
         * @memberof proto.RobotProcessedFeedback
         * @instance
         */
        RobotProcessedFeedback.prototype.signalStrength = 0;

        /**
         * Creates a new RobotProcessedFeedback instance using the specified properties.
         * @function create
         * @memberof proto.RobotProcessedFeedback
         * @static
         * @param {proto.IRobotProcessedFeedback=} [properties] Properties to set
         * @returns {proto.RobotProcessedFeedback} RobotProcessedFeedback instance
         */
        RobotProcessedFeedback.create = function create(properties) {
            return new RobotProcessedFeedback(properties);
        };

        /**
         * Encodes the specified RobotProcessedFeedback message. Does not implicitly {@link proto.RobotProcessedFeedback.verify|verify} messages.
         * @function encode
         * @memberof proto.RobotProcessedFeedback
         * @static
         * @param {proto.IRobotProcessedFeedback} message RobotProcessedFeedback message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotProcessedFeedback.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ballSensorSeesBall != null && Object.hasOwnProperty.call(message, "ballSensorSeesBall"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.ballSensorSeesBall);
            if (message.ballPosition != null && Object.hasOwnProperty.call(message, "ballPosition"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.ballPosition);
            if (message.ballSensorIsWorking != null && Object.hasOwnProperty.call(message, "ballSensorIsWorking"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.ballSensorIsWorking);
            if (message.dribblerSeesBall != null && Object.hasOwnProperty.call(message, "dribblerSeesBall"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.dribblerSeesBall);
            if (message.xsensIsCalibrated != null && Object.hasOwnProperty.call(message, "xsensIsCalibrated"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.xsensIsCalibrated);
            if (message.capacitorIsCharged != null && Object.hasOwnProperty.call(message, "capacitorIsCharged"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.capacitorIsCharged);
            if (message.wheelInformation != null && Object.hasOwnProperty.call(message, "wheelInformation"))
                $root.proto.RobotWheels.encode(message.wheelInformation, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.batteryLevel != null && Object.hasOwnProperty.call(message, "batteryLevel"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.batteryLevel);
            if (message.signalStrength != null && Object.hasOwnProperty.call(message, "signalStrength"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.signalStrength);
            return writer;
        };

        /**
         * Encodes the specified RobotProcessedFeedback message, length delimited. Does not implicitly {@link proto.RobotProcessedFeedback.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RobotProcessedFeedback
         * @static
         * @param {proto.IRobotProcessedFeedback} message RobotProcessedFeedback message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotProcessedFeedback.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RobotProcessedFeedback message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RobotProcessedFeedback
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RobotProcessedFeedback} RobotProcessedFeedback
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotProcessedFeedback.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RobotProcessedFeedback();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.ballSensorSeesBall = reader.bool();
                        break;
                    }
                case 2: {
                        message.ballPosition = reader.float();
                        break;
                    }
                case 3: {
                        message.ballSensorIsWorking = reader.bool();
                        break;
                    }
                case 4: {
                        message.dribblerSeesBall = reader.bool();
                        break;
                    }
                case 5: {
                        message.xsensIsCalibrated = reader.bool();
                        break;
                    }
                case 6: {
                        message.capacitorIsCharged = reader.bool();
                        break;
                    }
                case 7: {
                        message.wheelInformation = $root.proto.RobotWheels.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.batteryLevel = reader.float();
                        break;
                    }
                case 9: {
                        message.signalStrength = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RobotProcessedFeedback message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RobotProcessedFeedback
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RobotProcessedFeedback} RobotProcessedFeedback
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotProcessedFeedback.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RobotProcessedFeedback message.
         * @function verify
         * @memberof proto.RobotProcessedFeedback
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RobotProcessedFeedback.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ballSensorSeesBall != null && message.hasOwnProperty("ballSensorSeesBall"))
                if (typeof message.ballSensorSeesBall !== "boolean")
                    return "ballSensorSeesBall: boolean expected";
            if (message.ballPosition != null && message.hasOwnProperty("ballPosition"))
                if (typeof message.ballPosition !== "number")
                    return "ballPosition: number expected";
            if (message.ballSensorIsWorking != null && message.hasOwnProperty("ballSensorIsWorking"))
                if (typeof message.ballSensorIsWorking !== "boolean")
                    return "ballSensorIsWorking: boolean expected";
            if (message.dribblerSeesBall != null && message.hasOwnProperty("dribblerSeesBall"))
                if (typeof message.dribblerSeesBall !== "boolean")
                    return "dribblerSeesBall: boolean expected";
            if (message.xsensIsCalibrated != null && message.hasOwnProperty("xsensIsCalibrated"))
                if (typeof message.xsensIsCalibrated !== "boolean")
                    return "xsensIsCalibrated: boolean expected";
            if (message.capacitorIsCharged != null && message.hasOwnProperty("capacitorIsCharged"))
                if (typeof message.capacitorIsCharged !== "boolean")
                    return "capacitorIsCharged: boolean expected";
            if (message.wheelInformation != null && message.hasOwnProperty("wheelInformation")) {
                let error = $root.proto.RobotWheels.verify(message.wheelInformation);
                if (error)
                    return "wheelInformation." + error;
            }
            if (message.batteryLevel != null && message.hasOwnProperty("batteryLevel"))
                if (typeof message.batteryLevel !== "number")
                    return "batteryLevel: number expected";
            if (message.signalStrength != null && message.hasOwnProperty("signalStrength"))
                if (!$util.isInteger(message.signalStrength))
                    return "signalStrength: integer expected";
            return null;
        };

        /**
         * Creates a RobotProcessedFeedback message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RobotProcessedFeedback
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RobotProcessedFeedback} RobotProcessedFeedback
         */
        RobotProcessedFeedback.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RobotProcessedFeedback)
                return object;
            let message = new $root.proto.RobotProcessedFeedback();
            if (object.ballSensorSeesBall != null)
                message.ballSensorSeesBall = Boolean(object.ballSensorSeesBall);
            if (object.ballPosition != null)
                message.ballPosition = Number(object.ballPosition);
            if (object.ballSensorIsWorking != null)
                message.ballSensorIsWorking = Boolean(object.ballSensorIsWorking);
            if (object.dribblerSeesBall != null)
                message.dribblerSeesBall = Boolean(object.dribblerSeesBall);
            if (object.xsensIsCalibrated != null)
                message.xsensIsCalibrated = Boolean(object.xsensIsCalibrated);
            if (object.capacitorIsCharged != null)
                message.capacitorIsCharged = Boolean(object.capacitorIsCharged);
            if (object.wheelInformation != null) {
                if (typeof object.wheelInformation !== "object")
                    throw TypeError(".proto.RobotProcessedFeedback.wheelInformation: object expected");
                message.wheelInformation = $root.proto.RobotWheels.fromObject(object.wheelInformation);
            }
            if (object.batteryLevel != null)
                message.batteryLevel = Number(object.batteryLevel);
            if (object.signalStrength != null)
                message.signalStrength = object.signalStrength | 0;
            return message;
        };

        /**
         * Creates a plain object from a RobotProcessedFeedback message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RobotProcessedFeedback
         * @static
         * @param {proto.RobotProcessedFeedback} message RobotProcessedFeedback
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RobotProcessedFeedback.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.ballSensorSeesBall = false;
                object.ballPosition = 0;
                object.ballSensorIsWorking = false;
                object.dribblerSeesBall = false;
                object.xsensIsCalibrated = false;
                object.capacitorIsCharged = false;
                object.wheelInformation = null;
                object.batteryLevel = 0;
                object.signalStrength = 0;
            }
            if (message.ballSensorSeesBall != null && message.hasOwnProperty("ballSensorSeesBall"))
                object.ballSensorSeesBall = message.ballSensorSeesBall;
            if (message.ballPosition != null && message.hasOwnProperty("ballPosition"))
                object.ballPosition = options.json && !isFinite(message.ballPosition) ? String(message.ballPosition) : message.ballPosition;
            if (message.ballSensorIsWorking != null && message.hasOwnProperty("ballSensorIsWorking"))
                object.ballSensorIsWorking = message.ballSensorIsWorking;
            if (message.dribblerSeesBall != null && message.hasOwnProperty("dribblerSeesBall"))
                object.dribblerSeesBall = message.dribblerSeesBall;
            if (message.xsensIsCalibrated != null && message.hasOwnProperty("xsensIsCalibrated"))
                object.xsensIsCalibrated = message.xsensIsCalibrated;
            if (message.capacitorIsCharged != null && message.hasOwnProperty("capacitorIsCharged"))
                object.capacitorIsCharged = message.capacitorIsCharged;
            if (message.wheelInformation != null && message.hasOwnProperty("wheelInformation"))
                object.wheelInformation = $root.proto.RobotWheels.toObject(message.wheelInformation, options);
            if (message.batteryLevel != null && message.hasOwnProperty("batteryLevel"))
                object.batteryLevel = options.json && !isFinite(message.batteryLevel) ? String(message.batteryLevel) : message.batteryLevel;
            if (message.signalStrength != null && message.hasOwnProperty("signalStrength"))
                object.signalStrength = message.signalStrength;
            return object;
        };

        /**
         * Converts this RobotProcessedFeedback to JSON.
         * @function toJSON
         * @memberof proto.RobotProcessedFeedback
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RobotProcessedFeedback.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RobotProcessedFeedback
         * @function getTypeUrl
         * @memberof proto.RobotProcessedFeedback
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RobotProcessedFeedback.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RobotProcessedFeedback";
        };

        return RobotProcessedFeedback;
    })();

    proto.FeedbackOnlyRobot = (function() {

        /**
         * Properties of a FeedbackOnlyRobot.
         * @memberof proto
         * @interface IFeedbackOnlyRobot
         * @property {number|null} [id] FeedbackOnlyRobot id
         * @property {proto.IRobotProcessedFeedback|null} [feedback] FeedbackOnlyRobot feedback
         */

        /**
         * Constructs a new FeedbackOnlyRobot.
         * @memberof proto
         * @classdesc Represents a FeedbackOnlyRobot.
         * @implements IFeedbackOnlyRobot
         * @constructor
         * @param {proto.IFeedbackOnlyRobot=} [properties] Properties to set
         */
        function FeedbackOnlyRobot(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FeedbackOnlyRobot id.
         * @member {number} id
         * @memberof proto.FeedbackOnlyRobot
         * @instance
         */
        FeedbackOnlyRobot.prototype.id = 0;

        /**
         * FeedbackOnlyRobot feedback.
         * @member {proto.IRobotProcessedFeedback|null|undefined} feedback
         * @memberof proto.FeedbackOnlyRobot
         * @instance
         */
        FeedbackOnlyRobot.prototype.feedback = null;

        /**
         * Creates a new FeedbackOnlyRobot instance using the specified properties.
         * @function create
         * @memberof proto.FeedbackOnlyRobot
         * @static
         * @param {proto.IFeedbackOnlyRobot=} [properties] Properties to set
         * @returns {proto.FeedbackOnlyRobot} FeedbackOnlyRobot instance
         */
        FeedbackOnlyRobot.create = function create(properties) {
            return new FeedbackOnlyRobot(properties);
        };

        /**
         * Encodes the specified FeedbackOnlyRobot message. Does not implicitly {@link proto.FeedbackOnlyRobot.verify|verify} messages.
         * @function encode
         * @memberof proto.FeedbackOnlyRobot
         * @static
         * @param {proto.IFeedbackOnlyRobot} message FeedbackOnlyRobot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackOnlyRobot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.feedback != null && Object.hasOwnProperty.call(message, "feedback"))
                $root.proto.RobotProcessedFeedback.encode(message.feedback, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FeedbackOnlyRobot message, length delimited. Does not implicitly {@link proto.FeedbackOnlyRobot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.FeedbackOnlyRobot
         * @static
         * @param {proto.IFeedbackOnlyRobot} message FeedbackOnlyRobot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeedbackOnlyRobot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeedbackOnlyRobot message from the specified reader or buffer.
         * @function decode
         * @memberof proto.FeedbackOnlyRobot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.FeedbackOnlyRobot} FeedbackOnlyRobot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackOnlyRobot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.FeedbackOnlyRobot();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.feedback = $root.proto.RobotProcessedFeedback.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeedbackOnlyRobot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.FeedbackOnlyRobot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.FeedbackOnlyRobot} FeedbackOnlyRobot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeedbackOnlyRobot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeedbackOnlyRobot message.
         * @function verify
         * @memberof proto.FeedbackOnlyRobot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeedbackOnlyRobot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.feedback != null && message.hasOwnProperty("feedback")) {
                let error = $root.proto.RobotProcessedFeedback.verify(message.feedback);
                if (error)
                    return "feedback." + error;
            }
            return null;
        };

        /**
         * Creates a FeedbackOnlyRobot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.FeedbackOnlyRobot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.FeedbackOnlyRobot} FeedbackOnlyRobot
         */
        FeedbackOnlyRobot.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.FeedbackOnlyRobot)
                return object;
            let message = new $root.proto.FeedbackOnlyRobot();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.feedback != null) {
                if (typeof object.feedback !== "object")
                    throw TypeError(".proto.FeedbackOnlyRobot.feedback: object expected");
                message.feedback = $root.proto.RobotProcessedFeedback.fromObject(object.feedback);
            }
            return message;
        };

        /**
         * Creates a plain object from a FeedbackOnlyRobot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.FeedbackOnlyRobot
         * @static
         * @param {proto.FeedbackOnlyRobot} message FeedbackOnlyRobot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeedbackOnlyRobot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = 0;
                object.feedback = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.feedback != null && message.hasOwnProperty("feedback"))
                object.feedback = $root.proto.RobotProcessedFeedback.toObject(message.feedback, options);
            return object;
        };

        /**
         * Converts this FeedbackOnlyRobot to JSON.
         * @function toJSON
         * @memberof proto.FeedbackOnlyRobot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeedbackOnlyRobot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FeedbackOnlyRobot
         * @function getTypeUrl
         * @memberof proto.FeedbackOnlyRobot
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FeedbackOnlyRobot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.FeedbackOnlyRobot";
        };

        return FeedbackOnlyRobot;
    })();

    proto.State = (function() {

        /**
         * Properties of a State.
         * @memberof proto
         * @interface IState
         * @property {proto.IWorld|null} [lastSeenWorld] State lastSeenWorld
         * @property {proto.IWorld|null} [commandExtrapolatedWorld] State commandExtrapolatedWorld
         * @property {proto.IWorld|null} [ballCameraWorld] State ballCameraWorld
         * @property {proto.ITeamParameters|null} [blueRobotParameters] State blueRobotParameters
         * @property {proto.ITeamParameters|null} [yellowRobotParameters] State yellowRobotParameters
         * @property {proto.ISSL_GeometryData|null} [field] State field
         * @property {proto.ISSL_Referee|null} [referee] State referee
         * @property {Array.<proto.ISSL_WrapperPacket>|null} [processedVisionPackets] State processedVisionPackets
         * @property {Array.<proto.ISSL_Referee>|null} [processedRefereePackets] State processedRefereePackets
         * @property {Array.<proto.IRobotsFeedback>|null} [processedFeedbackPackets] State processedFeedbackPackets
         */

        /**
         * Constructs a new State.
         * @memberof proto
         * @classdesc Represents a State.
         * @implements IState
         * @constructor
         * @param {proto.IState=} [properties] Properties to set
         */
        function State(properties) {
            this.processedVisionPackets = [];
            this.processedRefereePackets = [];
            this.processedFeedbackPackets = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * State lastSeenWorld.
         * @member {proto.IWorld|null|undefined} lastSeenWorld
         * @memberof proto.State
         * @instance
         */
        State.prototype.lastSeenWorld = null;

        /**
         * State commandExtrapolatedWorld.
         * @member {proto.IWorld|null|undefined} commandExtrapolatedWorld
         * @memberof proto.State
         * @instance
         */
        State.prototype.commandExtrapolatedWorld = null;

        /**
         * State ballCameraWorld.
         * @member {proto.IWorld|null|undefined} ballCameraWorld
         * @memberof proto.State
         * @instance
         */
        State.prototype.ballCameraWorld = null;

        /**
         * State blueRobotParameters.
         * @member {proto.ITeamParameters|null|undefined} blueRobotParameters
         * @memberof proto.State
         * @instance
         */
        State.prototype.blueRobotParameters = null;

        /**
         * State yellowRobotParameters.
         * @member {proto.ITeamParameters|null|undefined} yellowRobotParameters
         * @memberof proto.State
         * @instance
         */
        State.prototype.yellowRobotParameters = null;

        /**
         * State field.
         * @member {proto.ISSL_GeometryData|null|undefined} field
         * @memberof proto.State
         * @instance
         */
        State.prototype.field = null;

        /**
         * State referee.
         * @member {proto.ISSL_Referee|null|undefined} referee
         * @memberof proto.State
         * @instance
         */
        State.prototype.referee = null;

        /**
         * State processedVisionPackets.
         * @member {Array.<proto.ISSL_WrapperPacket>} processedVisionPackets
         * @memberof proto.State
         * @instance
         */
        State.prototype.processedVisionPackets = $util.emptyArray;

        /**
         * State processedRefereePackets.
         * @member {Array.<proto.ISSL_Referee>} processedRefereePackets
         * @memberof proto.State
         * @instance
         */
        State.prototype.processedRefereePackets = $util.emptyArray;

        /**
         * State processedFeedbackPackets.
         * @member {Array.<proto.IRobotsFeedback>} processedFeedbackPackets
         * @memberof proto.State
         * @instance
         */
        State.prototype.processedFeedbackPackets = $util.emptyArray;

        /**
         * Creates a new State instance using the specified properties.
         * @function create
         * @memberof proto.State
         * @static
         * @param {proto.IState=} [properties] Properties to set
         * @returns {proto.State} State instance
         */
        State.create = function create(properties) {
            return new State(properties);
        };

        /**
         * Encodes the specified State message. Does not implicitly {@link proto.State.verify|verify} messages.
         * @function encode
         * @memberof proto.State
         * @static
         * @param {proto.IState} message State message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        State.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastSeenWorld != null && Object.hasOwnProperty.call(message, "lastSeenWorld"))
                $root.proto.World.encode(message.lastSeenWorld, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.commandExtrapolatedWorld != null && Object.hasOwnProperty.call(message, "commandExtrapolatedWorld"))
                $root.proto.World.encode(message.commandExtrapolatedWorld, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.ballCameraWorld != null && Object.hasOwnProperty.call(message, "ballCameraWorld"))
                $root.proto.World.encode(message.ballCameraWorld, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.blueRobotParameters != null && Object.hasOwnProperty.call(message, "blueRobotParameters"))
                $root.proto.TeamParameters.encode(message.blueRobotParameters, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.yellowRobotParameters != null && Object.hasOwnProperty.call(message, "yellowRobotParameters"))
                $root.proto.TeamParameters.encode(message.yellowRobotParameters, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.field != null && Object.hasOwnProperty.call(message, "field"))
                $root.proto.SSL_GeometryData.encode(message.field, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.referee != null && Object.hasOwnProperty.call(message, "referee"))
                $root.proto.SSL_Referee.encode(message.referee, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.processedVisionPackets != null && message.processedVisionPackets.length)
                for (let i = 0; i < message.processedVisionPackets.length; ++i)
                    $root.proto.SSL_WrapperPacket.encode(message.processedVisionPackets[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.processedRefereePackets != null && message.processedRefereePackets.length)
                for (let i = 0; i < message.processedRefereePackets.length; ++i)
                    $root.proto.SSL_Referee.encode(message.processedRefereePackets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.processedFeedbackPackets != null && message.processedFeedbackPackets.length)
                for (let i = 0; i < message.processedFeedbackPackets.length; ++i)
                    $root.proto.RobotsFeedback.encode(message.processedFeedbackPackets[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified State message, length delimited. Does not implicitly {@link proto.State.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.State
         * @static
         * @param {proto.IState} message State message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        State.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a State message from the specified reader or buffer.
         * @function decode
         * @memberof proto.State
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.State} State
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        State.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.State();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.lastSeenWorld = $root.proto.World.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.commandExtrapolatedWorld = $root.proto.World.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.ballCameraWorld = $root.proto.World.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.blueRobotParameters = $root.proto.TeamParameters.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.yellowRobotParameters = $root.proto.TeamParameters.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.field = $root.proto.SSL_GeometryData.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.referee = $root.proto.SSL_Referee.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        if (!(message.processedVisionPackets && message.processedVisionPackets.length))
                            message.processedVisionPackets = [];
                        message.processedVisionPackets.push($root.proto.SSL_WrapperPacket.decode(reader, reader.uint32()));
                        break;
                    }
                case 11: {
                        if (!(message.processedRefereePackets && message.processedRefereePackets.length))
                            message.processedRefereePackets = [];
                        message.processedRefereePackets.push($root.proto.SSL_Referee.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        if (!(message.processedFeedbackPackets && message.processedFeedbackPackets.length))
                            message.processedFeedbackPackets = [];
                        message.processedFeedbackPackets.push($root.proto.RobotsFeedback.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a State message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.State
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.State} State
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        State.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a State message.
         * @function verify
         * @memberof proto.State
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        State.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastSeenWorld != null && message.hasOwnProperty("lastSeenWorld")) {
                let error = $root.proto.World.verify(message.lastSeenWorld);
                if (error)
                    return "lastSeenWorld." + error;
            }
            if (message.commandExtrapolatedWorld != null && message.hasOwnProperty("commandExtrapolatedWorld")) {
                let error = $root.proto.World.verify(message.commandExtrapolatedWorld);
                if (error)
                    return "commandExtrapolatedWorld." + error;
            }
            if (message.ballCameraWorld != null && message.hasOwnProperty("ballCameraWorld")) {
                let error = $root.proto.World.verify(message.ballCameraWorld);
                if (error)
                    return "ballCameraWorld." + error;
            }
            if (message.blueRobotParameters != null && message.hasOwnProperty("blueRobotParameters")) {
                let error = $root.proto.TeamParameters.verify(message.blueRobotParameters);
                if (error)
                    return "blueRobotParameters." + error;
            }
            if (message.yellowRobotParameters != null && message.hasOwnProperty("yellowRobotParameters")) {
                let error = $root.proto.TeamParameters.verify(message.yellowRobotParameters);
                if (error)
                    return "yellowRobotParameters." + error;
            }
            if (message.field != null && message.hasOwnProperty("field")) {
                let error = $root.proto.SSL_GeometryData.verify(message.field);
                if (error)
                    return "field." + error;
            }
            if (message.referee != null && message.hasOwnProperty("referee")) {
                let error = $root.proto.SSL_Referee.verify(message.referee);
                if (error)
                    return "referee." + error;
            }
            if (message.processedVisionPackets != null && message.hasOwnProperty("processedVisionPackets")) {
                if (!Array.isArray(message.processedVisionPackets))
                    return "processedVisionPackets: array expected";
                for (let i = 0; i < message.processedVisionPackets.length; ++i) {
                    let error = $root.proto.SSL_WrapperPacket.verify(message.processedVisionPackets[i]);
                    if (error)
                        return "processedVisionPackets." + error;
                }
            }
            if (message.processedRefereePackets != null && message.hasOwnProperty("processedRefereePackets")) {
                if (!Array.isArray(message.processedRefereePackets))
                    return "processedRefereePackets: array expected";
                for (let i = 0; i < message.processedRefereePackets.length; ++i) {
                    let error = $root.proto.SSL_Referee.verify(message.processedRefereePackets[i]);
                    if (error)
                        return "processedRefereePackets." + error;
                }
            }
            if (message.processedFeedbackPackets != null && message.hasOwnProperty("processedFeedbackPackets")) {
                if (!Array.isArray(message.processedFeedbackPackets))
                    return "processedFeedbackPackets: array expected";
                for (let i = 0; i < message.processedFeedbackPackets.length; ++i) {
                    let error = $root.proto.RobotsFeedback.verify(message.processedFeedbackPackets[i]);
                    if (error)
                        return "processedFeedbackPackets." + error;
                }
            }
            return null;
        };

        /**
         * Creates a State message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.State
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.State} State
         */
        State.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.State)
                return object;
            let message = new $root.proto.State();
            if (object.lastSeenWorld != null) {
                if (typeof object.lastSeenWorld !== "object")
                    throw TypeError(".proto.State.lastSeenWorld: object expected");
                message.lastSeenWorld = $root.proto.World.fromObject(object.lastSeenWorld);
            }
            if (object.commandExtrapolatedWorld != null) {
                if (typeof object.commandExtrapolatedWorld !== "object")
                    throw TypeError(".proto.State.commandExtrapolatedWorld: object expected");
                message.commandExtrapolatedWorld = $root.proto.World.fromObject(object.commandExtrapolatedWorld);
            }
            if (object.ballCameraWorld != null) {
                if (typeof object.ballCameraWorld !== "object")
                    throw TypeError(".proto.State.ballCameraWorld: object expected");
                message.ballCameraWorld = $root.proto.World.fromObject(object.ballCameraWorld);
            }
            if (object.blueRobotParameters != null) {
                if (typeof object.blueRobotParameters !== "object")
                    throw TypeError(".proto.State.blueRobotParameters: object expected");
                message.blueRobotParameters = $root.proto.TeamParameters.fromObject(object.blueRobotParameters);
            }
            if (object.yellowRobotParameters != null) {
                if (typeof object.yellowRobotParameters !== "object")
                    throw TypeError(".proto.State.yellowRobotParameters: object expected");
                message.yellowRobotParameters = $root.proto.TeamParameters.fromObject(object.yellowRobotParameters);
            }
            if (object.field != null) {
                if (typeof object.field !== "object")
                    throw TypeError(".proto.State.field: object expected");
                message.field = $root.proto.SSL_GeometryData.fromObject(object.field);
            }
            if (object.referee != null) {
                if (typeof object.referee !== "object")
                    throw TypeError(".proto.State.referee: object expected");
                message.referee = $root.proto.SSL_Referee.fromObject(object.referee);
            }
            if (object.processedVisionPackets) {
                if (!Array.isArray(object.processedVisionPackets))
                    throw TypeError(".proto.State.processedVisionPackets: array expected");
                message.processedVisionPackets = [];
                for (let i = 0; i < object.processedVisionPackets.length; ++i) {
                    if (typeof object.processedVisionPackets[i] !== "object")
                        throw TypeError(".proto.State.processedVisionPackets: object expected");
                    message.processedVisionPackets[i] = $root.proto.SSL_WrapperPacket.fromObject(object.processedVisionPackets[i]);
                }
            }
            if (object.processedRefereePackets) {
                if (!Array.isArray(object.processedRefereePackets))
                    throw TypeError(".proto.State.processedRefereePackets: array expected");
                message.processedRefereePackets = [];
                for (let i = 0; i < object.processedRefereePackets.length; ++i) {
                    if (typeof object.processedRefereePackets[i] !== "object")
                        throw TypeError(".proto.State.processedRefereePackets: object expected");
                    message.processedRefereePackets[i] = $root.proto.SSL_Referee.fromObject(object.processedRefereePackets[i]);
                }
            }
            if (object.processedFeedbackPackets) {
                if (!Array.isArray(object.processedFeedbackPackets))
                    throw TypeError(".proto.State.processedFeedbackPackets: array expected");
                message.processedFeedbackPackets = [];
                for (let i = 0; i < object.processedFeedbackPackets.length; ++i) {
                    if (typeof object.processedFeedbackPackets[i] !== "object")
                        throw TypeError(".proto.State.processedFeedbackPackets: object expected");
                    message.processedFeedbackPackets[i] = $root.proto.RobotsFeedback.fromObject(object.processedFeedbackPackets[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a State message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.State
         * @static
         * @param {proto.State} message State
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        State.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.processedVisionPackets = [];
                object.processedRefereePackets = [];
                object.processedFeedbackPackets = [];
            }
            if (options.defaults) {
                object.lastSeenWorld = null;
                object.commandExtrapolatedWorld = null;
                object.ballCameraWorld = null;
                object.blueRobotParameters = null;
                object.yellowRobotParameters = null;
                object.field = null;
                object.referee = null;
            }
            if (message.lastSeenWorld != null && message.hasOwnProperty("lastSeenWorld"))
                object.lastSeenWorld = $root.proto.World.toObject(message.lastSeenWorld, options);
            if (message.commandExtrapolatedWorld != null && message.hasOwnProperty("commandExtrapolatedWorld"))
                object.commandExtrapolatedWorld = $root.proto.World.toObject(message.commandExtrapolatedWorld, options);
            if (message.ballCameraWorld != null && message.hasOwnProperty("ballCameraWorld"))
                object.ballCameraWorld = $root.proto.World.toObject(message.ballCameraWorld, options);
            if (message.blueRobotParameters != null && message.hasOwnProperty("blueRobotParameters"))
                object.blueRobotParameters = $root.proto.TeamParameters.toObject(message.blueRobotParameters, options);
            if (message.yellowRobotParameters != null && message.hasOwnProperty("yellowRobotParameters"))
                object.yellowRobotParameters = $root.proto.TeamParameters.toObject(message.yellowRobotParameters, options);
            if (message.field != null && message.hasOwnProperty("field"))
                object.field = $root.proto.SSL_GeometryData.toObject(message.field, options);
            if (message.referee != null && message.hasOwnProperty("referee"))
                object.referee = $root.proto.SSL_Referee.toObject(message.referee, options);
            if (message.processedVisionPackets && message.processedVisionPackets.length) {
                object.processedVisionPackets = [];
                for (let j = 0; j < message.processedVisionPackets.length; ++j)
                    object.processedVisionPackets[j] = $root.proto.SSL_WrapperPacket.toObject(message.processedVisionPackets[j], options);
            }
            if (message.processedRefereePackets && message.processedRefereePackets.length) {
                object.processedRefereePackets = [];
                for (let j = 0; j < message.processedRefereePackets.length; ++j)
                    object.processedRefereePackets[j] = $root.proto.SSL_Referee.toObject(message.processedRefereePackets[j], options);
            }
            if (message.processedFeedbackPackets && message.processedFeedbackPackets.length) {
                object.processedFeedbackPackets = [];
                for (let j = 0; j < message.processedFeedbackPackets.length; ++j)
                    object.processedFeedbackPackets[j] = $root.proto.RobotsFeedback.toObject(message.processedFeedbackPackets[j], options);
            }
            return object;
        };

        /**
         * Converts this State to JSON.
         * @function toJSON
         * @memberof proto.State
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        State.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for State
         * @function getTypeUrl
         * @memberof proto.State
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        State.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.State";
        };

        return State;
    })();

    proto.ModuleState = (function() {

        /**
         * Properties of a ModuleState.
         * @memberof proto
         * @interface IModuleState
         * @property {proto.IState|null} [systemState] ModuleState systemState
         * @property {Array.<proto.IHandshake>|null} [handshakes] ModuleState handshakes
         */

        /**
         * Constructs a new ModuleState.
         * @memberof proto
         * @classdesc Represents a ModuleState.
         * @implements IModuleState
         * @constructor
         * @param {proto.IModuleState=} [properties] Properties to set
         */
        function ModuleState(properties) {
            this.handshakes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModuleState systemState.
         * @member {proto.IState|null|undefined} systemState
         * @memberof proto.ModuleState
         * @instance
         */
        ModuleState.prototype.systemState = null;

        /**
         * ModuleState handshakes.
         * @member {Array.<proto.IHandshake>} handshakes
         * @memberof proto.ModuleState
         * @instance
         */
        ModuleState.prototype.handshakes = $util.emptyArray;

        /**
         * Creates a new ModuleState instance using the specified properties.
         * @function create
         * @memberof proto.ModuleState
         * @static
         * @param {proto.IModuleState=} [properties] Properties to set
         * @returns {proto.ModuleState} ModuleState instance
         */
        ModuleState.create = function create(properties) {
            return new ModuleState(properties);
        };

        /**
         * Encodes the specified ModuleState message. Does not implicitly {@link proto.ModuleState.verify|verify} messages.
         * @function encode
         * @memberof proto.ModuleState
         * @static
         * @param {proto.IModuleState} message ModuleState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModuleState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.systemState != null && Object.hasOwnProperty.call(message, "systemState"))
                $root.proto.State.encode(message.systemState, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.handshakes != null && message.handshakes.length)
                for (let i = 0; i < message.handshakes.length; ++i)
                    $root.proto.Handshake.encode(message.handshakes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ModuleState message, length delimited. Does not implicitly {@link proto.ModuleState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.ModuleState
         * @static
         * @param {proto.IModuleState} message ModuleState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModuleState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModuleState message from the specified reader or buffer.
         * @function decode
         * @memberof proto.ModuleState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.ModuleState} ModuleState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModuleState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.ModuleState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.systemState = $root.proto.State.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        if (!(message.handshakes && message.handshakes.length))
                            message.handshakes = [];
                        message.handshakes.push($root.proto.Handshake.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModuleState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.ModuleState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.ModuleState} ModuleState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModuleState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModuleState message.
         * @function verify
         * @memberof proto.ModuleState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModuleState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.systemState != null && message.hasOwnProperty("systemState")) {
                let error = $root.proto.State.verify(message.systemState);
                if (error)
                    return "systemState." + error;
            }
            if (message.handshakes != null && message.hasOwnProperty("handshakes")) {
                if (!Array.isArray(message.handshakes))
                    return "handshakes: array expected";
                for (let i = 0; i < message.handshakes.length; ++i) {
                    let error = $root.proto.Handshake.verify(message.handshakes[i]);
                    if (error)
                        return "handshakes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ModuleState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.ModuleState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.ModuleState} ModuleState
         */
        ModuleState.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.ModuleState)
                return object;
            let message = new $root.proto.ModuleState();
            if (object.systemState != null) {
                if (typeof object.systemState !== "object")
                    throw TypeError(".proto.ModuleState.systemState: object expected");
                message.systemState = $root.proto.State.fromObject(object.systemState);
            }
            if (object.handshakes) {
                if (!Array.isArray(object.handshakes))
                    throw TypeError(".proto.ModuleState.handshakes: array expected");
                message.handshakes = [];
                for (let i = 0; i < object.handshakes.length; ++i) {
                    if (typeof object.handshakes[i] !== "object")
                        throw TypeError(".proto.ModuleState.handshakes: object expected");
                    message.handshakes[i] = $root.proto.Handshake.fromObject(object.handshakes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ModuleState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.ModuleState
         * @static
         * @param {proto.ModuleState} message ModuleState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModuleState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.handshakes = [];
            if (options.defaults)
                object.systemState = null;
            if (message.systemState != null && message.hasOwnProperty("systemState"))
                object.systemState = $root.proto.State.toObject(message.systemState, options);
            if (message.handshakes && message.handshakes.length) {
                object.handshakes = [];
                for (let j = 0; j < message.handshakes.length; ++j)
                    object.handshakes[j] = $root.proto.Handshake.toObject(message.handshakes[j], options);
            }
            return object;
        };

        /**
         * Converts this ModuleState to JSON.
         * @function toJSON
         * @memberof proto.ModuleState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModuleState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ModuleState
         * @function getTypeUrl
         * @memberof proto.ModuleState
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ModuleState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.ModuleState";
        };

        return ModuleState;
    })();

    proto.RobotParameters = (function() {

        /**
         * Properties of a RobotParameters.
         * @memberof proto
         * @interface IRobotParameters
         * @property {number|null} [radius] RobotParameters radius
         * @property {number|null} [height] RobotParameters height
         * @property {number|null} [frontWidth] RobotParameters frontWidth
         * @property {number|null} [dribblerWidth] RobotParameters dribblerWidth
         * @property {number|null} [angleOffset] RobotParameters angleOffset
         */

        /**
         * Constructs a new RobotParameters.
         * @memberof proto
         * @classdesc Represents a RobotParameters.
         * @implements IRobotParameters
         * @constructor
         * @param {proto.IRobotParameters=} [properties] Properties to set
         */
        function RobotParameters(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RobotParameters radius.
         * @member {number} radius
         * @memberof proto.RobotParameters
         * @instance
         */
        RobotParameters.prototype.radius = 0;

        /**
         * RobotParameters height.
         * @member {number} height
         * @memberof proto.RobotParameters
         * @instance
         */
        RobotParameters.prototype.height = 0;

        /**
         * RobotParameters frontWidth.
         * @member {number} frontWidth
         * @memberof proto.RobotParameters
         * @instance
         */
        RobotParameters.prototype.frontWidth = 0;

        /**
         * RobotParameters dribblerWidth.
         * @member {number} dribblerWidth
         * @memberof proto.RobotParameters
         * @instance
         */
        RobotParameters.prototype.dribblerWidth = 0;

        /**
         * RobotParameters angleOffset.
         * @member {number} angleOffset
         * @memberof proto.RobotParameters
         * @instance
         */
        RobotParameters.prototype.angleOffset = 0;

        /**
         * Creates a new RobotParameters instance using the specified properties.
         * @function create
         * @memberof proto.RobotParameters
         * @static
         * @param {proto.IRobotParameters=} [properties] Properties to set
         * @returns {proto.RobotParameters} RobotParameters instance
         */
        RobotParameters.create = function create(properties) {
            return new RobotParameters(properties);
        };

        /**
         * Encodes the specified RobotParameters message. Does not implicitly {@link proto.RobotParameters.verify|verify} messages.
         * @function encode
         * @memberof proto.RobotParameters
         * @static
         * @param {proto.IRobotParameters} message RobotParameters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotParameters.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.radius != null && Object.hasOwnProperty.call(message, "radius"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.radius);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.height);
            if (message.frontWidth != null && Object.hasOwnProperty.call(message, "frontWidth"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.frontWidth);
            if (message.dribblerWidth != null && Object.hasOwnProperty.call(message, "dribblerWidth"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.dribblerWidth);
            if (message.angleOffset != null && Object.hasOwnProperty.call(message, "angleOffset"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.angleOffset);
            return writer;
        };

        /**
         * Encodes the specified RobotParameters message, length delimited. Does not implicitly {@link proto.RobotParameters.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RobotParameters
         * @static
         * @param {proto.IRobotParameters} message RobotParameters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotParameters.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RobotParameters message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RobotParameters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RobotParameters} RobotParameters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotParameters.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RobotParameters();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.radius = reader.float();
                        break;
                    }
                case 2: {
                        message.height = reader.float();
                        break;
                    }
                case 3: {
                        message.frontWidth = reader.float();
                        break;
                    }
                case 4: {
                        message.dribblerWidth = reader.float();
                        break;
                    }
                case 5: {
                        message.angleOffset = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RobotParameters message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RobotParameters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RobotParameters} RobotParameters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotParameters.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RobotParameters message.
         * @function verify
         * @memberof proto.RobotParameters
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RobotParameters.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.radius != null && message.hasOwnProperty("radius"))
                if (typeof message.radius !== "number")
                    return "radius: number expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (typeof message.height !== "number")
                    return "height: number expected";
            if (message.frontWidth != null && message.hasOwnProperty("frontWidth"))
                if (typeof message.frontWidth !== "number")
                    return "frontWidth: number expected";
            if (message.dribblerWidth != null && message.hasOwnProperty("dribblerWidth"))
                if (typeof message.dribblerWidth !== "number")
                    return "dribblerWidth: number expected";
            if (message.angleOffset != null && message.hasOwnProperty("angleOffset"))
                if (typeof message.angleOffset !== "number")
                    return "angleOffset: number expected";
            return null;
        };

        /**
         * Creates a RobotParameters message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RobotParameters
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RobotParameters} RobotParameters
         */
        RobotParameters.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RobotParameters)
                return object;
            let message = new $root.proto.RobotParameters();
            if (object.radius != null)
                message.radius = Number(object.radius);
            if (object.height != null)
                message.height = Number(object.height);
            if (object.frontWidth != null)
                message.frontWidth = Number(object.frontWidth);
            if (object.dribblerWidth != null)
                message.dribblerWidth = Number(object.dribblerWidth);
            if (object.angleOffset != null)
                message.angleOffset = Number(object.angleOffset);
            return message;
        };

        /**
         * Creates a plain object from a RobotParameters message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RobotParameters
         * @static
         * @param {proto.RobotParameters} message RobotParameters
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RobotParameters.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.radius = 0;
                object.height = 0;
                object.frontWidth = 0;
                object.dribblerWidth = 0;
                object.angleOffset = 0;
            }
            if (message.radius != null && message.hasOwnProperty("radius"))
                object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = options.json && !isFinite(message.height) ? String(message.height) : message.height;
            if (message.frontWidth != null && message.hasOwnProperty("frontWidth"))
                object.frontWidth = options.json && !isFinite(message.frontWidth) ? String(message.frontWidth) : message.frontWidth;
            if (message.dribblerWidth != null && message.hasOwnProperty("dribblerWidth"))
                object.dribblerWidth = options.json && !isFinite(message.dribblerWidth) ? String(message.dribblerWidth) : message.dribblerWidth;
            if (message.angleOffset != null && message.hasOwnProperty("angleOffset"))
                object.angleOffset = options.json && !isFinite(message.angleOffset) ? String(message.angleOffset) : message.angleOffset;
            return object;
        };

        /**
         * Converts this RobotParameters to JSON.
         * @function toJSON
         * @memberof proto.RobotParameters
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RobotParameters.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RobotParameters
         * @function getTypeUrl
         * @memberof proto.RobotParameters
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RobotParameters.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RobotParameters";
        };

        return RobotParameters;
    })();

    proto.TeamParameters = (function() {

        /**
         * Properties of a TeamParameters.
         * @memberof proto
         * @interface ITeamParameters
         * @property {boolean|null} [didChange] TeamParameters didChange
         * @property {proto.IRobotParameters|null} [parameters] TeamParameters parameters
         */

        /**
         * Constructs a new TeamParameters.
         * @memberof proto
         * @classdesc Represents a TeamParameters.
         * @implements ITeamParameters
         * @constructor
         * @param {proto.ITeamParameters=} [properties] Properties to set
         */
        function TeamParameters(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TeamParameters didChange.
         * @member {boolean} didChange
         * @memberof proto.TeamParameters
         * @instance
         */
        TeamParameters.prototype.didChange = false;

        /**
         * TeamParameters parameters.
         * @member {proto.IRobotParameters|null|undefined} parameters
         * @memberof proto.TeamParameters
         * @instance
         */
        TeamParameters.prototype.parameters = null;

        /**
         * Creates a new TeamParameters instance using the specified properties.
         * @function create
         * @memberof proto.TeamParameters
         * @static
         * @param {proto.ITeamParameters=} [properties] Properties to set
         * @returns {proto.TeamParameters} TeamParameters instance
         */
        TeamParameters.create = function create(properties) {
            return new TeamParameters(properties);
        };

        /**
         * Encodes the specified TeamParameters message. Does not implicitly {@link proto.TeamParameters.verify|verify} messages.
         * @function encode
         * @memberof proto.TeamParameters
         * @static
         * @param {proto.ITeamParameters} message TeamParameters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TeamParameters.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.didChange != null && Object.hasOwnProperty.call(message, "didChange"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.didChange);
            if (message.parameters != null && Object.hasOwnProperty.call(message, "parameters"))
                $root.proto.RobotParameters.encode(message.parameters, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TeamParameters message, length delimited. Does not implicitly {@link proto.TeamParameters.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.TeamParameters
         * @static
         * @param {proto.ITeamParameters} message TeamParameters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TeamParameters.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TeamParameters message from the specified reader or buffer.
         * @function decode
         * @memberof proto.TeamParameters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.TeamParameters} TeamParameters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TeamParameters.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.TeamParameters();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.didChange = reader.bool();
                        break;
                    }
                case 2: {
                        message.parameters = $root.proto.RobotParameters.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TeamParameters message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.TeamParameters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.TeamParameters} TeamParameters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TeamParameters.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TeamParameters message.
         * @function verify
         * @memberof proto.TeamParameters
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TeamParameters.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.didChange != null && message.hasOwnProperty("didChange"))
                if (typeof message.didChange !== "boolean")
                    return "didChange: boolean expected";
            if (message.parameters != null && message.hasOwnProperty("parameters")) {
                let error = $root.proto.RobotParameters.verify(message.parameters);
                if (error)
                    return "parameters." + error;
            }
            return null;
        };

        /**
         * Creates a TeamParameters message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.TeamParameters
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.TeamParameters} TeamParameters
         */
        TeamParameters.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.TeamParameters)
                return object;
            let message = new $root.proto.TeamParameters();
            if (object.didChange != null)
                message.didChange = Boolean(object.didChange);
            if (object.parameters != null) {
                if (typeof object.parameters !== "object")
                    throw TypeError(".proto.TeamParameters.parameters: object expected");
                message.parameters = $root.proto.RobotParameters.fromObject(object.parameters);
            }
            return message;
        };

        /**
         * Creates a plain object from a TeamParameters message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.TeamParameters
         * @static
         * @param {proto.TeamParameters} message TeamParameters
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TeamParameters.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.didChange = false;
                object.parameters = null;
            }
            if (message.didChange != null && message.hasOwnProperty("didChange"))
                object.didChange = message.didChange;
            if (message.parameters != null && message.hasOwnProperty("parameters"))
                object.parameters = $root.proto.RobotParameters.toObject(message.parameters, options);
            return object;
        };

        /**
         * Converts this TeamParameters to JSON.
         * @function toJSON
         * @memberof proto.TeamParameters
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TeamParameters.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TeamParameters
         * @function getTypeUrl
         * @memberof proto.TeamParameters
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TeamParameters.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.TeamParameters";
        };

        return TeamParameters;
    })();

    /**
     * RobotTeam enum.
     * @name proto.RobotTeam
     * @enum {number}
     * @property {number} YELLOW_TEAM=0 YELLOW_TEAM value
     * @property {number} BLUE_TEAM=1 BLUE_TEAM value
     */
    proto.RobotTeam = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "YELLOW_TEAM"] = 0;
        values[valuesById[1] = "BLUE_TEAM"] = 1;
        return values;
    })();

    /**
     * RobotFeedbackSource enum.
     * @name proto.RobotFeedbackSource
     * @enum {number}
     * @property {number} SIMULATOR=0 SIMULATOR value
     * @property {number} BASESTATION=1 BASESTATION value
     */
    proto.RobotFeedbackSource = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SIMULATOR"] = 0;
        values[valuesById[1] = "BASESTATION"] = 1;
        return values;
    })();

    proto.RobotFeedback = (function() {

        /**
         * Properties of a RobotFeedback.
         * @memberof proto
         * @interface IRobotFeedback
         * @property {number|null} [id] RobotFeedback id
         * @property {boolean|null} [ballSensorSeesBall] RobotFeedback ballSensorSeesBall
         * @property {number|null} [ballPosition] RobotFeedback ballPosition
         * @property {boolean|null} [ballSensorIsWorking] RobotFeedback ballSensorIsWorking
         * @property {boolean|null} [dribblerSeesBall] RobotFeedback dribblerSeesBall
         * @property {number|null} [estimatedVelocityX] RobotFeedback estimatedVelocityX
         * @property {number|null} [estimatedVelocityY] RobotFeedback estimatedVelocityY
         * @property {number|null} [estimatedAngle] RobotFeedback estimatedAngle
         * @property {boolean|null} [xsensIsCalibrated] RobotFeedback xsensIsCalibrated
         * @property {boolean|null} [capacitorIsCharged] RobotFeedback capacitorIsCharged
         * @property {number|null} [wheelsLocked] RobotFeedback wheelsLocked
         * @property {number|null} [wheelsBraking] RobotFeedback wheelsBraking
         * @property {number|null} [batteryLevel] RobotFeedback batteryLevel
         * @property {number|null} [signalStrength] RobotFeedback signalStrength
         */

        /**
         * Constructs a new RobotFeedback.
         * @memberof proto
         * @classdesc Represents a RobotFeedback.
         * @implements IRobotFeedback
         * @constructor
         * @param {proto.IRobotFeedback=} [properties] Properties to set
         */
        function RobotFeedback(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RobotFeedback id.
         * @member {number} id
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.id = 0;

        /**
         * RobotFeedback ballSensorSeesBall.
         * @member {boolean} ballSensorSeesBall
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.ballSensorSeesBall = false;

        /**
         * RobotFeedback ballPosition.
         * @member {number} ballPosition
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.ballPosition = 0;

        /**
         * RobotFeedback ballSensorIsWorking.
         * @member {boolean} ballSensorIsWorking
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.ballSensorIsWorking = false;

        /**
         * RobotFeedback dribblerSeesBall.
         * @member {boolean} dribblerSeesBall
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.dribblerSeesBall = false;

        /**
         * RobotFeedback estimatedVelocityX.
         * @member {number} estimatedVelocityX
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.estimatedVelocityX = 0;

        /**
         * RobotFeedback estimatedVelocityY.
         * @member {number} estimatedVelocityY
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.estimatedVelocityY = 0;

        /**
         * RobotFeedback estimatedAngle.
         * @member {number} estimatedAngle
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.estimatedAngle = 0;

        /**
         * RobotFeedback xsensIsCalibrated.
         * @member {boolean} xsensIsCalibrated
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.xsensIsCalibrated = false;

        /**
         * RobotFeedback capacitorIsCharged.
         * @member {boolean} capacitorIsCharged
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.capacitorIsCharged = false;

        /**
         * RobotFeedback wheelsLocked.
         * @member {number} wheelsLocked
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.wheelsLocked = 0;

        /**
         * RobotFeedback wheelsBraking.
         * @member {number} wheelsBraking
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.wheelsBraking = 0;

        /**
         * RobotFeedback batteryLevel.
         * @member {number} batteryLevel
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.batteryLevel = 0;

        /**
         * RobotFeedback signalStrength.
         * @member {number} signalStrength
         * @memberof proto.RobotFeedback
         * @instance
         */
        RobotFeedback.prototype.signalStrength = 0;

        /**
         * Creates a new RobotFeedback instance using the specified properties.
         * @function create
         * @memberof proto.RobotFeedback
         * @static
         * @param {proto.IRobotFeedback=} [properties] Properties to set
         * @returns {proto.RobotFeedback} RobotFeedback instance
         */
        RobotFeedback.create = function create(properties) {
            return new RobotFeedback(properties);
        };

        /**
         * Encodes the specified RobotFeedback message. Does not implicitly {@link proto.RobotFeedback.verify|verify} messages.
         * @function encode
         * @memberof proto.RobotFeedback
         * @static
         * @param {proto.IRobotFeedback} message RobotFeedback message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotFeedback.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.ballSensorSeesBall != null && Object.hasOwnProperty.call(message, "ballSensorSeesBall"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ballSensorSeesBall);
            if (message.ballPosition != null && Object.hasOwnProperty.call(message, "ballPosition"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.ballPosition);
            if (message.ballSensorIsWorking != null && Object.hasOwnProperty.call(message, "ballSensorIsWorking"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.ballSensorIsWorking);
            if (message.dribblerSeesBall != null && Object.hasOwnProperty.call(message, "dribblerSeesBall"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.dribblerSeesBall);
            if (message.estimatedVelocityX != null && Object.hasOwnProperty.call(message, "estimatedVelocityX"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.estimatedVelocityX);
            if (message.estimatedVelocityY != null && Object.hasOwnProperty.call(message, "estimatedVelocityY"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.estimatedVelocityY);
            if (message.estimatedAngle != null && Object.hasOwnProperty.call(message, "estimatedAngle"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.estimatedAngle);
            if (message.xsensIsCalibrated != null && Object.hasOwnProperty.call(message, "xsensIsCalibrated"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.xsensIsCalibrated);
            if (message.capacitorIsCharged != null && Object.hasOwnProperty.call(message, "capacitorIsCharged"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.capacitorIsCharged);
            if (message.wheelsLocked != null && Object.hasOwnProperty.call(message, "wheelsLocked"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.wheelsLocked);
            if (message.wheelsBraking != null && Object.hasOwnProperty.call(message, "wheelsBraking"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.wheelsBraking);
            if (message.batteryLevel != null && Object.hasOwnProperty.call(message, "batteryLevel"))
                writer.uint32(/* id 13, wireType 5 =*/109).float(message.batteryLevel);
            if (message.signalStrength != null && Object.hasOwnProperty.call(message, "signalStrength"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.signalStrength);
            return writer;
        };

        /**
         * Encodes the specified RobotFeedback message, length delimited. Does not implicitly {@link proto.RobotFeedback.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RobotFeedback
         * @static
         * @param {proto.IRobotFeedback} message RobotFeedback message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotFeedback.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RobotFeedback message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RobotFeedback
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RobotFeedback} RobotFeedback
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotFeedback.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RobotFeedback();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.ballSensorSeesBall = reader.bool();
                        break;
                    }
                case 3: {
                        message.ballPosition = reader.float();
                        break;
                    }
                case 4: {
                        message.ballSensorIsWorking = reader.bool();
                        break;
                    }
                case 5: {
                        message.dribblerSeesBall = reader.bool();
                        break;
                    }
                case 6: {
                        message.estimatedVelocityX = reader.double();
                        break;
                    }
                case 7: {
                        message.estimatedVelocityY = reader.double();
                        break;
                    }
                case 8: {
                        message.estimatedAngle = reader.double();
                        break;
                    }
                case 9: {
                        message.xsensIsCalibrated = reader.bool();
                        break;
                    }
                case 10: {
                        message.capacitorIsCharged = reader.bool();
                        break;
                    }
                case 11: {
                        message.wheelsLocked = reader.int32();
                        break;
                    }
                case 12: {
                        message.wheelsBraking = reader.int32();
                        break;
                    }
                case 13: {
                        message.batteryLevel = reader.float();
                        break;
                    }
                case 14: {
                        message.signalStrength = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RobotFeedback message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RobotFeedback
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RobotFeedback} RobotFeedback
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotFeedback.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RobotFeedback message.
         * @function verify
         * @memberof proto.RobotFeedback
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RobotFeedback.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.ballSensorSeesBall != null && message.hasOwnProperty("ballSensorSeesBall"))
                if (typeof message.ballSensorSeesBall !== "boolean")
                    return "ballSensorSeesBall: boolean expected";
            if (message.ballPosition != null && message.hasOwnProperty("ballPosition"))
                if (typeof message.ballPosition !== "number")
                    return "ballPosition: number expected";
            if (message.ballSensorIsWorking != null && message.hasOwnProperty("ballSensorIsWorking"))
                if (typeof message.ballSensorIsWorking !== "boolean")
                    return "ballSensorIsWorking: boolean expected";
            if (message.dribblerSeesBall != null && message.hasOwnProperty("dribblerSeesBall"))
                if (typeof message.dribblerSeesBall !== "boolean")
                    return "dribblerSeesBall: boolean expected";
            if (message.estimatedVelocityX != null && message.hasOwnProperty("estimatedVelocityX"))
                if (typeof message.estimatedVelocityX !== "number")
                    return "estimatedVelocityX: number expected";
            if (message.estimatedVelocityY != null && message.hasOwnProperty("estimatedVelocityY"))
                if (typeof message.estimatedVelocityY !== "number")
                    return "estimatedVelocityY: number expected";
            if (message.estimatedAngle != null && message.hasOwnProperty("estimatedAngle"))
                if (typeof message.estimatedAngle !== "number")
                    return "estimatedAngle: number expected";
            if (message.xsensIsCalibrated != null && message.hasOwnProperty("xsensIsCalibrated"))
                if (typeof message.xsensIsCalibrated !== "boolean")
                    return "xsensIsCalibrated: boolean expected";
            if (message.capacitorIsCharged != null && message.hasOwnProperty("capacitorIsCharged"))
                if (typeof message.capacitorIsCharged !== "boolean")
                    return "capacitorIsCharged: boolean expected";
            if (message.wheelsLocked != null && message.hasOwnProperty("wheelsLocked"))
                if (!$util.isInteger(message.wheelsLocked))
                    return "wheelsLocked: integer expected";
            if (message.wheelsBraking != null && message.hasOwnProperty("wheelsBraking"))
                if (!$util.isInteger(message.wheelsBraking))
                    return "wheelsBraking: integer expected";
            if (message.batteryLevel != null && message.hasOwnProperty("batteryLevel"))
                if (typeof message.batteryLevel !== "number")
                    return "batteryLevel: number expected";
            if (message.signalStrength != null && message.hasOwnProperty("signalStrength"))
                if (!$util.isInteger(message.signalStrength))
                    return "signalStrength: integer expected";
            return null;
        };

        /**
         * Creates a RobotFeedback message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RobotFeedback
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RobotFeedback} RobotFeedback
         */
        RobotFeedback.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RobotFeedback)
                return object;
            let message = new $root.proto.RobotFeedback();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.ballSensorSeesBall != null)
                message.ballSensorSeesBall = Boolean(object.ballSensorSeesBall);
            if (object.ballPosition != null)
                message.ballPosition = Number(object.ballPosition);
            if (object.ballSensorIsWorking != null)
                message.ballSensorIsWorking = Boolean(object.ballSensorIsWorking);
            if (object.dribblerSeesBall != null)
                message.dribblerSeesBall = Boolean(object.dribblerSeesBall);
            if (object.estimatedVelocityX != null)
                message.estimatedVelocityX = Number(object.estimatedVelocityX);
            if (object.estimatedVelocityY != null)
                message.estimatedVelocityY = Number(object.estimatedVelocityY);
            if (object.estimatedAngle != null)
                message.estimatedAngle = Number(object.estimatedAngle);
            if (object.xsensIsCalibrated != null)
                message.xsensIsCalibrated = Boolean(object.xsensIsCalibrated);
            if (object.capacitorIsCharged != null)
                message.capacitorIsCharged = Boolean(object.capacitorIsCharged);
            if (object.wheelsLocked != null)
                message.wheelsLocked = object.wheelsLocked | 0;
            if (object.wheelsBraking != null)
                message.wheelsBraking = object.wheelsBraking | 0;
            if (object.batteryLevel != null)
                message.batteryLevel = Number(object.batteryLevel);
            if (object.signalStrength != null)
                message.signalStrength = object.signalStrength | 0;
            return message;
        };

        /**
         * Creates a plain object from a RobotFeedback message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RobotFeedback
         * @static
         * @param {proto.RobotFeedback} message RobotFeedback
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RobotFeedback.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = 0;
                object.ballSensorSeesBall = false;
                object.ballPosition = 0;
                object.ballSensorIsWorking = false;
                object.dribblerSeesBall = false;
                object.estimatedVelocityX = 0;
                object.estimatedVelocityY = 0;
                object.estimatedAngle = 0;
                object.xsensIsCalibrated = false;
                object.capacitorIsCharged = false;
                object.wheelsLocked = 0;
                object.wheelsBraking = 0;
                object.batteryLevel = 0;
                object.signalStrength = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.ballSensorSeesBall != null && message.hasOwnProperty("ballSensorSeesBall"))
                object.ballSensorSeesBall = message.ballSensorSeesBall;
            if (message.ballPosition != null && message.hasOwnProperty("ballPosition"))
                object.ballPosition = options.json && !isFinite(message.ballPosition) ? String(message.ballPosition) : message.ballPosition;
            if (message.ballSensorIsWorking != null && message.hasOwnProperty("ballSensorIsWorking"))
                object.ballSensorIsWorking = message.ballSensorIsWorking;
            if (message.dribblerSeesBall != null && message.hasOwnProperty("dribblerSeesBall"))
                object.dribblerSeesBall = message.dribblerSeesBall;
            if (message.estimatedVelocityX != null && message.hasOwnProperty("estimatedVelocityX"))
                object.estimatedVelocityX = options.json && !isFinite(message.estimatedVelocityX) ? String(message.estimatedVelocityX) : message.estimatedVelocityX;
            if (message.estimatedVelocityY != null && message.hasOwnProperty("estimatedVelocityY"))
                object.estimatedVelocityY = options.json && !isFinite(message.estimatedVelocityY) ? String(message.estimatedVelocityY) : message.estimatedVelocityY;
            if (message.estimatedAngle != null && message.hasOwnProperty("estimatedAngle"))
                object.estimatedAngle = options.json && !isFinite(message.estimatedAngle) ? String(message.estimatedAngle) : message.estimatedAngle;
            if (message.xsensIsCalibrated != null && message.hasOwnProperty("xsensIsCalibrated"))
                object.xsensIsCalibrated = message.xsensIsCalibrated;
            if (message.capacitorIsCharged != null && message.hasOwnProperty("capacitorIsCharged"))
                object.capacitorIsCharged = message.capacitorIsCharged;
            if (message.wheelsLocked != null && message.hasOwnProperty("wheelsLocked"))
                object.wheelsLocked = message.wheelsLocked;
            if (message.wheelsBraking != null && message.hasOwnProperty("wheelsBraking"))
                object.wheelsBraking = message.wheelsBraking;
            if (message.batteryLevel != null && message.hasOwnProperty("batteryLevel"))
                object.batteryLevel = options.json && !isFinite(message.batteryLevel) ? String(message.batteryLevel) : message.batteryLevel;
            if (message.signalStrength != null && message.hasOwnProperty("signalStrength"))
                object.signalStrength = message.signalStrength;
            return object;
        };

        /**
         * Converts this RobotFeedback to JSON.
         * @function toJSON
         * @memberof proto.RobotFeedback
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RobotFeedback.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RobotFeedback
         * @function getTypeUrl
         * @memberof proto.RobotFeedback
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RobotFeedback.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RobotFeedback";
        };

        return RobotFeedback;
    })();

    proto.RobotsFeedback = (function() {

        /**
         * Properties of a RobotsFeedback.
         * @memberof proto
         * @interface IRobotsFeedback
         * @property {proto.RobotTeam|null} [team] RobotsFeedback team
         * @property {proto.RobotFeedbackSource|null} [source] RobotsFeedback source
         * @property {Array.<proto.IRobotFeedback>|null} [robotsFeedback] RobotsFeedback robotsFeedback
         */

        /**
         * Constructs a new RobotsFeedback.
         * @memberof proto
         * @classdesc Represents a RobotsFeedback.
         * @implements IRobotsFeedback
         * @constructor
         * @param {proto.IRobotsFeedback=} [properties] Properties to set
         */
        function RobotsFeedback(properties) {
            this.robotsFeedback = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RobotsFeedback team.
         * @member {proto.RobotTeam} team
         * @memberof proto.RobotsFeedback
         * @instance
         */
        RobotsFeedback.prototype.team = 0;

        /**
         * RobotsFeedback source.
         * @member {proto.RobotFeedbackSource} source
         * @memberof proto.RobotsFeedback
         * @instance
         */
        RobotsFeedback.prototype.source = 0;

        /**
         * RobotsFeedback robotsFeedback.
         * @member {Array.<proto.IRobotFeedback>} robotsFeedback
         * @memberof proto.RobotsFeedback
         * @instance
         */
        RobotsFeedback.prototype.robotsFeedback = $util.emptyArray;

        /**
         * Creates a new RobotsFeedback instance using the specified properties.
         * @function create
         * @memberof proto.RobotsFeedback
         * @static
         * @param {proto.IRobotsFeedback=} [properties] Properties to set
         * @returns {proto.RobotsFeedback} RobotsFeedback instance
         */
        RobotsFeedback.create = function create(properties) {
            return new RobotsFeedback(properties);
        };

        /**
         * Encodes the specified RobotsFeedback message. Does not implicitly {@link proto.RobotsFeedback.verify|verify} messages.
         * @function encode
         * @memberof proto.RobotsFeedback
         * @static
         * @param {proto.IRobotsFeedback} message RobotsFeedback message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotsFeedback.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.team != null && Object.hasOwnProperty.call(message, "team"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.team);
            if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.source);
            if (message.robotsFeedback != null && message.robotsFeedback.length)
                for (let i = 0; i < message.robotsFeedback.length; ++i)
                    $root.proto.RobotFeedback.encode(message.robotsFeedback[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RobotsFeedback message, length delimited. Does not implicitly {@link proto.RobotsFeedback.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RobotsFeedback
         * @static
         * @param {proto.IRobotsFeedback} message RobotsFeedback message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotsFeedback.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RobotsFeedback message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RobotsFeedback
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RobotsFeedback} RobotsFeedback
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotsFeedback.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RobotsFeedback();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.team = reader.int32();
                        break;
                    }
                case 2: {
                        message.source = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.robotsFeedback && message.robotsFeedback.length))
                            message.robotsFeedback = [];
                        message.robotsFeedback.push($root.proto.RobotFeedback.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RobotsFeedback message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RobotsFeedback
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RobotsFeedback} RobotsFeedback
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotsFeedback.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RobotsFeedback message.
         * @function verify
         * @memberof proto.RobotsFeedback
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RobotsFeedback.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.team != null && message.hasOwnProperty("team"))
                switch (message.team) {
                default:
                    return "team: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.source != null && message.hasOwnProperty("source"))
                switch (message.source) {
                default:
                    return "source: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.robotsFeedback != null && message.hasOwnProperty("robotsFeedback")) {
                if (!Array.isArray(message.robotsFeedback))
                    return "robotsFeedback: array expected";
                for (let i = 0; i < message.robotsFeedback.length; ++i) {
                    let error = $root.proto.RobotFeedback.verify(message.robotsFeedback[i]);
                    if (error)
                        return "robotsFeedback." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RobotsFeedback message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RobotsFeedback
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RobotsFeedback} RobotsFeedback
         */
        RobotsFeedback.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RobotsFeedback)
                return object;
            let message = new $root.proto.RobotsFeedback();
            switch (object.team) {
            default:
                if (typeof object.team === "number") {
                    message.team = object.team;
                    break;
                }
                break;
            case "YELLOW_TEAM":
            case 0:
                message.team = 0;
                break;
            case "BLUE_TEAM":
            case 1:
                message.team = 1;
                break;
            }
            switch (object.source) {
            default:
                if (typeof object.source === "number") {
                    message.source = object.source;
                    break;
                }
                break;
            case "SIMULATOR":
            case 0:
                message.source = 0;
                break;
            case "BASESTATION":
            case 1:
                message.source = 1;
                break;
            }
            if (object.robotsFeedback) {
                if (!Array.isArray(object.robotsFeedback))
                    throw TypeError(".proto.RobotsFeedback.robotsFeedback: array expected");
                message.robotsFeedback = [];
                for (let i = 0; i < object.robotsFeedback.length; ++i) {
                    if (typeof object.robotsFeedback[i] !== "object")
                        throw TypeError(".proto.RobotsFeedback.robotsFeedback: object expected");
                    message.robotsFeedback[i] = $root.proto.RobotFeedback.fromObject(object.robotsFeedback[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RobotsFeedback message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RobotsFeedback
         * @static
         * @param {proto.RobotsFeedback} message RobotsFeedback
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RobotsFeedback.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.robotsFeedback = [];
            if (options.defaults) {
                object.team = options.enums === String ? "YELLOW_TEAM" : 0;
                object.source = options.enums === String ? "SIMULATOR" : 0;
            }
            if (message.team != null && message.hasOwnProperty("team"))
                object.team = options.enums === String ? $root.proto.RobotTeam[message.team] === undefined ? message.team : $root.proto.RobotTeam[message.team] : message.team;
            if (message.source != null && message.hasOwnProperty("source"))
                object.source = options.enums === String ? $root.proto.RobotFeedbackSource[message.source] === undefined ? message.source : $root.proto.RobotFeedbackSource[message.source] : message.source;
            if (message.robotsFeedback && message.robotsFeedback.length) {
                object.robotsFeedback = [];
                for (let j = 0; j < message.robotsFeedback.length; ++j)
                    object.robotsFeedback[j] = $root.proto.RobotFeedback.toObject(message.robotsFeedback[j], options);
            }
            return object;
        };

        /**
         * Converts this RobotsFeedback to JSON.
         * @function toJSON
         * @memberof proto.RobotsFeedback
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RobotsFeedback.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RobotsFeedback
         * @function getTypeUrl
         * @memberof proto.RobotsFeedback
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RobotsFeedback.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RobotsFeedback";
        };

        return RobotsFeedback;
    })();

    proto.RobotCommand = (function() {

        /**
         * Properties of a RobotCommand.
         * @memberof proto
         * @interface IRobotCommand
         * @property {number|null} [id] RobotCommand id
         * @property {number|null} [velocityX] RobotCommand velocityX
         * @property {number|null} [velocityY] RobotCommand velocityY
         * @property {number|null} [angle] RobotCommand angle
         * @property {number|null} [angularVelocity] RobotCommand angularVelocity
         * @property {boolean|null} [useAngularVelocity] RobotCommand useAngularVelocity
         * @property {number|null} [cameraAngleOfRobot] RobotCommand cameraAngleOfRobot
         * @property {boolean|null} [cameraAngleOfRobotIsSet] RobotCommand cameraAngleOfRobotIsSet
         * @property {number|null} [kickSpeed] RobotCommand kickSpeed
         * @property {boolean|null} [waitForBall] RobotCommand waitForBall
         * @property {boolean|null} [kickAtAngle] RobotCommand kickAtAngle
         * @property {proto.RobotCommand.KickType|null} [kickType] RobotCommand kickType
         * @property {number|null} [dribblerSpeed] RobotCommand dribblerSpeed
         * @property {boolean|null} [ignorePacket] RobotCommand ignorePacket
         */

        /**
         * Constructs a new RobotCommand.
         * @memberof proto
         * @classdesc Represents a RobotCommand.
         * @implements IRobotCommand
         * @constructor
         * @param {proto.IRobotCommand=} [properties] Properties to set
         */
        function RobotCommand(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RobotCommand id.
         * @member {number} id
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.id = 0;

        /**
         * RobotCommand velocityX.
         * @member {number} velocityX
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.velocityX = 0;

        /**
         * RobotCommand velocityY.
         * @member {number} velocityY
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.velocityY = 0;

        /**
         * RobotCommand angle.
         * @member {number} angle
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.angle = 0;

        /**
         * RobotCommand angularVelocity.
         * @member {number} angularVelocity
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.angularVelocity = 0;

        /**
         * RobotCommand useAngularVelocity.
         * @member {boolean} useAngularVelocity
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.useAngularVelocity = false;

        /**
         * RobotCommand cameraAngleOfRobot.
         * @member {number} cameraAngleOfRobot
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.cameraAngleOfRobot = 0;

        /**
         * RobotCommand cameraAngleOfRobotIsSet.
         * @member {boolean} cameraAngleOfRobotIsSet
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.cameraAngleOfRobotIsSet = false;

        /**
         * RobotCommand kickSpeed.
         * @member {number} kickSpeed
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.kickSpeed = 0;

        /**
         * RobotCommand waitForBall.
         * @member {boolean} waitForBall
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.waitForBall = false;

        /**
         * RobotCommand kickAtAngle.
         * @member {boolean} kickAtAngle
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.kickAtAngle = false;

        /**
         * RobotCommand kickType.
         * @member {proto.RobotCommand.KickType} kickType
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.kickType = 0;

        /**
         * RobotCommand dribblerSpeed.
         * @member {number} dribblerSpeed
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.dribblerSpeed = 0;

        /**
         * RobotCommand ignorePacket.
         * @member {boolean} ignorePacket
         * @memberof proto.RobotCommand
         * @instance
         */
        RobotCommand.prototype.ignorePacket = false;

        /**
         * Creates a new RobotCommand instance using the specified properties.
         * @function create
         * @memberof proto.RobotCommand
         * @static
         * @param {proto.IRobotCommand=} [properties] Properties to set
         * @returns {proto.RobotCommand} RobotCommand instance
         */
        RobotCommand.create = function create(properties) {
            return new RobotCommand(properties);
        };

        /**
         * Encodes the specified RobotCommand message. Does not implicitly {@link proto.RobotCommand.verify|verify} messages.
         * @function encode
         * @memberof proto.RobotCommand
         * @static
         * @param {proto.IRobotCommand} message RobotCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotCommand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.velocityX != null && Object.hasOwnProperty.call(message, "velocityX"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.velocityX);
            if (message.velocityY != null && Object.hasOwnProperty.call(message, "velocityY"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.velocityY);
            if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.angle);
            if (message.angularVelocity != null && Object.hasOwnProperty.call(message, "angularVelocity"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.angularVelocity);
            if (message.useAngularVelocity != null && Object.hasOwnProperty.call(message, "useAngularVelocity"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.useAngularVelocity);
            if (message.cameraAngleOfRobot != null && Object.hasOwnProperty.call(message, "cameraAngleOfRobot"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.cameraAngleOfRobot);
            if (message.cameraAngleOfRobotIsSet != null && Object.hasOwnProperty.call(message, "cameraAngleOfRobotIsSet"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.cameraAngleOfRobotIsSet);
            if (message.kickSpeed != null && Object.hasOwnProperty.call(message, "kickSpeed"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.kickSpeed);
            if (message.waitForBall != null && Object.hasOwnProperty.call(message, "waitForBall"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.waitForBall);
            if (message.kickAtAngle != null && Object.hasOwnProperty.call(message, "kickAtAngle"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.kickAtAngle);
            if (message.kickType != null && Object.hasOwnProperty.call(message, "kickType"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.kickType);
            if (message.dribblerSpeed != null && Object.hasOwnProperty.call(message, "dribblerSpeed"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.dribblerSpeed);
            if (message.ignorePacket != null && Object.hasOwnProperty.call(message, "ignorePacket"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.ignorePacket);
            return writer;
        };

        /**
         * Encodes the specified RobotCommand message, length delimited. Does not implicitly {@link proto.RobotCommand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RobotCommand
         * @static
         * @param {proto.IRobotCommand} message RobotCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotCommand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RobotCommand message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RobotCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RobotCommand} RobotCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotCommand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RobotCommand();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.velocityX = reader.double();
                        break;
                    }
                case 3: {
                        message.velocityY = reader.double();
                        break;
                    }
                case 4: {
                        message.angle = reader.double();
                        break;
                    }
                case 5: {
                        message.angularVelocity = reader.double();
                        break;
                    }
                case 6: {
                        message.useAngularVelocity = reader.bool();
                        break;
                    }
                case 7: {
                        message.cameraAngleOfRobot = reader.double();
                        break;
                    }
                case 8: {
                        message.cameraAngleOfRobotIsSet = reader.bool();
                        break;
                    }
                case 9: {
                        message.kickSpeed = reader.double();
                        break;
                    }
                case 10: {
                        message.waitForBall = reader.bool();
                        break;
                    }
                case 11: {
                        message.kickAtAngle = reader.bool();
                        break;
                    }
                case 12: {
                        message.kickType = reader.int32();
                        break;
                    }
                case 13: {
                        message.dribblerSpeed = reader.double();
                        break;
                    }
                case 14: {
                        message.ignorePacket = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RobotCommand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RobotCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RobotCommand} RobotCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotCommand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RobotCommand message.
         * @function verify
         * @memberof proto.RobotCommand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RobotCommand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.velocityX != null && message.hasOwnProperty("velocityX"))
                if (typeof message.velocityX !== "number")
                    return "velocityX: number expected";
            if (message.velocityY != null && message.hasOwnProperty("velocityY"))
                if (typeof message.velocityY !== "number")
                    return "velocityY: number expected";
            if (message.angle != null && message.hasOwnProperty("angle"))
                if (typeof message.angle !== "number")
                    return "angle: number expected";
            if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity"))
                if (typeof message.angularVelocity !== "number")
                    return "angularVelocity: number expected";
            if (message.useAngularVelocity != null && message.hasOwnProperty("useAngularVelocity"))
                if (typeof message.useAngularVelocity !== "boolean")
                    return "useAngularVelocity: boolean expected";
            if (message.cameraAngleOfRobot != null && message.hasOwnProperty("cameraAngleOfRobot"))
                if (typeof message.cameraAngleOfRobot !== "number")
                    return "cameraAngleOfRobot: number expected";
            if (message.cameraAngleOfRobotIsSet != null && message.hasOwnProperty("cameraAngleOfRobotIsSet"))
                if (typeof message.cameraAngleOfRobotIsSet !== "boolean")
                    return "cameraAngleOfRobotIsSet: boolean expected";
            if (message.kickSpeed != null && message.hasOwnProperty("kickSpeed"))
                if (typeof message.kickSpeed !== "number")
                    return "kickSpeed: number expected";
            if (message.waitForBall != null && message.hasOwnProperty("waitForBall"))
                if (typeof message.waitForBall !== "boolean")
                    return "waitForBall: boolean expected";
            if (message.kickAtAngle != null && message.hasOwnProperty("kickAtAngle"))
                if (typeof message.kickAtAngle !== "boolean")
                    return "kickAtAngle: boolean expected";
            if (message.kickType != null && message.hasOwnProperty("kickType"))
                switch (message.kickType) {
                default:
                    return "kickType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.dribblerSpeed != null && message.hasOwnProperty("dribblerSpeed"))
                if (typeof message.dribblerSpeed !== "number")
                    return "dribblerSpeed: number expected";
            if (message.ignorePacket != null && message.hasOwnProperty("ignorePacket"))
                if (typeof message.ignorePacket !== "boolean")
                    return "ignorePacket: boolean expected";
            return null;
        };

        /**
         * Creates a RobotCommand message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RobotCommand
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RobotCommand} RobotCommand
         */
        RobotCommand.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RobotCommand)
                return object;
            let message = new $root.proto.RobotCommand();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.velocityX != null)
                message.velocityX = Number(object.velocityX);
            if (object.velocityY != null)
                message.velocityY = Number(object.velocityY);
            if (object.angle != null)
                message.angle = Number(object.angle);
            if (object.angularVelocity != null)
                message.angularVelocity = Number(object.angularVelocity);
            if (object.useAngularVelocity != null)
                message.useAngularVelocity = Boolean(object.useAngularVelocity);
            if (object.cameraAngleOfRobot != null)
                message.cameraAngleOfRobot = Number(object.cameraAngleOfRobot);
            if (object.cameraAngleOfRobotIsSet != null)
                message.cameraAngleOfRobotIsSet = Boolean(object.cameraAngleOfRobotIsSet);
            if (object.kickSpeed != null)
                message.kickSpeed = Number(object.kickSpeed);
            if (object.waitForBall != null)
                message.waitForBall = Boolean(object.waitForBall);
            if (object.kickAtAngle != null)
                message.kickAtAngle = Boolean(object.kickAtAngle);
            switch (object.kickType) {
            default:
                if (typeof object.kickType === "number") {
                    message.kickType = object.kickType;
                    break;
                }
                break;
            case "NO_KICK":
            case 0:
                message.kickType = 0;
                break;
            case "KICK":
            case 1:
                message.kickType = 1;
                break;
            case "CHIP":
            case 2:
                message.kickType = 2;
                break;
            }
            if (object.dribblerSpeed != null)
                message.dribblerSpeed = Number(object.dribblerSpeed);
            if (object.ignorePacket != null)
                message.ignorePacket = Boolean(object.ignorePacket);
            return message;
        };

        /**
         * Creates a plain object from a RobotCommand message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RobotCommand
         * @static
         * @param {proto.RobotCommand} message RobotCommand
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RobotCommand.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = 0;
                object.velocityX = 0;
                object.velocityY = 0;
                object.angle = 0;
                object.angularVelocity = 0;
                object.useAngularVelocity = false;
                object.cameraAngleOfRobot = 0;
                object.cameraAngleOfRobotIsSet = false;
                object.kickSpeed = 0;
                object.waitForBall = false;
                object.kickAtAngle = false;
                object.kickType = options.enums === String ? "NO_KICK" : 0;
                object.dribblerSpeed = 0;
                object.ignorePacket = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.velocityX != null && message.hasOwnProperty("velocityX"))
                object.velocityX = options.json && !isFinite(message.velocityX) ? String(message.velocityX) : message.velocityX;
            if (message.velocityY != null && message.hasOwnProperty("velocityY"))
                object.velocityY = options.json && !isFinite(message.velocityY) ? String(message.velocityY) : message.velocityY;
            if (message.angle != null && message.hasOwnProperty("angle"))
                object.angle = options.json && !isFinite(message.angle) ? String(message.angle) : message.angle;
            if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity"))
                object.angularVelocity = options.json && !isFinite(message.angularVelocity) ? String(message.angularVelocity) : message.angularVelocity;
            if (message.useAngularVelocity != null && message.hasOwnProperty("useAngularVelocity"))
                object.useAngularVelocity = message.useAngularVelocity;
            if (message.cameraAngleOfRobot != null && message.hasOwnProperty("cameraAngleOfRobot"))
                object.cameraAngleOfRobot = options.json && !isFinite(message.cameraAngleOfRobot) ? String(message.cameraAngleOfRobot) : message.cameraAngleOfRobot;
            if (message.cameraAngleOfRobotIsSet != null && message.hasOwnProperty("cameraAngleOfRobotIsSet"))
                object.cameraAngleOfRobotIsSet = message.cameraAngleOfRobotIsSet;
            if (message.kickSpeed != null && message.hasOwnProperty("kickSpeed"))
                object.kickSpeed = options.json && !isFinite(message.kickSpeed) ? String(message.kickSpeed) : message.kickSpeed;
            if (message.waitForBall != null && message.hasOwnProperty("waitForBall"))
                object.waitForBall = message.waitForBall;
            if (message.kickAtAngle != null && message.hasOwnProperty("kickAtAngle"))
                object.kickAtAngle = message.kickAtAngle;
            if (message.kickType != null && message.hasOwnProperty("kickType"))
                object.kickType = options.enums === String ? $root.proto.RobotCommand.KickType[message.kickType] === undefined ? message.kickType : $root.proto.RobotCommand.KickType[message.kickType] : message.kickType;
            if (message.dribblerSpeed != null && message.hasOwnProperty("dribblerSpeed"))
                object.dribblerSpeed = options.json && !isFinite(message.dribblerSpeed) ? String(message.dribblerSpeed) : message.dribblerSpeed;
            if (message.ignorePacket != null && message.hasOwnProperty("ignorePacket"))
                object.ignorePacket = message.ignorePacket;
            return object;
        };

        /**
         * Converts this RobotCommand to JSON.
         * @function toJSON
         * @memberof proto.RobotCommand
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RobotCommand.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RobotCommand
         * @function getTypeUrl
         * @memberof proto.RobotCommand
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RobotCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RobotCommand";
        };

        /**
         * KickType enum.
         * @name proto.RobotCommand.KickType
         * @enum {number}
         * @property {number} NO_KICK=0 NO_KICK value
         * @property {number} KICK=1 KICK value
         * @property {number} CHIP=2 CHIP value
         */
        RobotCommand.KickType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NO_KICK"] = 0;
            values[valuesById[1] = "KICK"] = 1;
            values[valuesById[2] = "CHIP"] = 2;
            return values;
        })();

        return RobotCommand;
    })();

    proto.RobotCommands = (function() {

        /**
         * Properties of a RobotCommands.
         * @memberof proto
         * @interface IRobotCommands
         * @property {Array.<proto.IRobotCommand>|null} [robotCommands] RobotCommands robotCommands
         */

        /**
         * Constructs a new RobotCommands.
         * @memberof proto
         * @classdesc Represents a RobotCommands.
         * @implements IRobotCommands
         * @constructor
         * @param {proto.IRobotCommands=} [properties] Properties to set
         */
        function RobotCommands(properties) {
            this.robotCommands = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RobotCommands robotCommands.
         * @member {Array.<proto.IRobotCommand>} robotCommands
         * @memberof proto.RobotCommands
         * @instance
         */
        RobotCommands.prototype.robotCommands = $util.emptyArray;

        /**
         * Creates a new RobotCommands instance using the specified properties.
         * @function create
         * @memberof proto.RobotCommands
         * @static
         * @param {proto.IRobotCommands=} [properties] Properties to set
         * @returns {proto.RobotCommands} RobotCommands instance
         */
        RobotCommands.create = function create(properties) {
            return new RobotCommands(properties);
        };

        /**
         * Encodes the specified RobotCommands message. Does not implicitly {@link proto.RobotCommands.verify|verify} messages.
         * @function encode
         * @memberof proto.RobotCommands
         * @static
         * @param {proto.IRobotCommands} message RobotCommands message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotCommands.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.robotCommands != null && message.robotCommands.length)
                for (let i = 0; i < message.robotCommands.length; ++i)
                    $root.proto.RobotCommand.encode(message.robotCommands[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RobotCommands message, length delimited. Does not implicitly {@link proto.RobotCommands.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.RobotCommands
         * @static
         * @param {proto.IRobotCommands} message RobotCommands message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RobotCommands.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RobotCommands message from the specified reader or buffer.
         * @function decode
         * @memberof proto.RobotCommands
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.RobotCommands} RobotCommands
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotCommands.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.RobotCommands();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.robotCommands && message.robotCommands.length))
                            message.robotCommands = [];
                        message.robotCommands.push($root.proto.RobotCommand.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RobotCommands message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.RobotCommands
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.RobotCommands} RobotCommands
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RobotCommands.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RobotCommands message.
         * @function verify
         * @memberof proto.RobotCommands
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RobotCommands.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.robotCommands != null && message.hasOwnProperty("robotCommands")) {
                if (!Array.isArray(message.robotCommands))
                    return "robotCommands: array expected";
                for (let i = 0; i < message.robotCommands.length; ++i) {
                    let error = $root.proto.RobotCommand.verify(message.robotCommands[i]);
                    if (error)
                        return "robotCommands." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RobotCommands message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.RobotCommands
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.RobotCommands} RobotCommands
         */
        RobotCommands.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.RobotCommands)
                return object;
            let message = new $root.proto.RobotCommands();
            if (object.robotCommands) {
                if (!Array.isArray(object.robotCommands))
                    throw TypeError(".proto.RobotCommands.robotCommands: array expected");
                message.robotCommands = [];
                for (let i = 0; i < object.robotCommands.length; ++i) {
                    if (typeof object.robotCommands[i] !== "object")
                        throw TypeError(".proto.RobotCommands.robotCommands: object expected");
                    message.robotCommands[i] = $root.proto.RobotCommand.fromObject(object.robotCommands[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RobotCommands message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.RobotCommands
         * @static
         * @param {proto.RobotCommands} message RobotCommands
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RobotCommands.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.robotCommands = [];
            if (message.robotCommands && message.robotCommands.length) {
                object.robotCommands = [];
                for (let j = 0; j < message.robotCommands.length; ++j)
                    object.robotCommands[j] = $root.proto.RobotCommand.toObject(message.robotCommands[j], options);
            }
            return object;
        };

        /**
         * Converts this RobotCommands to JSON.
         * @function toJSON
         * @memberof proto.RobotCommands
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RobotCommands.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RobotCommands
         * @function getTypeUrl
         * @memberof proto.RobotCommands
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RobotCommands.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.RobotCommands";
        };

        return RobotCommands;
    })();

    proto.SimulationBallLocation = (function() {

        /**
         * Properties of a SimulationBallLocation.
         * @memberof proto
         * @interface ISimulationBallLocation
         * @property {number|null} [x] SimulationBallLocation x
         * @property {number|null} [y] SimulationBallLocation y
         * @property {number|null} [z] SimulationBallLocation z
         * @property {number|null} [xVelocity] SimulationBallLocation xVelocity
         * @property {number|null} [yVelocity] SimulationBallLocation yVelocity
         * @property {number|null} [zVelocity] SimulationBallLocation zVelocity
         * @property {boolean|null} [velocityInRolling] SimulationBallLocation velocityInRolling
         * @property {boolean|null} [teleportSafely] SimulationBallLocation teleportSafely
         * @property {boolean|null} [byForce] SimulationBallLocation byForce
         */

        /**
         * Constructs a new SimulationBallLocation.
         * @memberof proto
         * @classdesc Represents a SimulationBallLocation.
         * @implements ISimulationBallLocation
         * @constructor
         * @param {proto.ISimulationBallLocation=} [properties] Properties to set
         */
        function SimulationBallLocation(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SimulationBallLocation x.
         * @member {number} x
         * @memberof proto.SimulationBallLocation
         * @instance
         */
        SimulationBallLocation.prototype.x = 0;

        /**
         * SimulationBallLocation y.
         * @member {number} y
         * @memberof proto.SimulationBallLocation
         * @instance
         */
        SimulationBallLocation.prototype.y = 0;

        /**
         * SimulationBallLocation z.
         * @member {number} z
         * @memberof proto.SimulationBallLocation
         * @instance
         */
        SimulationBallLocation.prototype.z = 0;

        /**
         * SimulationBallLocation xVelocity.
         * @member {number} xVelocity
         * @memberof proto.SimulationBallLocation
         * @instance
         */
        SimulationBallLocation.prototype.xVelocity = 0;

        /**
         * SimulationBallLocation yVelocity.
         * @member {number} yVelocity
         * @memberof proto.SimulationBallLocation
         * @instance
         */
        SimulationBallLocation.prototype.yVelocity = 0;

        /**
         * SimulationBallLocation zVelocity.
         * @member {number} zVelocity
         * @memberof proto.SimulationBallLocation
         * @instance
         */
        SimulationBallLocation.prototype.zVelocity = 0;

        /**
         * SimulationBallLocation velocityInRolling.
         * @member {boolean} velocityInRolling
         * @memberof proto.SimulationBallLocation
         * @instance
         */
        SimulationBallLocation.prototype.velocityInRolling = false;

        /**
         * SimulationBallLocation teleportSafely.
         * @member {boolean} teleportSafely
         * @memberof proto.SimulationBallLocation
         * @instance
         */
        SimulationBallLocation.prototype.teleportSafely = false;

        /**
         * SimulationBallLocation byForce.
         * @member {boolean} byForce
         * @memberof proto.SimulationBallLocation
         * @instance
         */
        SimulationBallLocation.prototype.byForce = false;

        /**
         * Creates a new SimulationBallLocation instance using the specified properties.
         * @function create
         * @memberof proto.SimulationBallLocation
         * @static
         * @param {proto.ISimulationBallLocation=} [properties] Properties to set
         * @returns {proto.SimulationBallLocation} SimulationBallLocation instance
         */
        SimulationBallLocation.create = function create(properties) {
            return new SimulationBallLocation(properties);
        };

        /**
         * Encodes the specified SimulationBallLocation message. Does not implicitly {@link proto.SimulationBallLocation.verify|verify} messages.
         * @function encode
         * @memberof proto.SimulationBallLocation
         * @static
         * @param {proto.ISimulationBallLocation} message SimulationBallLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimulationBallLocation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
            if (message.xVelocity != null && Object.hasOwnProperty.call(message, "xVelocity"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.xVelocity);
            if (message.yVelocity != null && Object.hasOwnProperty.call(message, "yVelocity"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.yVelocity);
            if (message.zVelocity != null && Object.hasOwnProperty.call(message, "zVelocity"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.zVelocity);
            if (message.velocityInRolling != null && Object.hasOwnProperty.call(message, "velocityInRolling"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.velocityInRolling);
            if (message.teleportSafely != null && Object.hasOwnProperty.call(message, "teleportSafely"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.teleportSafely);
            if (message.byForce != null && Object.hasOwnProperty.call(message, "byForce"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.byForce);
            return writer;
        };

        /**
         * Encodes the specified SimulationBallLocation message, length delimited. Does not implicitly {@link proto.SimulationBallLocation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SimulationBallLocation
         * @static
         * @param {proto.ISimulationBallLocation} message SimulationBallLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimulationBallLocation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimulationBallLocation message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SimulationBallLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SimulationBallLocation} SimulationBallLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimulationBallLocation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SimulationBallLocation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                case 3: {
                        message.z = reader.float();
                        break;
                    }
                case 4: {
                        message.xVelocity = reader.float();
                        break;
                    }
                case 5: {
                        message.yVelocity = reader.float();
                        break;
                    }
                case 6: {
                        message.zVelocity = reader.float();
                        break;
                    }
                case 7: {
                        message.velocityInRolling = reader.bool();
                        break;
                    }
                case 8: {
                        message.teleportSafely = reader.bool();
                        break;
                    }
                case 9: {
                        message.byForce = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimulationBallLocation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SimulationBallLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SimulationBallLocation} SimulationBallLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimulationBallLocation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimulationBallLocation message.
         * @function verify
         * @memberof proto.SimulationBallLocation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimulationBallLocation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            if (message.xVelocity != null && message.hasOwnProperty("xVelocity"))
                if (typeof message.xVelocity !== "number")
                    return "xVelocity: number expected";
            if (message.yVelocity != null && message.hasOwnProperty("yVelocity"))
                if (typeof message.yVelocity !== "number")
                    return "yVelocity: number expected";
            if (message.zVelocity != null && message.hasOwnProperty("zVelocity"))
                if (typeof message.zVelocity !== "number")
                    return "zVelocity: number expected";
            if (message.velocityInRolling != null && message.hasOwnProperty("velocityInRolling"))
                if (typeof message.velocityInRolling !== "boolean")
                    return "velocityInRolling: boolean expected";
            if (message.teleportSafely != null && message.hasOwnProperty("teleportSafely"))
                if (typeof message.teleportSafely !== "boolean")
                    return "teleportSafely: boolean expected";
            if (message.byForce != null && message.hasOwnProperty("byForce"))
                if (typeof message.byForce !== "boolean")
                    return "byForce: boolean expected";
            return null;
        };

        /**
         * Creates a SimulationBallLocation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SimulationBallLocation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SimulationBallLocation} SimulationBallLocation
         */
        SimulationBallLocation.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SimulationBallLocation)
                return object;
            let message = new $root.proto.SimulationBallLocation();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            if (object.xVelocity != null)
                message.xVelocity = Number(object.xVelocity);
            if (object.yVelocity != null)
                message.yVelocity = Number(object.yVelocity);
            if (object.zVelocity != null)
                message.zVelocity = Number(object.zVelocity);
            if (object.velocityInRolling != null)
                message.velocityInRolling = Boolean(object.velocityInRolling);
            if (object.teleportSafely != null)
                message.teleportSafely = Boolean(object.teleportSafely);
            if (object.byForce != null)
                message.byForce = Boolean(object.byForce);
            return message;
        };

        /**
         * Creates a plain object from a SimulationBallLocation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SimulationBallLocation
         * @static
         * @param {proto.SimulationBallLocation} message SimulationBallLocation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SimulationBallLocation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
                object.xVelocity = 0;
                object.yVelocity = 0;
                object.zVelocity = 0;
                object.velocityInRolling = false;
                object.teleportSafely = false;
                object.byForce = false;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            if (message.xVelocity != null && message.hasOwnProperty("xVelocity"))
                object.xVelocity = options.json && !isFinite(message.xVelocity) ? String(message.xVelocity) : message.xVelocity;
            if (message.yVelocity != null && message.hasOwnProperty("yVelocity"))
                object.yVelocity = options.json && !isFinite(message.yVelocity) ? String(message.yVelocity) : message.yVelocity;
            if (message.zVelocity != null && message.hasOwnProperty("zVelocity"))
                object.zVelocity = options.json && !isFinite(message.zVelocity) ? String(message.zVelocity) : message.zVelocity;
            if (message.velocityInRolling != null && message.hasOwnProperty("velocityInRolling"))
                object.velocityInRolling = message.velocityInRolling;
            if (message.teleportSafely != null && message.hasOwnProperty("teleportSafely"))
                object.teleportSafely = message.teleportSafely;
            if (message.byForce != null && message.hasOwnProperty("byForce"))
                object.byForce = message.byForce;
            return object;
        };

        /**
         * Converts this SimulationBallLocation to JSON.
         * @function toJSON
         * @memberof proto.SimulationBallLocation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SimulationBallLocation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SimulationBallLocation
         * @function getTypeUrl
         * @memberof proto.SimulationBallLocation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SimulationBallLocation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SimulationBallLocation";
        };

        return SimulationBallLocation;
    })();

    proto.SimulationRobotLocation = (function() {

        /**
         * Properties of a SimulationRobotLocation.
         * @memberof proto
         * @interface ISimulationRobotLocation
         * @property {number|null} [id] SimulationRobotLocation id
         * @property {boolean|null} [isTeamYellow] SimulationRobotLocation isTeamYellow
         * @property {number|null} [x] SimulationRobotLocation x
         * @property {number|null} [y] SimulationRobotLocation y
         * @property {number|null} [xVelocity] SimulationRobotLocation xVelocity
         * @property {number|null} [yVelocity] SimulationRobotLocation yVelocity
         * @property {number|null} [angularVelocity] SimulationRobotLocation angularVelocity
         * @property {number|null} [orientation] SimulationRobotLocation orientation
         * @property {boolean|null} [presentOnField] SimulationRobotLocation presentOnField
         * @property {boolean|null} [byForce] SimulationRobotLocation byForce
         */

        /**
         * Constructs a new SimulationRobotLocation.
         * @memberof proto
         * @classdesc Represents a SimulationRobotLocation.
         * @implements ISimulationRobotLocation
         * @constructor
         * @param {proto.ISimulationRobotLocation=} [properties] Properties to set
         */
        function SimulationRobotLocation(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SimulationRobotLocation id.
         * @member {number} id
         * @memberof proto.SimulationRobotLocation
         * @instance
         */
        SimulationRobotLocation.prototype.id = 0;

        /**
         * SimulationRobotLocation isTeamYellow.
         * @member {boolean} isTeamYellow
         * @memberof proto.SimulationRobotLocation
         * @instance
         */
        SimulationRobotLocation.prototype.isTeamYellow = false;

        /**
         * SimulationRobotLocation x.
         * @member {number} x
         * @memberof proto.SimulationRobotLocation
         * @instance
         */
        SimulationRobotLocation.prototype.x = 0;

        /**
         * SimulationRobotLocation y.
         * @member {number} y
         * @memberof proto.SimulationRobotLocation
         * @instance
         */
        SimulationRobotLocation.prototype.y = 0;

        /**
         * SimulationRobotLocation xVelocity.
         * @member {number} xVelocity
         * @memberof proto.SimulationRobotLocation
         * @instance
         */
        SimulationRobotLocation.prototype.xVelocity = 0;

        /**
         * SimulationRobotLocation yVelocity.
         * @member {number} yVelocity
         * @memberof proto.SimulationRobotLocation
         * @instance
         */
        SimulationRobotLocation.prototype.yVelocity = 0;

        /**
         * SimulationRobotLocation angularVelocity.
         * @member {number} angularVelocity
         * @memberof proto.SimulationRobotLocation
         * @instance
         */
        SimulationRobotLocation.prototype.angularVelocity = 0;

        /**
         * SimulationRobotLocation orientation.
         * @member {number} orientation
         * @memberof proto.SimulationRobotLocation
         * @instance
         */
        SimulationRobotLocation.prototype.orientation = 0;

        /**
         * SimulationRobotLocation presentOnField.
         * @member {boolean} presentOnField
         * @memberof proto.SimulationRobotLocation
         * @instance
         */
        SimulationRobotLocation.prototype.presentOnField = false;

        /**
         * SimulationRobotLocation byForce.
         * @member {boolean} byForce
         * @memberof proto.SimulationRobotLocation
         * @instance
         */
        SimulationRobotLocation.prototype.byForce = false;

        /**
         * Creates a new SimulationRobotLocation instance using the specified properties.
         * @function create
         * @memberof proto.SimulationRobotLocation
         * @static
         * @param {proto.ISimulationRobotLocation=} [properties] Properties to set
         * @returns {proto.SimulationRobotLocation} SimulationRobotLocation instance
         */
        SimulationRobotLocation.create = function create(properties) {
            return new SimulationRobotLocation(properties);
        };

        /**
         * Encodes the specified SimulationRobotLocation message. Does not implicitly {@link proto.SimulationRobotLocation.verify|verify} messages.
         * @function encode
         * @memberof proto.SimulationRobotLocation
         * @static
         * @param {proto.ISimulationRobotLocation} message SimulationRobotLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimulationRobotLocation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.isTeamYellow != null && Object.hasOwnProperty.call(message, "isTeamYellow"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isTeamYellow);
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.y);
            if (message.xVelocity != null && Object.hasOwnProperty.call(message, "xVelocity"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.xVelocity);
            if (message.yVelocity != null && Object.hasOwnProperty.call(message, "yVelocity"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.yVelocity);
            if (message.angularVelocity != null && Object.hasOwnProperty.call(message, "angularVelocity"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.angularVelocity);
            if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.orientation);
            if (message.presentOnField != null && Object.hasOwnProperty.call(message, "presentOnField"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.presentOnField);
            if (message.byForce != null && Object.hasOwnProperty.call(message, "byForce"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.byForce);
            return writer;
        };

        /**
         * Encodes the specified SimulationRobotLocation message, length delimited. Does not implicitly {@link proto.SimulationRobotLocation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SimulationRobotLocation
         * @static
         * @param {proto.ISimulationRobotLocation} message SimulationRobotLocation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimulationRobotLocation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimulationRobotLocation message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SimulationRobotLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SimulationRobotLocation} SimulationRobotLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimulationRobotLocation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SimulationRobotLocation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.isTeamYellow = reader.bool();
                        break;
                    }
                case 3: {
                        message.x = reader.float();
                        break;
                    }
                case 4: {
                        message.y = reader.float();
                        break;
                    }
                case 5: {
                        message.xVelocity = reader.float();
                        break;
                    }
                case 6: {
                        message.yVelocity = reader.float();
                        break;
                    }
                case 7: {
                        message.angularVelocity = reader.float();
                        break;
                    }
                case 8: {
                        message.orientation = reader.float();
                        break;
                    }
                case 9: {
                        message.presentOnField = reader.bool();
                        break;
                    }
                case 10: {
                        message.byForce = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimulationRobotLocation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SimulationRobotLocation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SimulationRobotLocation} SimulationRobotLocation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimulationRobotLocation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimulationRobotLocation message.
         * @function verify
         * @memberof proto.SimulationRobotLocation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimulationRobotLocation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.isTeamYellow != null && message.hasOwnProperty("isTeamYellow"))
                if (typeof message.isTeamYellow !== "boolean")
                    return "isTeamYellow: boolean expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.xVelocity != null && message.hasOwnProperty("xVelocity"))
                if (typeof message.xVelocity !== "number")
                    return "xVelocity: number expected";
            if (message.yVelocity != null && message.hasOwnProperty("yVelocity"))
                if (typeof message.yVelocity !== "number")
                    return "yVelocity: number expected";
            if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity"))
                if (typeof message.angularVelocity !== "number")
                    return "angularVelocity: number expected";
            if (message.orientation != null && message.hasOwnProperty("orientation"))
                if (typeof message.orientation !== "number")
                    return "orientation: number expected";
            if (message.presentOnField != null && message.hasOwnProperty("presentOnField"))
                if (typeof message.presentOnField !== "boolean")
                    return "presentOnField: boolean expected";
            if (message.byForce != null && message.hasOwnProperty("byForce"))
                if (typeof message.byForce !== "boolean")
                    return "byForce: boolean expected";
            return null;
        };

        /**
         * Creates a SimulationRobotLocation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SimulationRobotLocation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SimulationRobotLocation} SimulationRobotLocation
         */
        SimulationRobotLocation.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SimulationRobotLocation)
                return object;
            let message = new $root.proto.SimulationRobotLocation();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.isTeamYellow != null)
                message.isTeamYellow = Boolean(object.isTeamYellow);
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.xVelocity != null)
                message.xVelocity = Number(object.xVelocity);
            if (object.yVelocity != null)
                message.yVelocity = Number(object.yVelocity);
            if (object.angularVelocity != null)
                message.angularVelocity = Number(object.angularVelocity);
            if (object.orientation != null)
                message.orientation = Number(object.orientation);
            if (object.presentOnField != null)
                message.presentOnField = Boolean(object.presentOnField);
            if (object.byForce != null)
                message.byForce = Boolean(object.byForce);
            return message;
        };

        /**
         * Creates a plain object from a SimulationRobotLocation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SimulationRobotLocation
         * @static
         * @param {proto.SimulationRobotLocation} message SimulationRobotLocation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SimulationRobotLocation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = 0;
                object.isTeamYellow = false;
                object.x = 0;
                object.y = 0;
                object.xVelocity = 0;
                object.yVelocity = 0;
                object.angularVelocity = 0;
                object.orientation = 0;
                object.presentOnField = false;
                object.byForce = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.isTeamYellow != null && message.hasOwnProperty("isTeamYellow"))
                object.isTeamYellow = message.isTeamYellow;
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.xVelocity != null && message.hasOwnProperty("xVelocity"))
                object.xVelocity = options.json && !isFinite(message.xVelocity) ? String(message.xVelocity) : message.xVelocity;
            if (message.yVelocity != null && message.hasOwnProperty("yVelocity"))
                object.yVelocity = options.json && !isFinite(message.yVelocity) ? String(message.yVelocity) : message.yVelocity;
            if (message.angularVelocity != null && message.hasOwnProperty("angularVelocity"))
                object.angularVelocity = options.json && !isFinite(message.angularVelocity) ? String(message.angularVelocity) : message.angularVelocity;
            if (message.orientation != null && message.hasOwnProperty("orientation"))
                object.orientation = options.json && !isFinite(message.orientation) ? String(message.orientation) : message.orientation;
            if (message.presentOnField != null && message.hasOwnProperty("presentOnField"))
                object.presentOnField = message.presentOnField;
            if (message.byForce != null && message.hasOwnProperty("byForce"))
                object.byForce = message.byForce;
            return object;
        };

        /**
         * Converts this SimulationRobotLocation to JSON.
         * @function toJSON
         * @memberof proto.SimulationRobotLocation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SimulationRobotLocation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SimulationRobotLocation
         * @function getTypeUrl
         * @memberof proto.SimulationRobotLocation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SimulationRobotLocation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SimulationRobotLocation";
        };

        return SimulationRobotLocation;
    })();

    proto.SimulationRobotProperties = (function() {

        /**
         * Properties of a SimulationRobotProperties.
         * @memberof proto
         * @interface ISimulationRobotProperties
         * @property {number|null} [id] SimulationRobotProperties id
         * @property {boolean|null} [isTeamYellow] SimulationRobotProperties isTeamYellow
         * @property {number|null} [radius] SimulationRobotProperties radius
         * @property {number|null} [height] SimulationRobotProperties height
         * @property {number|null} [mass] SimulationRobotProperties mass
         * @property {number|null} [maxKickSpeed] SimulationRobotProperties maxKickSpeed
         * @property {number|null} [maxChipSpeed] SimulationRobotProperties maxChipSpeed
         * @property {number|null} [centerToDribblerDistance] SimulationRobotProperties centerToDribblerDistance
         * @property {number|null} [maxAcceleration] SimulationRobotProperties maxAcceleration
         * @property {number|null} [maxAngularAcceleration] SimulationRobotProperties maxAngularAcceleration
         * @property {number|null} [maxDeceleration] SimulationRobotProperties maxDeceleration
         * @property {number|null} [maxAngularDeceleration] SimulationRobotProperties maxAngularDeceleration
         * @property {number|null} [maxVelocity] SimulationRobotProperties maxVelocity
         * @property {number|null} [maxAngularVelocity] SimulationRobotProperties maxAngularVelocity
         * @property {number|null} [frontRightWheelAngle] SimulationRobotProperties frontRightWheelAngle
         * @property {number|null} [backRightWheelAngle] SimulationRobotProperties backRightWheelAngle
         * @property {number|null} [backLeftWheelAngle] SimulationRobotProperties backLeftWheelAngle
         * @property {number|null} [frontLeftWheelAngle] SimulationRobotProperties frontLeftWheelAngle
         */

        /**
         * Constructs a new SimulationRobotProperties.
         * @memberof proto
         * @classdesc Represents a SimulationRobotProperties.
         * @implements ISimulationRobotProperties
         * @constructor
         * @param {proto.ISimulationRobotProperties=} [properties] Properties to set
         */
        function SimulationRobotProperties(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SimulationRobotProperties id.
         * @member {number} id
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.id = 0;

        /**
         * SimulationRobotProperties isTeamYellow.
         * @member {boolean} isTeamYellow
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.isTeamYellow = false;

        /**
         * SimulationRobotProperties radius.
         * @member {number} radius
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.radius = 0;

        /**
         * SimulationRobotProperties height.
         * @member {number} height
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.height = 0;

        /**
         * SimulationRobotProperties mass.
         * @member {number} mass
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.mass = 0;

        /**
         * SimulationRobotProperties maxKickSpeed.
         * @member {number} maxKickSpeed
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.maxKickSpeed = 0;

        /**
         * SimulationRobotProperties maxChipSpeed.
         * @member {number} maxChipSpeed
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.maxChipSpeed = 0;

        /**
         * SimulationRobotProperties centerToDribblerDistance.
         * @member {number} centerToDribblerDistance
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.centerToDribblerDistance = 0;

        /**
         * SimulationRobotProperties maxAcceleration.
         * @member {number} maxAcceleration
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.maxAcceleration = 0;

        /**
         * SimulationRobotProperties maxAngularAcceleration.
         * @member {number} maxAngularAcceleration
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.maxAngularAcceleration = 0;

        /**
         * SimulationRobotProperties maxDeceleration.
         * @member {number} maxDeceleration
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.maxDeceleration = 0;

        /**
         * SimulationRobotProperties maxAngularDeceleration.
         * @member {number} maxAngularDeceleration
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.maxAngularDeceleration = 0;

        /**
         * SimulationRobotProperties maxVelocity.
         * @member {number} maxVelocity
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.maxVelocity = 0;

        /**
         * SimulationRobotProperties maxAngularVelocity.
         * @member {number} maxAngularVelocity
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.maxAngularVelocity = 0;

        /**
         * SimulationRobotProperties frontRightWheelAngle.
         * @member {number} frontRightWheelAngle
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.frontRightWheelAngle = 0;

        /**
         * SimulationRobotProperties backRightWheelAngle.
         * @member {number} backRightWheelAngle
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.backRightWheelAngle = 0;

        /**
         * SimulationRobotProperties backLeftWheelAngle.
         * @member {number} backLeftWheelAngle
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.backLeftWheelAngle = 0;

        /**
         * SimulationRobotProperties frontLeftWheelAngle.
         * @member {number} frontLeftWheelAngle
         * @memberof proto.SimulationRobotProperties
         * @instance
         */
        SimulationRobotProperties.prototype.frontLeftWheelAngle = 0;

        /**
         * Creates a new SimulationRobotProperties instance using the specified properties.
         * @function create
         * @memberof proto.SimulationRobotProperties
         * @static
         * @param {proto.ISimulationRobotProperties=} [properties] Properties to set
         * @returns {proto.SimulationRobotProperties} SimulationRobotProperties instance
         */
        SimulationRobotProperties.create = function create(properties) {
            return new SimulationRobotProperties(properties);
        };

        /**
         * Encodes the specified SimulationRobotProperties message. Does not implicitly {@link proto.SimulationRobotProperties.verify|verify} messages.
         * @function encode
         * @memberof proto.SimulationRobotProperties
         * @static
         * @param {proto.ISimulationRobotProperties} message SimulationRobotProperties message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimulationRobotProperties.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.isTeamYellow != null && Object.hasOwnProperty.call(message, "isTeamYellow"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isTeamYellow);
            if (message.radius != null && Object.hasOwnProperty.call(message, "radius"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.radius);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.height);
            if (message.mass != null && Object.hasOwnProperty.call(message, "mass"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.mass);
            if (message.maxKickSpeed != null && Object.hasOwnProperty.call(message, "maxKickSpeed"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.maxKickSpeed);
            if (message.maxChipSpeed != null && Object.hasOwnProperty.call(message, "maxChipSpeed"))
                writer.uint32(/* id 7, wireType 5 =*/61).float(message.maxChipSpeed);
            if (message.centerToDribblerDistance != null && Object.hasOwnProperty.call(message, "centerToDribblerDistance"))
                writer.uint32(/* id 8, wireType 5 =*/69).float(message.centerToDribblerDistance);
            if (message.maxAcceleration != null && Object.hasOwnProperty.call(message, "maxAcceleration"))
                writer.uint32(/* id 9, wireType 5 =*/77).float(message.maxAcceleration);
            if (message.maxAngularAcceleration != null && Object.hasOwnProperty.call(message, "maxAngularAcceleration"))
                writer.uint32(/* id 10, wireType 5 =*/85).float(message.maxAngularAcceleration);
            if (message.maxDeceleration != null && Object.hasOwnProperty.call(message, "maxDeceleration"))
                writer.uint32(/* id 11, wireType 5 =*/93).float(message.maxDeceleration);
            if (message.maxAngularDeceleration != null && Object.hasOwnProperty.call(message, "maxAngularDeceleration"))
                writer.uint32(/* id 12, wireType 5 =*/101).float(message.maxAngularDeceleration);
            if (message.maxVelocity != null && Object.hasOwnProperty.call(message, "maxVelocity"))
                writer.uint32(/* id 13, wireType 5 =*/109).float(message.maxVelocity);
            if (message.maxAngularVelocity != null && Object.hasOwnProperty.call(message, "maxAngularVelocity"))
                writer.uint32(/* id 14, wireType 5 =*/117).float(message.maxAngularVelocity);
            if (message.frontRightWheelAngle != null && Object.hasOwnProperty.call(message, "frontRightWheelAngle"))
                writer.uint32(/* id 15, wireType 5 =*/125).float(message.frontRightWheelAngle);
            if (message.backRightWheelAngle != null && Object.hasOwnProperty.call(message, "backRightWheelAngle"))
                writer.uint32(/* id 16, wireType 5 =*/133).float(message.backRightWheelAngle);
            if (message.backLeftWheelAngle != null && Object.hasOwnProperty.call(message, "backLeftWheelAngle"))
                writer.uint32(/* id 17, wireType 5 =*/141).float(message.backLeftWheelAngle);
            if (message.frontLeftWheelAngle != null && Object.hasOwnProperty.call(message, "frontLeftWheelAngle"))
                writer.uint32(/* id 18, wireType 5 =*/149).float(message.frontLeftWheelAngle);
            return writer;
        };

        /**
         * Encodes the specified SimulationRobotProperties message, length delimited. Does not implicitly {@link proto.SimulationRobotProperties.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SimulationRobotProperties
         * @static
         * @param {proto.ISimulationRobotProperties} message SimulationRobotProperties message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimulationRobotProperties.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimulationRobotProperties message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SimulationRobotProperties
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SimulationRobotProperties} SimulationRobotProperties
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimulationRobotProperties.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SimulationRobotProperties();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.isTeamYellow = reader.bool();
                        break;
                    }
                case 3: {
                        message.radius = reader.float();
                        break;
                    }
                case 4: {
                        message.height = reader.float();
                        break;
                    }
                case 5: {
                        message.mass = reader.float();
                        break;
                    }
                case 6: {
                        message.maxKickSpeed = reader.float();
                        break;
                    }
                case 7: {
                        message.maxChipSpeed = reader.float();
                        break;
                    }
                case 8: {
                        message.centerToDribblerDistance = reader.float();
                        break;
                    }
                case 9: {
                        message.maxAcceleration = reader.float();
                        break;
                    }
                case 10: {
                        message.maxAngularAcceleration = reader.float();
                        break;
                    }
                case 11: {
                        message.maxDeceleration = reader.float();
                        break;
                    }
                case 12: {
                        message.maxAngularDeceleration = reader.float();
                        break;
                    }
                case 13: {
                        message.maxVelocity = reader.float();
                        break;
                    }
                case 14: {
                        message.maxAngularVelocity = reader.float();
                        break;
                    }
                case 15: {
                        message.frontRightWheelAngle = reader.float();
                        break;
                    }
                case 16: {
                        message.backRightWheelAngle = reader.float();
                        break;
                    }
                case 17: {
                        message.backLeftWheelAngle = reader.float();
                        break;
                    }
                case 18: {
                        message.frontLeftWheelAngle = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimulationRobotProperties message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SimulationRobotProperties
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SimulationRobotProperties} SimulationRobotProperties
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimulationRobotProperties.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimulationRobotProperties message.
         * @function verify
         * @memberof proto.SimulationRobotProperties
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimulationRobotProperties.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.isTeamYellow != null && message.hasOwnProperty("isTeamYellow"))
                if (typeof message.isTeamYellow !== "boolean")
                    return "isTeamYellow: boolean expected";
            if (message.radius != null && message.hasOwnProperty("radius"))
                if (typeof message.radius !== "number")
                    return "radius: number expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (typeof message.height !== "number")
                    return "height: number expected";
            if (message.mass != null && message.hasOwnProperty("mass"))
                if (typeof message.mass !== "number")
                    return "mass: number expected";
            if (message.maxKickSpeed != null && message.hasOwnProperty("maxKickSpeed"))
                if (typeof message.maxKickSpeed !== "number")
                    return "maxKickSpeed: number expected";
            if (message.maxChipSpeed != null && message.hasOwnProperty("maxChipSpeed"))
                if (typeof message.maxChipSpeed !== "number")
                    return "maxChipSpeed: number expected";
            if (message.centerToDribblerDistance != null && message.hasOwnProperty("centerToDribblerDistance"))
                if (typeof message.centerToDribblerDistance !== "number")
                    return "centerToDribblerDistance: number expected";
            if (message.maxAcceleration != null && message.hasOwnProperty("maxAcceleration"))
                if (typeof message.maxAcceleration !== "number")
                    return "maxAcceleration: number expected";
            if (message.maxAngularAcceleration != null && message.hasOwnProperty("maxAngularAcceleration"))
                if (typeof message.maxAngularAcceleration !== "number")
                    return "maxAngularAcceleration: number expected";
            if (message.maxDeceleration != null && message.hasOwnProperty("maxDeceleration"))
                if (typeof message.maxDeceleration !== "number")
                    return "maxDeceleration: number expected";
            if (message.maxAngularDeceleration != null && message.hasOwnProperty("maxAngularDeceleration"))
                if (typeof message.maxAngularDeceleration !== "number")
                    return "maxAngularDeceleration: number expected";
            if (message.maxVelocity != null && message.hasOwnProperty("maxVelocity"))
                if (typeof message.maxVelocity !== "number")
                    return "maxVelocity: number expected";
            if (message.maxAngularVelocity != null && message.hasOwnProperty("maxAngularVelocity"))
                if (typeof message.maxAngularVelocity !== "number")
                    return "maxAngularVelocity: number expected";
            if (message.frontRightWheelAngle != null && message.hasOwnProperty("frontRightWheelAngle"))
                if (typeof message.frontRightWheelAngle !== "number")
                    return "frontRightWheelAngle: number expected";
            if (message.backRightWheelAngle != null && message.hasOwnProperty("backRightWheelAngle"))
                if (typeof message.backRightWheelAngle !== "number")
                    return "backRightWheelAngle: number expected";
            if (message.backLeftWheelAngle != null && message.hasOwnProperty("backLeftWheelAngle"))
                if (typeof message.backLeftWheelAngle !== "number")
                    return "backLeftWheelAngle: number expected";
            if (message.frontLeftWheelAngle != null && message.hasOwnProperty("frontLeftWheelAngle"))
                if (typeof message.frontLeftWheelAngle !== "number")
                    return "frontLeftWheelAngle: number expected";
            return null;
        };

        /**
         * Creates a SimulationRobotProperties message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SimulationRobotProperties
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SimulationRobotProperties} SimulationRobotProperties
         */
        SimulationRobotProperties.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SimulationRobotProperties)
                return object;
            let message = new $root.proto.SimulationRobotProperties();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.isTeamYellow != null)
                message.isTeamYellow = Boolean(object.isTeamYellow);
            if (object.radius != null)
                message.radius = Number(object.radius);
            if (object.height != null)
                message.height = Number(object.height);
            if (object.mass != null)
                message.mass = Number(object.mass);
            if (object.maxKickSpeed != null)
                message.maxKickSpeed = Number(object.maxKickSpeed);
            if (object.maxChipSpeed != null)
                message.maxChipSpeed = Number(object.maxChipSpeed);
            if (object.centerToDribblerDistance != null)
                message.centerToDribblerDistance = Number(object.centerToDribblerDistance);
            if (object.maxAcceleration != null)
                message.maxAcceleration = Number(object.maxAcceleration);
            if (object.maxAngularAcceleration != null)
                message.maxAngularAcceleration = Number(object.maxAngularAcceleration);
            if (object.maxDeceleration != null)
                message.maxDeceleration = Number(object.maxDeceleration);
            if (object.maxAngularDeceleration != null)
                message.maxAngularDeceleration = Number(object.maxAngularDeceleration);
            if (object.maxVelocity != null)
                message.maxVelocity = Number(object.maxVelocity);
            if (object.maxAngularVelocity != null)
                message.maxAngularVelocity = Number(object.maxAngularVelocity);
            if (object.frontRightWheelAngle != null)
                message.frontRightWheelAngle = Number(object.frontRightWheelAngle);
            if (object.backRightWheelAngle != null)
                message.backRightWheelAngle = Number(object.backRightWheelAngle);
            if (object.backLeftWheelAngle != null)
                message.backLeftWheelAngle = Number(object.backLeftWheelAngle);
            if (object.frontLeftWheelAngle != null)
                message.frontLeftWheelAngle = Number(object.frontLeftWheelAngle);
            return message;
        };

        /**
         * Creates a plain object from a SimulationRobotProperties message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SimulationRobotProperties
         * @static
         * @param {proto.SimulationRobotProperties} message SimulationRobotProperties
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SimulationRobotProperties.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = 0;
                object.isTeamYellow = false;
                object.radius = 0;
                object.height = 0;
                object.mass = 0;
                object.maxKickSpeed = 0;
                object.maxChipSpeed = 0;
                object.centerToDribblerDistance = 0;
                object.maxAcceleration = 0;
                object.maxAngularAcceleration = 0;
                object.maxDeceleration = 0;
                object.maxAngularDeceleration = 0;
                object.maxVelocity = 0;
                object.maxAngularVelocity = 0;
                object.frontRightWheelAngle = 0;
                object.backRightWheelAngle = 0;
                object.backLeftWheelAngle = 0;
                object.frontLeftWheelAngle = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.isTeamYellow != null && message.hasOwnProperty("isTeamYellow"))
                object.isTeamYellow = message.isTeamYellow;
            if (message.radius != null && message.hasOwnProperty("radius"))
                object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = options.json && !isFinite(message.height) ? String(message.height) : message.height;
            if (message.mass != null && message.hasOwnProperty("mass"))
                object.mass = options.json && !isFinite(message.mass) ? String(message.mass) : message.mass;
            if (message.maxKickSpeed != null && message.hasOwnProperty("maxKickSpeed"))
                object.maxKickSpeed = options.json && !isFinite(message.maxKickSpeed) ? String(message.maxKickSpeed) : message.maxKickSpeed;
            if (message.maxChipSpeed != null && message.hasOwnProperty("maxChipSpeed"))
                object.maxChipSpeed = options.json && !isFinite(message.maxChipSpeed) ? String(message.maxChipSpeed) : message.maxChipSpeed;
            if (message.centerToDribblerDistance != null && message.hasOwnProperty("centerToDribblerDistance"))
                object.centerToDribblerDistance = options.json && !isFinite(message.centerToDribblerDistance) ? String(message.centerToDribblerDistance) : message.centerToDribblerDistance;
            if (message.maxAcceleration != null && message.hasOwnProperty("maxAcceleration"))
                object.maxAcceleration = options.json && !isFinite(message.maxAcceleration) ? String(message.maxAcceleration) : message.maxAcceleration;
            if (message.maxAngularAcceleration != null && message.hasOwnProperty("maxAngularAcceleration"))
                object.maxAngularAcceleration = options.json && !isFinite(message.maxAngularAcceleration) ? String(message.maxAngularAcceleration) : message.maxAngularAcceleration;
            if (message.maxDeceleration != null && message.hasOwnProperty("maxDeceleration"))
                object.maxDeceleration = options.json && !isFinite(message.maxDeceleration) ? String(message.maxDeceleration) : message.maxDeceleration;
            if (message.maxAngularDeceleration != null && message.hasOwnProperty("maxAngularDeceleration"))
                object.maxAngularDeceleration = options.json && !isFinite(message.maxAngularDeceleration) ? String(message.maxAngularDeceleration) : message.maxAngularDeceleration;
            if (message.maxVelocity != null && message.hasOwnProperty("maxVelocity"))
                object.maxVelocity = options.json && !isFinite(message.maxVelocity) ? String(message.maxVelocity) : message.maxVelocity;
            if (message.maxAngularVelocity != null && message.hasOwnProperty("maxAngularVelocity"))
                object.maxAngularVelocity = options.json && !isFinite(message.maxAngularVelocity) ? String(message.maxAngularVelocity) : message.maxAngularVelocity;
            if (message.frontRightWheelAngle != null && message.hasOwnProperty("frontRightWheelAngle"))
                object.frontRightWheelAngle = options.json && !isFinite(message.frontRightWheelAngle) ? String(message.frontRightWheelAngle) : message.frontRightWheelAngle;
            if (message.backRightWheelAngle != null && message.hasOwnProperty("backRightWheelAngle"))
                object.backRightWheelAngle = options.json && !isFinite(message.backRightWheelAngle) ? String(message.backRightWheelAngle) : message.backRightWheelAngle;
            if (message.backLeftWheelAngle != null && message.hasOwnProperty("backLeftWheelAngle"))
                object.backLeftWheelAngle = options.json && !isFinite(message.backLeftWheelAngle) ? String(message.backLeftWheelAngle) : message.backLeftWheelAngle;
            if (message.frontLeftWheelAngle != null && message.hasOwnProperty("frontLeftWheelAngle"))
                object.frontLeftWheelAngle = options.json && !isFinite(message.frontLeftWheelAngle) ? String(message.frontLeftWheelAngle) : message.frontLeftWheelAngle;
            return object;
        };

        /**
         * Converts this SimulationRobotProperties to JSON.
         * @function toJSON
         * @memberof proto.SimulationRobotProperties
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SimulationRobotProperties.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SimulationRobotProperties
         * @function getTypeUrl
         * @memberof proto.SimulationRobotProperties
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SimulationRobotProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SimulationRobotProperties";
        };

        return SimulationRobotProperties;
    })();

    proto.SimulationConfiguration = (function() {

        /**
         * Properties of a SimulationConfiguration.
         * @memberof proto
         * @interface ISimulationConfiguration
         * @property {proto.ISimulationBallLocation|null} [ballLocation] SimulationConfiguration ballLocation
         * @property {Array.<proto.ISimulationRobotLocation>|null} [robotLocations] SimulationConfiguration robotLocations
         * @property {Array.<proto.ISimulationRobotProperties>|null} [robotProperties] SimulationConfiguration robotProperties
         * @property {number|null} [simulationSpeed] SimulationConfiguration simulationSpeed
         * @property {number|null} [visionPort] SimulationConfiguration visionPort
         */

        /**
         * Constructs a new SimulationConfiguration.
         * @memberof proto
         * @classdesc Represents a SimulationConfiguration.
         * @implements ISimulationConfiguration
         * @constructor
         * @param {proto.ISimulationConfiguration=} [properties] Properties to set
         */
        function SimulationConfiguration(properties) {
            this.robotLocations = [];
            this.robotProperties = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SimulationConfiguration ballLocation.
         * @member {proto.ISimulationBallLocation|null|undefined} ballLocation
         * @memberof proto.SimulationConfiguration
         * @instance
         */
        SimulationConfiguration.prototype.ballLocation = null;

        /**
         * SimulationConfiguration robotLocations.
         * @member {Array.<proto.ISimulationRobotLocation>} robotLocations
         * @memberof proto.SimulationConfiguration
         * @instance
         */
        SimulationConfiguration.prototype.robotLocations = $util.emptyArray;

        /**
         * SimulationConfiguration robotProperties.
         * @member {Array.<proto.ISimulationRobotProperties>} robotProperties
         * @memberof proto.SimulationConfiguration
         * @instance
         */
        SimulationConfiguration.prototype.robotProperties = $util.emptyArray;

        /**
         * SimulationConfiguration simulationSpeed.
         * @member {number} simulationSpeed
         * @memberof proto.SimulationConfiguration
         * @instance
         */
        SimulationConfiguration.prototype.simulationSpeed = 0;

        /**
         * SimulationConfiguration visionPort.
         * @member {number} visionPort
         * @memberof proto.SimulationConfiguration
         * @instance
         */
        SimulationConfiguration.prototype.visionPort = 0;

        /**
         * Creates a new SimulationConfiguration instance using the specified properties.
         * @function create
         * @memberof proto.SimulationConfiguration
         * @static
         * @param {proto.ISimulationConfiguration=} [properties] Properties to set
         * @returns {proto.SimulationConfiguration} SimulationConfiguration instance
         */
        SimulationConfiguration.create = function create(properties) {
            return new SimulationConfiguration(properties);
        };

        /**
         * Encodes the specified SimulationConfiguration message. Does not implicitly {@link proto.SimulationConfiguration.verify|verify} messages.
         * @function encode
         * @memberof proto.SimulationConfiguration
         * @static
         * @param {proto.ISimulationConfiguration} message SimulationConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimulationConfiguration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ballLocation != null && Object.hasOwnProperty.call(message, "ballLocation"))
                $root.proto.SimulationBallLocation.encode(message.ballLocation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.robotLocations != null && message.robotLocations.length)
                for (let i = 0; i < message.robotLocations.length; ++i)
                    $root.proto.SimulationRobotLocation.encode(message.robotLocations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.robotProperties != null && message.robotProperties.length)
                for (let i = 0; i < message.robotProperties.length; ++i)
                    $root.proto.SimulationRobotProperties.encode(message.robotProperties[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.simulationSpeed != null && Object.hasOwnProperty.call(message, "simulationSpeed"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.simulationSpeed);
            if (message.visionPort != null && Object.hasOwnProperty.call(message, "visionPort"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.visionPort);
            return writer;
        };

        /**
         * Encodes the specified SimulationConfiguration message, length delimited. Does not implicitly {@link proto.SimulationConfiguration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof proto.SimulationConfiguration
         * @static
         * @param {proto.ISimulationConfiguration} message SimulationConfiguration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimulationConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimulationConfiguration message from the specified reader or buffer.
         * @function decode
         * @memberof proto.SimulationConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {proto.SimulationConfiguration} SimulationConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimulationConfiguration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.proto.SimulationConfiguration();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.ballLocation = $root.proto.SimulationBallLocation.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        if (!(message.robotLocations && message.robotLocations.length))
                            message.robotLocations = [];
                        message.robotLocations.push($root.proto.SimulationRobotLocation.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.robotProperties && message.robotProperties.length))
                            message.robotProperties = [];
                        message.robotProperties.push($root.proto.SimulationRobotProperties.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.simulationSpeed = reader.float();
                        break;
                    }
                case 5: {
                        message.visionPort = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimulationConfiguration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof proto.SimulationConfiguration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {proto.SimulationConfiguration} SimulationConfiguration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimulationConfiguration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimulationConfiguration message.
         * @function verify
         * @memberof proto.SimulationConfiguration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimulationConfiguration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ballLocation != null && message.hasOwnProperty("ballLocation")) {
                let error = $root.proto.SimulationBallLocation.verify(message.ballLocation);
                if (error)
                    return "ballLocation." + error;
            }
            if (message.robotLocations != null && message.hasOwnProperty("robotLocations")) {
                if (!Array.isArray(message.robotLocations))
                    return "robotLocations: array expected";
                for (let i = 0; i < message.robotLocations.length; ++i) {
                    let error = $root.proto.SimulationRobotLocation.verify(message.robotLocations[i]);
                    if (error)
                        return "robotLocations." + error;
                }
            }
            if (message.robotProperties != null && message.hasOwnProperty("robotProperties")) {
                if (!Array.isArray(message.robotProperties))
                    return "robotProperties: array expected";
                for (let i = 0; i < message.robotProperties.length; ++i) {
                    let error = $root.proto.SimulationRobotProperties.verify(message.robotProperties[i]);
                    if (error)
                        return "robotProperties." + error;
                }
            }
            if (message.simulationSpeed != null && message.hasOwnProperty("simulationSpeed"))
                if (typeof message.simulationSpeed !== "number")
                    return "simulationSpeed: number expected";
            if (message.visionPort != null && message.hasOwnProperty("visionPort"))
                if (!$util.isInteger(message.visionPort))
                    return "visionPort: integer expected";
            return null;
        };

        /**
         * Creates a SimulationConfiguration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof proto.SimulationConfiguration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {proto.SimulationConfiguration} SimulationConfiguration
         */
        SimulationConfiguration.fromObject = function fromObject(object) {
            if (object instanceof $root.proto.SimulationConfiguration)
                return object;
            let message = new $root.proto.SimulationConfiguration();
            if (object.ballLocation != null) {
                if (typeof object.ballLocation !== "object")
                    throw TypeError(".proto.SimulationConfiguration.ballLocation: object expected");
                message.ballLocation = $root.proto.SimulationBallLocation.fromObject(object.ballLocation);
            }
            if (object.robotLocations) {
                if (!Array.isArray(object.robotLocations))
                    throw TypeError(".proto.SimulationConfiguration.robotLocations: array expected");
                message.robotLocations = [];
                for (let i = 0; i < object.robotLocations.length; ++i) {
                    if (typeof object.robotLocations[i] !== "object")
                        throw TypeError(".proto.SimulationConfiguration.robotLocations: object expected");
                    message.robotLocations[i] = $root.proto.SimulationRobotLocation.fromObject(object.robotLocations[i]);
                }
            }
            if (object.robotProperties) {
                if (!Array.isArray(object.robotProperties))
                    throw TypeError(".proto.SimulationConfiguration.robotProperties: array expected");
                message.robotProperties = [];
                for (let i = 0; i < object.robotProperties.length; ++i) {
                    if (typeof object.robotProperties[i] !== "object")
                        throw TypeError(".proto.SimulationConfiguration.robotProperties: object expected");
                    message.robotProperties[i] = $root.proto.SimulationRobotProperties.fromObject(object.robotProperties[i]);
                }
            }
            if (object.simulationSpeed != null)
                message.simulationSpeed = Number(object.simulationSpeed);
            if (object.visionPort != null)
                message.visionPort = object.visionPort >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a SimulationConfiguration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof proto.SimulationConfiguration
         * @static
         * @param {proto.SimulationConfiguration} message SimulationConfiguration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SimulationConfiguration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.robotLocations = [];
                object.robotProperties = [];
            }
            if (options.defaults) {
                object.ballLocation = null;
                object.simulationSpeed = 0;
                object.visionPort = 0;
            }
            if (message.ballLocation != null && message.hasOwnProperty("ballLocation"))
                object.ballLocation = $root.proto.SimulationBallLocation.toObject(message.ballLocation, options);
            if (message.robotLocations && message.robotLocations.length) {
                object.robotLocations = [];
                for (let j = 0; j < message.robotLocations.length; ++j)
                    object.robotLocations[j] = $root.proto.SimulationRobotLocation.toObject(message.robotLocations[j], options);
            }
            if (message.robotProperties && message.robotProperties.length) {
                object.robotProperties = [];
                for (let j = 0; j < message.robotProperties.length; ++j)
                    object.robotProperties[j] = $root.proto.SimulationRobotProperties.toObject(message.robotProperties[j], options);
            }
            if (message.simulationSpeed != null && message.hasOwnProperty("simulationSpeed"))
                object.simulationSpeed = options.json && !isFinite(message.simulationSpeed) ? String(message.simulationSpeed) : message.simulationSpeed;
            if (message.visionPort != null && message.hasOwnProperty("visionPort"))
                object.visionPort = message.visionPort;
            return object;
        };

        /**
         * Converts this SimulationConfiguration to JSON.
         * @function toJSON
         * @memberof proto.SimulationConfiguration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SimulationConfiguration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SimulationConfiguration
         * @function getTypeUrl
         * @memberof proto.SimulationConfiguration
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SimulationConfiguration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/proto.SimulationConfiguration";
        };

        return SimulationConfiguration;
    })();

    return proto;
})();

export const TeleportBall = $root.TeleportBall = (() => {

    /**
     * Properties of a TeleportBall.
     * @exports ITeleportBall
     * @interface ITeleportBall
     * @property {number|null} [x] TeleportBall x
     * @property {number|null} [y] TeleportBall y
     * @property {number|null} [z] TeleportBall z
     * @property {number|null} [vx] TeleportBall vx
     * @property {number|null} [vy] TeleportBall vy
     * @property {number|null} [vz] TeleportBall vz
     * @property {boolean|null} [teleportSafely] TeleportBall teleportSafely
     * @property {boolean|null} [roll] TeleportBall roll
     * @property {boolean|null} [byForce] TeleportBall byForce
     */

    /**
     * Constructs a new TeleportBall.
     * @exports TeleportBall
     * @classdesc Represents a TeleportBall.
     * @implements ITeleportBall
     * @constructor
     * @param {ITeleportBall=} [properties] Properties to set
     */
    function TeleportBall(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TeleportBall x.
     * @member {number} x
     * @memberof TeleportBall
     * @instance
     */
    TeleportBall.prototype.x = 0;

    /**
     * TeleportBall y.
     * @member {number} y
     * @memberof TeleportBall
     * @instance
     */
    TeleportBall.prototype.y = 0;

    /**
     * TeleportBall z.
     * @member {number} z
     * @memberof TeleportBall
     * @instance
     */
    TeleportBall.prototype.z = 0;

    /**
     * TeleportBall vx.
     * @member {number} vx
     * @memberof TeleportBall
     * @instance
     */
    TeleportBall.prototype.vx = 0;

    /**
     * TeleportBall vy.
     * @member {number} vy
     * @memberof TeleportBall
     * @instance
     */
    TeleportBall.prototype.vy = 0;

    /**
     * TeleportBall vz.
     * @member {number} vz
     * @memberof TeleportBall
     * @instance
     */
    TeleportBall.prototype.vz = 0;

    /**
     * TeleportBall teleportSafely.
     * @member {boolean} teleportSafely
     * @memberof TeleportBall
     * @instance
     */
    TeleportBall.prototype.teleportSafely = false;

    /**
     * TeleportBall roll.
     * @member {boolean} roll
     * @memberof TeleportBall
     * @instance
     */
    TeleportBall.prototype.roll = false;

    /**
     * TeleportBall byForce.
     * @member {boolean} byForce
     * @memberof TeleportBall
     * @instance
     */
    TeleportBall.prototype.byForce = false;

    /**
     * Creates a new TeleportBall instance using the specified properties.
     * @function create
     * @memberof TeleportBall
     * @static
     * @param {ITeleportBall=} [properties] Properties to set
     * @returns {TeleportBall} TeleportBall instance
     */
    TeleportBall.create = function create(properties) {
        return new TeleportBall(properties);
    };

    /**
     * Encodes the specified TeleportBall message. Does not implicitly {@link TeleportBall.verify|verify} messages.
     * @function encode
     * @memberof TeleportBall
     * @static
     * @param {ITeleportBall} message TeleportBall message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeleportBall.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.z);
        if (message.vx != null && Object.hasOwnProperty.call(message, "vx"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.vx);
        if (message.vy != null && Object.hasOwnProperty.call(message, "vy"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.vy);
        if (message.vz != null && Object.hasOwnProperty.call(message, "vz"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.vz);
        if (message.teleportSafely != null && Object.hasOwnProperty.call(message, "teleportSafely"))
            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.teleportSafely);
        if (message.roll != null && Object.hasOwnProperty.call(message, "roll"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.roll);
        if (message.byForce != null && Object.hasOwnProperty.call(message, "byForce"))
            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.byForce);
        return writer;
    };

    /**
     * Encodes the specified TeleportBall message, length delimited. Does not implicitly {@link TeleportBall.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TeleportBall
     * @static
     * @param {ITeleportBall} message TeleportBall message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeleportBall.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TeleportBall message from the specified reader or buffer.
     * @function decode
     * @memberof TeleportBall
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TeleportBall} TeleportBall
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeleportBall.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TeleportBall();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.x = reader.float();
                    break;
                }
            case 2: {
                    message.y = reader.float();
                    break;
                }
            case 3: {
                    message.z = reader.float();
                    break;
                }
            case 4: {
                    message.vx = reader.float();
                    break;
                }
            case 5: {
                    message.vy = reader.float();
                    break;
                }
            case 6: {
                    message.vz = reader.float();
                    break;
                }
            case 7: {
                    message.teleportSafely = reader.bool();
                    break;
                }
            case 8: {
                    message.roll = reader.bool();
                    break;
                }
            case 9: {
                    message.byForce = reader.bool();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a TeleportBall message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TeleportBall
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TeleportBall} TeleportBall
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeleportBall.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TeleportBall message.
     * @function verify
     * @memberof TeleportBall
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TeleportBall.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.x != null && message.hasOwnProperty("x"))
            if (typeof message.x !== "number")
                return "x: number expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (typeof message.y !== "number")
                return "y: number expected";
        if (message.z != null && message.hasOwnProperty("z"))
            if (typeof message.z !== "number")
                return "z: number expected";
        if (message.vx != null && message.hasOwnProperty("vx"))
            if (typeof message.vx !== "number")
                return "vx: number expected";
        if (message.vy != null && message.hasOwnProperty("vy"))
            if (typeof message.vy !== "number")
                return "vy: number expected";
        if (message.vz != null && message.hasOwnProperty("vz"))
            if (typeof message.vz !== "number")
                return "vz: number expected";
        if (message.teleportSafely != null && message.hasOwnProperty("teleportSafely"))
            if (typeof message.teleportSafely !== "boolean")
                return "teleportSafely: boolean expected";
        if (message.roll != null && message.hasOwnProperty("roll"))
            if (typeof message.roll !== "boolean")
                return "roll: boolean expected";
        if (message.byForce != null && message.hasOwnProperty("byForce"))
            if (typeof message.byForce !== "boolean")
                return "byForce: boolean expected";
        return null;
    };

    /**
     * Creates a TeleportBall message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TeleportBall
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TeleportBall} TeleportBall
     */
    TeleportBall.fromObject = function fromObject(object) {
        if (object instanceof $root.TeleportBall)
            return object;
        let message = new $root.TeleportBall();
        if (object.x != null)
            message.x = Number(object.x);
        if (object.y != null)
            message.y = Number(object.y);
        if (object.z != null)
            message.z = Number(object.z);
        if (object.vx != null)
            message.vx = Number(object.vx);
        if (object.vy != null)
            message.vy = Number(object.vy);
        if (object.vz != null)
            message.vz = Number(object.vz);
        if (object.teleportSafely != null)
            message.teleportSafely = Boolean(object.teleportSafely);
        if (object.roll != null)
            message.roll = Boolean(object.roll);
        if (object.byForce != null)
            message.byForce = Boolean(object.byForce);
        return message;
    };

    /**
     * Creates a plain object from a TeleportBall message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TeleportBall
     * @static
     * @param {TeleportBall} message TeleportBall
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TeleportBall.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
            object.z = 0;
            object.vx = 0;
            object.vy = 0;
            object.vz = 0;
            object.teleportSafely = false;
            object.roll = false;
            object.byForce = false;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
        if (message.vx != null && message.hasOwnProperty("vx"))
            object.vx = options.json && !isFinite(message.vx) ? String(message.vx) : message.vx;
        if (message.vy != null && message.hasOwnProperty("vy"))
            object.vy = options.json && !isFinite(message.vy) ? String(message.vy) : message.vy;
        if (message.vz != null && message.hasOwnProperty("vz"))
            object.vz = options.json && !isFinite(message.vz) ? String(message.vz) : message.vz;
        if (message.teleportSafely != null && message.hasOwnProperty("teleportSafely"))
            object.teleportSafely = message.teleportSafely;
        if (message.roll != null && message.hasOwnProperty("roll"))
            object.roll = message.roll;
        if (message.byForce != null && message.hasOwnProperty("byForce"))
            object.byForce = message.byForce;
        return object;
    };

    /**
     * Converts this TeleportBall to JSON.
     * @function toJSON
     * @memberof TeleportBall
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TeleportBall.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TeleportBall
     * @function getTypeUrl
     * @memberof TeleportBall
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TeleportBall.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/TeleportBall";
    };

    return TeleportBall;
})();

export const TeleportRobot = $root.TeleportRobot = (() => {

    /**
     * Properties of a TeleportRobot.
     * @exports ITeleportRobot
     * @interface ITeleportRobot
     * @property {IRobotId} id TeleportRobot id
     * @property {number|null} [x] TeleportRobot x
     * @property {number|null} [y] TeleportRobot y
     * @property {number|null} [orientation] TeleportRobot orientation
     * @property {number|null} [vX] TeleportRobot vX
     * @property {number|null} [vY] TeleportRobot vY
     * @property {number|null} [vAngular] TeleportRobot vAngular
     * @property {boolean|null} [present] TeleportRobot present
     * @property {boolean|null} [byForce] TeleportRobot byForce
     */

    /**
     * Constructs a new TeleportRobot.
     * @exports TeleportRobot
     * @classdesc Represents a TeleportRobot.
     * @implements ITeleportRobot
     * @constructor
     * @param {ITeleportRobot=} [properties] Properties to set
     */
    function TeleportRobot(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * TeleportRobot id.
     * @member {IRobotId} id
     * @memberof TeleportRobot
     * @instance
     */
    TeleportRobot.prototype.id = null;

    /**
     * TeleportRobot x.
     * @member {number} x
     * @memberof TeleportRobot
     * @instance
     */
    TeleportRobot.prototype.x = 0;

    /**
     * TeleportRobot y.
     * @member {number} y
     * @memberof TeleportRobot
     * @instance
     */
    TeleportRobot.prototype.y = 0;

    /**
     * TeleportRobot orientation.
     * @member {number} orientation
     * @memberof TeleportRobot
     * @instance
     */
    TeleportRobot.prototype.orientation = 0;

    /**
     * TeleportRobot vX.
     * @member {number} vX
     * @memberof TeleportRobot
     * @instance
     */
    TeleportRobot.prototype.vX = 0;

    /**
     * TeleportRobot vY.
     * @member {number} vY
     * @memberof TeleportRobot
     * @instance
     */
    TeleportRobot.prototype.vY = 0;

    /**
     * TeleportRobot vAngular.
     * @member {number} vAngular
     * @memberof TeleportRobot
     * @instance
     */
    TeleportRobot.prototype.vAngular = 0;

    /**
     * TeleportRobot present.
     * @member {boolean} present
     * @memberof TeleportRobot
     * @instance
     */
    TeleportRobot.prototype.present = false;

    /**
     * TeleportRobot byForce.
     * @member {boolean} byForce
     * @memberof TeleportRobot
     * @instance
     */
    TeleportRobot.prototype.byForce = false;

    /**
     * Creates a new TeleportRobot instance using the specified properties.
     * @function create
     * @memberof TeleportRobot
     * @static
     * @param {ITeleportRobot=} [properties] Properties to set
     * @returns {TeleportRobot} TeleportRobot instance
     */
    TeleportRobot.create = function create(properties) {
        return new TeleportRobot(properties);
    };

    /**
     * Encodes the specified TeleportRobot message. Does not implicitly {@link TeleportRobot.verify|verify} messages.
     * @function encode
     * @memberof TeleportRobot
     * @static
     * @param {ITeleportRobot} message TeleportRobot message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeleportRobot.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        $root.RobotId.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.x != null && Object.hasOwnProperty.call(message, "x"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.x);
        if (message.y != null && Object.hasOwnProperty.call(message, "y"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.y);
        if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.orientation);
        if (message.vX != null && Object.hasOwnProperty.call(message, "vX"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.vX);
        if (message.vY != null && Object.hasOwnProperty.call(message, "vY"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.vY);
        if (message.vAngular != null && Object.hasOwnProperty.call(message, "vAngular"))
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.vAngular);
        if (message.present != null && Object.hasOwnProperty.call(message, "present"))
            writer.uint32(/* id 8, wireType 0 =*/64).bool(message.present);
        if (message.byForce != null && Object.hasOwnProperty.call(message, "byForce"))
            writer.uint32(/* id 9, wireType 0 =*/72).bool(message.byForce);
        return writer;
    };

    /**
     * Encodes the specified TeleportRobot message, length delimited. Does not implicitly {@link TeleportRobot.verify|verify} messages.
     * @function encodeDelimited
     * @memberof TeleportRobot
     * @static
     * @param {ITeleportRobot} message TeleportRobot message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    TeleportRobot.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a TeleportRobot message from the specified reader or buffer.
     * @function decode
     * @memberof TeleportRobot
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TeleportRobot} TeleportRobot
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeleportRobot.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TeleportRobot();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.id = $root.RobotId.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.x = reader.float();
                    break;
                }
            case 3: {
                    message.y = reader.float();
                    break;
                }
            case 4: {
                    message.orientation = reader.float();
                    break;
                }
            case 5: {
                    message.vX = reader.float();
                    break;
                }
            case 6: {
                    message.vY = reader.float();
                    break;
                }
            case 7: {
                    message.vAngular = reader.float();
                    break;
                }
            case 8: {
                    message.present = reader.bool();
                    break;
                }
            case 9: {
                    message.byForce = reader.bool();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("id"))
            throw $util.ProtocolError("missing required 'id'", { instance: message });
        return message;
    };

    /**
     * Decodes a TeleportRobot message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof TeleportRobot
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {TeleportRobot} TeleportRobot
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TeleportRobot.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a TeleportRobot message.
     * @function verify
     * @memberof TeleportRobot
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    TeleportRobot.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        {
            let error = $root.RobotId.verify(message.id);
            if (error)
                return "id." + error;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            if (typeof message.x !== "number")
                return "x: number expected";
        if (message.y != null && message.hasOwnProperty("y"))
            if (typeof message.y !== "number")
                return "y: number expected";
        if (message.orientation != null && message.hasOwnProperty("orientation"))
            if (typeof message.orientation !== "number")
                return "orientation: number expected";
        if (message.vX != null && message.hasOwnProperty("vX"))
            if (typeof message.vX !== "number")
                return "vX: number expected";
        if (message.vY != null && message.hasOwnProperty("vY"))
            if (typeof message.vY !== "number")
                return "vY: number expected";
        if (message.vAngular != null && message.hasOwnProperty("vAngular"))
            if (typeof message.vAngular !== "number")
                return "vAngular: number expected";
        if (message.present != null && message.hasOwnProperty("present"))
            if (typeof message.present !== "boolean")
                return "present: boolean expected";
        if (message.byForce != null && message.hasOwnProperty("byForce"))
            if (typeof message.byForce !== "boolean")
                return "byForce: boolean expected";
        return null;
    };

    /**
     * Creates a TeleportRobot message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof TeleportRobot
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {TeleportRobot} TeleportRobot
     */
    TeleportRobot.fromObject = function fromObject(object) {
        if (object instanceof $root.TeleportRobot)
            return object;
        let message = new $root.TeleportRobot();
        if (object.id != null) {
            if (typeof object.id !== "object")
                throw TypeError(".TeleportRobot.id: object expected");
            message.id = $root.RobotId.fromObject(object.id);
        }
        if (object.x != null)
            message.x = Number(object.x);
        if (object.y != null)
            message.y = Number(object.y);
        if (object.orientation != null)
            message.orientation = Number(object.orientation);
        if (object.vX != null)
            message.vX = Number(object.vX);
        if (object.vY != null)
            message.vY = Number(object.vY);
        if (object.vAngular != null)
            message.vAngular = Number(object.vAngular);
        if (object.present != null)
            message.present = Boolean(object.present);
        if (object.byForce != null)
            message.byForce = Boolean(object.byForce);
        return message;
    };

    /**
     * Creates a plain object from a TeleportRobot message. Also converts values to other types if specified.
     * @function toObject
     * @memberof TeleportRobot
     * @static
     * @param {TeleportRobot} message TeleportRobot
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    TeleportRobot.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.id = null;
            object.x = 0;
            object.y = 0;
            object.orientation = 0;
            object.vX = 0;
            object.vY = 0;
            object.vAngular = 0;
            object.present = false;
            object.byForce = false;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = $root.RobotId.toObject(message.id, options);
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
        if (message.orientation != null && message.hasOwnProperty("orientation"))
            object.orientation = options.json && !isFinite(message.orientation) ? String(message.orientation) : message.orientation;
        if (message.vX != null && message.hasOwnProperty("vX"))
            object.vX = options.json && !isFinite(message.vX) ? String(message.vX) : message.vX;
        if (message.vY != null && message.hasOwnProperty("vY"))
            object.vY = options.json && !isFinite(message.vY) ? String(message.vY) : message.vY;
        if (message.vAngular != null && message.hasOwnProperty("vAngular"))
            object.vAngular = options.json && !isFinite(message.vAngular) ? String(message.vAngular) : message.vAngular;
        if (message.present != null && message.hasOwnProperty("present"))
            object.present = message.present;
        if (message.byForce != null && message.hasOwnProperty("byForce"))
            object.byForce = message.byForce;
        return object;
    };

    /**
     * Converts this TeleportRobot to JSON.
     * @function toJSON
     * @memberof TeleportRobot
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    TeleportRobot.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for TeleportRobot
     * @function getTypeUrl
     * @memberof TeleportRobot
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    TeleportRobot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/TeleportRobot";
    };

    return TeleportRobot;
})();

export const SimulatorControl = $root.SimulatorControl = (() => {

    /**
     * Properties of a SimulatorControl.
     * @exports ISimulatorControl
     * @interface ISimulatorControl
     * @property {ITeleportBall|null} [teleportBall] SimulatorControl teleportBall
     * @property {Array.<ITeleportRobot>|null} [teleportRobot] SimulatorControl teleportRobot
     * @property {number|null} [simulationSpeed] SimulatorControl simulationSpeed
     */

    /**
     * Constructs a new SimulatorControl.
     * @exports SimulatorControl
     * @classdesc Represents a SimulatorControl.
     * @implements ISimulatorControl
     * @constructor
     * @param {ISimulatorControl=} [properties] Properties to set
     */
    function SimulatorControl(properties) {
        this.teleportRobot = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SimulatorControl teleportBall.
     * @member {ITeleportBall|null|undefined} teleportBall
     * @memberof SimulatorControl
     * @instance
     */
    SimulatorControl.prototype.teleportBall = null;

    /**
     * SimulatorControl teleportRobot.
     * @member {Array.<ITeleportRobot>} teleportRobot
     * @memberof SimulatorControl
     * @instance
     */
    SimulatorControl.prototype.teleportRobot = $util.emptyArray;

    /**
     * SimulatorControl simulationSpeed.
     * @member {number} simulationSpeed
     * @memberof SimulatorControl
     * @instance
     */
    SimulatorControl.prototype.simulationSpeed = 0;

    /**
     * Creates a new SimulatorControl instance using the specified properties.
     * @function create
     * @memberof SimulatorControl
     * @static
     * @param {ISimulatorControl=} [properties] Properties to set
     * @returns {SimulatorControl} SimulatorControl instance
     */
    SimulatorControl.create = function create(properties) {
        return new SimulatorControl(properties);
    };

    /**
     * Encodes the specified SimulatorControl message. Does not implicitly {@link SimulatorControl.verify|verify} messages.
     * @function encode
     * @memberof SimulatorControl
     * @static
     * @param {ISimulatorControl} message SimulatorControl message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulatorControl.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.teleportBall != null && Object.hasOwnProperty.call(message, "teleportBall"))
            $root.TeleportBall.encode(message.teleportBall, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.teleportRobot != null && message.teleportRobot.length)
            for (let i = 0; i < message.teleportRobot.length; ++i)
                $root.TeleportRobot.encode(message.teleportRobot[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.simulationSpeed != null && Object.hasOwnProperty.call(message, "simulationSpeed"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.simulationSpeed);
        return writer;
    };

    /**
     * Encodes the specified SimulatorControl message, length delimited. Does not implicitly {@link SimulatorControl.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SimulatorControl
     * @static
     * @param {ISimulatorControl} message SimulatorControl message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulatorControl.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SimulatorControl message from the specified reader or buffer.
     * @function decode
     * @memberof SimulatorControl
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SimulatorControl} SimulatorControl
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulatorControl.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SimulatorControl();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.teleportBall = $root.TeleportBall.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    if (!(message.teleportRobot && message.teleportRobot.length))
                        message.teleportRobot = [];
                    message.teleportRobot.push($root.TeleportRobot.decode(reader, reader.uint32()));
                    break;
                }
            case 3: {
                    message.simulationSpeed = reader.float();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SimulatorControl message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SimulatorControl
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SimulatorControl} SimulatorControl
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulatorControl.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SimulatorControl message.
     * @function verify
     * @memberof SimulatorControl
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SimulatorControl.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.teleportBall != null && message.hasOwnProperty("teleportBall")) {
            let error = $root.TeleportBall.verify(message.teleportBall);
            if (error)
                return "teleportBall." + error;
        }
        if (message.teleportRobot != null && message.hasOwnProperty("teleportRobot")) {
            if (!Array.isArray(message.teleportRobot))
                return "teleportRobot: array expected";
            for (let i = 0; i < message.teleportRobot.length; ++i) {
                let error = $root.TeleportRobot.verify(message.teleportRobot[i]);
                if (error)
                    return "teleportRobot." + error;
            }
        }
        if (message.simulationSpeed != null && message.hasOwnProperty("simulationSpeed"))
            if (typeof message.simulationSpeed !== "number")
                return "simulationSpeed: number expected";
        return null;
    };

    /**
     * Creates a SimulatorControl message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SimulatorControl
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SimulatorControl} SimulatorControl
     */
    SimulatorControl.fromObject = function fromObject(object) {
        if (object instanceof $root.SimulatorControl)
            return object;
        let message = new $root.SimulatorControl();
        if (object.teleportBall != null) {
            if (typeof object.teleportBall !== "object")
                throw TypeError(".SimulatorControl.teleportBall: object expected");
            message.teleportBall = $root.TeleportBall.fromObject(object.teleportBall);
        }
        if (object.teleportRobot) {
            if (!Array.isArray(object.teleportRobot))
                throw TypeError(".SimulatorControl.teleportRobot: array expected");
            message.teleportRobot = [];
            for (let i = 0; i < object.teleportRobot.length; ++i) {
                if (typeof object.teleportRobot[i] !== "object")
                    throw TypeError(".SimulatorControl.teleportRobot: object expected");
                message.teleportRobot[i] = $root.TeleportRobot.fromObject(object.teleportRobot[i]);
            }
        }
        if (object.simulationSpeed != null)
            message.simulationSpeed = Number(object.simulationSpeed);
        return message;
    };

    /**
     * Creates a plain object from a SimulatorControl message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SimulatorControl
     * @static
     * @param {SimulatorControl} message SimulatorControl
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SimulatorControl.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.teleportRobot = [];
        if (options.defaults) {
            object.teleportBall = null;
            object.simulationSpeed = 0;
        }
        if (message.teleportBall != null && message.hasOwnProperty("teleportBall"))
            object.teleportBall = $root.TeleportBall.toObject(message.teleportBall, options);
        if (message.teleportRobot && message.teleportRobot.length) {
            object.teleportRobot = [];
            for (let j = 0; j < message.teleportRobot.length; ++j)
                object.teleportRobot[j] = $root.TeleportRobot.toObject(message.teleportRobot[j], options);
        }
        if (message.simulationSpeed != null && message.hasOwnProperty("simulationSpeed"))
            object.simulationSpeed = options.json && !isFinite(message.simulationSpeed) ? String(message.simulationSpeed) : message.simulationSpeed;
        return object;
    };

    /**
     * Converts this SimulatorControl to JSON.
     * @function toJSON
     * @memberof SimulatorControl
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SimulatorControl.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SimulatorControl
     * @function getTypeUrl
     * @memberof SimulatorControl
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SimulatorControl.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SimulatorControl";
    };

    return SimulatorControl;
})();

export const SimulatorCommand = $root.SimulatorCommand = (() => {

    /**
     * Properties of a SimulatorCommand.
     * @exports ISimulatorCommand
     * @interface ISimulatorCommand
     * @property {ISimulatorControl|null} [control] SimulatorCommand control
     * @property {ISimulatorConfig|null} [config] SimulatorCommand config
     */

    /**
     * Constructs a new SimulatorCommand.
     * @exports SimulatorCommand
     * @classdesc Represents a SimulatorCommand.
     * @implements ISimulatorCommand
     * @constructor
     * @param {ISimulatorCommand=} [properties] Properties to set
     */
    function SimulatorCommand(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SimulatorCommand control.
     * @member {ISimulatorControl|null|undefined} control
     * @memberof SimulatorCommand
     * @instance
     */
    SimulatorCommand.prototype.control = null;

    /**
     * SimulatorCommand config.
     * @member {ISimulatorConfig|null|undefined} config
     * @memberof SimulatorCommand
     * @instance
     */
    SimulatorCommand.prototype.config = null;

    /**
     * Creates a new SimulatorCommand instance using the specified properties.
     * @function create
     * @memberof SimulatorCommand
     * @static
     * @param {ISimulatorCommand=} [properties] Properties to set
     * @returns {SimulatorCommand} SimulatorCommand instance
     */
    SimulatorCommand.create = function create(properties) {
        return new SimulatorCommand(properties);
    };

    /**
     * Encodes the specified SimulatorCommand message. Does not implicitly {@link SimulatorCommand.verify|verify} messages.
     * @function encode
     * @memberof SimulatorCommand
     * @static
     * @param {ISimulatorCommand} message SimulatorCommand message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulatorCommand.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.control != null && Object.hasOwnProperty.call(message, "control"))
            $root.SimulatorControl.encode(message.control, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.config != null && Object.hasOwnProperty.call(message, "config"))
            $root.SimulatorConfig.encode(message.config, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SimulatorCommand message, length delimited. Does not implicitly {@link SimulatorCommand.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SimulatorCommand
     * @static
     * @param {ISimulatorCommand} message SimulatorCommand message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulatorCommand.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SimulatorCommand message from the specified reader or buffer.
     * @function decode
     * @memberof SimulatorCommand
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SimulatorCommand} SimulatorCommand
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulatorCommand.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SimulatorCommand();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.control = $root.SimulatorControl.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.config = $root.SimulatorConfig.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SimulatorCommand message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SimulatorCommand
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SimulatorCommand} SimulatorCommand
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulatorCommand.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SimulatorCommand message.
     * @function verify
     * @memberof SimulatorCommand
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SimulatorCommand.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.control != null && message.hasOwnProperty("control")) {
            let error = $root.SimulatorControl.verify(message.control);
            if (error)
                return "control." + error;
        }
        if (message.config != null && message.hasOwnProperty("config")) {
            let error = $root.SimulatorConfig.verify(message.config);
            if (error)
                return "config." + error;
        }
        return null;
    };

    /**
     * Creates a SimulatorCommand message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SimulatorCommand
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SimulatorCommand} SimulatorCommand
     */
    SimulatorCommand.fromObject = function fromObject(object) {
        if (object instanceof $root.SimulatorCommand)
            return object;
        let message = new $root.SimulatorCommand();
        if (object.control != null) {
            if (typeof object.control !== "object")
                throw TypeError(".SimulatorCommand.control: object expected");
            message.control = $root.SimulatorControl.fromObject(object.control);
        }
        if (object.config != null) {
            if (typeof object.config !== "object")
                throw TypeError(".SimulatorCommand.config: object expected");
            message.config = $root.SimulatorConfig.fromObject(object.config);
        }
        return message;
    };

    /**
     * Creates a plain object from a SimulatorCommand message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SimulatorCommand
     * @static
     * @param {SimulatorCommand} message SimulatorCommand
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SimulatorCommand.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.control = null;
            object.config = null;
        }
        if (message.control != null && message.hasOwnProperty("control"))
            object.control = $root.SimulatorControl.toObject(message.control, options);
        if (message.config != null && message.hasOwnProperty("config"))
            object.config = $root.SimulatorConfig.toObject(message.config, options);
        return object;
    };

    /**
     * Converts this SimulatorCommand to JSON.
     * @function toJSON
     * @memberof SimulatorCommand
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SimulatorCommand.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SimulatorCommand
     * @function getTypeUrl
     * @memberof SimulatorCommand
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SimulatorCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SimulatorCommand";
    };

    return SimulatorCommand;
})();

export const SimulatorResponse = $root.SimulatorResponse = (() => {

    /**
     * Properties of a SimulatorResponse.
     * @exports ISimulatorResponse
     * @interface ISimulatorResponse
     * @property {Array.<ISimulatorError>|null} [errors] SimulatorResponse errors
     */

    /**
     * Constructs a new SimulatorResponse.
     * @exports SimulatorResponse
     * @classdesc Represents a SimulatorResponse.
     * @implements ISimulatorResponse
     * @constructor
     * @param {ISimulatorResponse=} [properties] Properties to set
     */
    function SimulatorResponse(properties) {
        this.errors = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SimulatorResponse errors.
     * @member {Array.<ISimulatorError>} errors
     * @memberof SimulatorResponse
     * @instance
     */
    SimulatorResponse.prototype.errors = $util.emptyArray;

    /**
     * Creates a new SimulatorResponse instance using the specified properties.
     * @function create
     * @memberof SimulatorResponse
     * @static
     * @param {ISimulatorResponse=} [properties] Properties to set
     * @returns {SimulatorResponse} SimulatorResponse instance
     */
    SimulatorResponse.create = function create(properties) {
        return new SimulatorResponse(properties);
    };

    /**
     * Encodes the specified SimulatorResponse message. Does not implicitly {@link SimulatorResponse.verify|verify} messages.
     * @function encode
     * @memberof SimulatorResponse
     * @static
     * @param {ISimulatorResponse} message SimulatorResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulatorResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.errors != null && message.errors.length)
            for (let i = 0; i < message.errors.length; ++i)
                $root.SimulatorError.encode(message.errors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SimulatorResponse message, length delimited. Does not implicitly {@link SimulatorResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SimulatorResponse
     * @static
     * @param {ISimulatorResponse} message SimulatorResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulatorResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SimulatorResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SimulatorResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SimulatorResponse} SimulatorResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulatorResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SimulatorResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.errors && message.errors.length))
                        message.errors = [];
                    message.errors.push($root.SimulatorError.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SimulatorResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SimulatorResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SimulatorResponse} SimulatorResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulatorResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SimulatorResponse message.
     * @function verify
     * @memberof SimulatorResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SimulatorResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.errors != null && message.hasOwnProperty("errors")) {
            if (!Array.isArray(message.errors))
                return "errors: array expected";
            for (let i = 0; i < message.errors.length; ++i) {
                let error = $root.SimulatorError.verify(message.errors[i]);
                if (error)
                    return "errors." + error;
            }
        }
        return null;
    };

    /**
     * Creates a SimulatorResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SimulatorResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SimulatorResponse} SimulatorResponse
     */
    SimulatorResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SimulatorResponse)
            return object;
        let message = new $root.SimulatorResponse();
        if (object.errors) {
            if (!Array.isArray(object.errors))
                throw TypeError(".SimulatorResponse.errors: array expected");
            message.errors = [];
            for (let i = 0; i < object.errors.length; ++i) {
                if (typeof object.errors[i] !== "object")
                    throw TypeError(".SimulatorResponse.errors: object expected");
                message.errors[i] = $root.SimulatorError.fromObject(object.errors[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a SimulatorResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SimulatorResponse
     * @static
     * @param {SimulatorResponse} message SimulatorResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SimulatorResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.errors = [];
        if (message.errors && message.errors.length) {
            object.errors = [];
            for (let j = 0; j < message.errors.length; ++j)
                object.errors[j] = $root.SimulatorError.toObject(message.errors[j], options);
        }
        return object;
    };

    /**
     * Converts this SimulatorResponse to JSON.
     * @function toJSON
     * @memberof SimulatorResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SimulatorResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SimulatorResponse
     * @function getTypeUrl
     * @memberof SimulatorResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SimulatorResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SimulatorResponse";
    };

    return SimulatorResponse;
})();

/**
 * Team enum.
 * @exports Team
 * @enum {number}
 * @property {number} UNKNOWN=0 UNKNOWN value
 * @property {number} YELLOW=1 YELLOW value
 * @property {number} BLUE=2 BLUE value
 */
export const Team = $root.Team = (() => {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "UNKNOWN"] = 0;
    values[valuesById[1] = "YELLOW"] = 1;
    values[valuesById[2] = "BLUE"] = 2;
    return values;
})();

export const RobotId = $root.RobotId = (() => {

    /**
     * Properties of a RobotId.
     * @exports IRobotId
     * @interface IRobotId
     * @property {number|null} [id] RobotId id
     * @property {Team|null} [team] RobotId team
     */

    /**
     * Constructs a new RobotId.
     * @exports RobotId
     * @classdesc Represents a RobotId.
     * @implements IRobotId
     * @constructor
     * @param {IRobotId=} [properties] Properties to set
     */
    function RobotId(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RobotId id.
     * @member {number} id
     * @memberof RobotId
     * @instance
     */
    RobotId.prototype.id = 0;

    /**
     * RobotId team.
     * @member {Team} team
     * @memberof RobotId
     * @instance
     */
    RobotId.prototype.team = 0;

    /**
     * Creates a new RobotId instance using the specified properties.
     * @function create
     * @memberof RobotId
     * @static
     * @param {IRobotId=} [properties] Properties to set
     * @returns {RobotId} RobotId instance
     */
    RobotId.create = function create(properties) {
        return new RobotId(properties);
    };

    /**
     * Encodes the specified RobotId message. Does not implicitly {@link RobotId.verify|verify} messages.
     * @function encode
     * @memberof RobotId
     * @static
     * @param {IRobotId} message RobotId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotId.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
        if (message.team != null && Object.hasOwnProperty.call(message, "team"))
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.team);
        return writer;
    };

    /**
     * Encodes the specified RobotId message, length delimited. Does not implicitly {@link RobotId.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RobotId
     * @static
     * @param {IRobotId} message RobotId message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotId.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RobotId message from the specified reader or buffer.
     * @function decode
     * @memberof RobotId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RobotId} RobotId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotId.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RobotId();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.id = reader.uint32();
                    break;
                }
            case 2: {
                    message.team = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RobotId message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RobotId
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RobotId} RobotId
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotId.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RobotId message.
     * @function verify
     * @memberof RobotId
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RobotId.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.id != null && message.hasOwnProperty("id"))
            if (!$util.isInteger(message.id))
                return "id: integer expected";
        if (message.team != null && message.hasOwnProperty("team"))
            switch (message.team) {
            default:
                return "team: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
        return null;
    };

    /**
     * Creates a RobotId message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RobotId
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RobotId} RobotId
     */
    RobotId.fromObject = function fromObject(object) {
        if (object instanceof $root.RobotId)
            return object;
        let message = new $root.RobotId();
        if (object.id != null)
            message.id = object.id >>> 0;
        switch (object.team) {
        default:
            if (typeof object.team === "number") {
                message.team = object.team;
                break;
            }
            break;
        case "UNKNOWN":
        case 0:
            message.team = 0;
            break;
        case "YELLOW":
        case 1:
            message.team = 1;
            break;
        case "BLUE":
        case 2:
            message.team = 2;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a RobotId message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RobotId
     * @static
     * @param {RobotId} message RobotId
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RobotId.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.id = 0;
            object.team = options.enums === String ? "UNKNOWN" : 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.team != null && message.hasOwnProperty("team"))
            object.team = options.enums === String ? $root.Team[message.team] === undefined ? message.team : $root.Team[message.team] : message.team;
        return object;
    };

    /**
     * Converts this RobotId to JSON.
     * @function toJSON
     * @memberof RobotId
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RobotId.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RobotId
     * @function getTypeUrl
     * @memberof RobotId
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RobotId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RobotId";
    };

    return RobotId;
})();

/**
 * Division enum.
 * @exports Division
 * @enum {number}
 * @property {number} DIV_UNKNOWN=0 DIV_UNKNOWN value
 * @property {number} DIV_A=1 DIV_A value
 * @property {number} DIV_B=2 DIV_B value
 */
export const Division = $root.Division = (() => {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "DIV_UNKNOWN"] = 0;
    values[valuesById[1] = "DIV_A"] = 1;
    values[valuesById[2] = "DIV_B"] = 2;
    return values;
})();

export const RobotLimits = $root.RobotLimits = (() => {

    /**
     * Properties of a RobotLimits.
     * @exports IRobotLimits
     * @interface IRobotLimits
     * @property {number|null} [accSpeedupAbsoluteMax] RobotLimits accSpeedupAbsoluteMax
     * @property {number|null} [accSpeedupAngularMax] RobotLimits accSpeedupAngularMax
     * @property {number|null} [accBrakeAbsoluteMax] RobotLimits accBrakeAbsoluteMax
     * @property {number|null} [accBrakeAngularMax] RobotLimits accBrakeAngularMax
     * @property {number|null} [velAbsoluteMax] RobotLimits velAbsoluteMax
     * @property {number|null} [velAngularMax] RobotLimits velAngularMax
     */

    /**
     * Constructs a new RobotLimits.
     * @exports RobotLimits
     * @classdesc Represents a RobotLimits.
     * @implements IRobotLimits
     * @constructor
     * @param {IRobotLimits=} [properties] Properties to set
     */
    function RobotLimits(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RobotLimits accSpeedupAbsoluteMax.
     * @member {number} accSpeedupAbsoluteMax
     * @memberof RobotLimits
     * @instance
     */
    RobotLimits.prototype.accSpeedupAbsoluteMax = 0;

    /**
     * RobotLimits accSpeedupAngularMax.
     * @member {number} accSpeedupAngularMax
     * @memberof RobotLimits
     * @instance
     */
    RobotLimits.prototype.accSpeedupAngularMax = 0;

    /**
     * RobotLimits accBrakeAbsoluteMax.
     * @member {number} accBrakeAbsoluteMax
     * @memberof RobotLimits
     * @instance
     */
    RobotLimits.prototype.accBrakeAbsoluteMax = 0;

    /**
     * RobotLimits accBrakeAngularMax.
     * @member {number} accBrakeAngularMax
     * @memberof RobotLimits
     * @instance
     */
    RobotLimits.prototype.accBrakeAngularMax = 0;

    /**
     * RobotLimits velAbsoluteMax.
     * @member {number} velAbsoluteMax
     * @memberof RobotLimits
     * @instance
     */
    RobotLimits.prototype.velAbsoluteMax = 0;

    /**
     * RobotLimits velAngularMax.
     * @member {number} velAngularMax
     * @memberof RobotLimits
     * @instance
     */
    RobotLimits.prototype.velAngularMax = 0;

    /**
     * Creates a new RobotLimits instance using the specified properties.
     * @function create
     * @memberof RobotLimits
     * @static
     * @param {IRobotLimits=} [properties] Properties to set
     * @returns {RobotLimits} RobotLimits instance
     */
    RobotLimits.create = function create(properties) {
        return new RobotLimits(properties);
    };

    /**
     * Encodes the specified RobotLimits message. Does not implicitly {@link RobotLimits.verify|verify} messages.
     * @function encode
     * @memberof RobotLimits
     * @static
     * @param {IRobotLimits} message RobotLimits message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotLimits.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.accSpeedupAbsoluteMax != null && Object.hasOwnProperty.call(message, "accSpeedupAbsoluteMax"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.accSpeedupAbsoluteMax);
        if (message.accSpeedupAngularMax != null && Object.hasOwnProperty.call(message, "accSpeedupAngularMax"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.accSpeedupAngularMax);
        if (message.accBrakeAbsoluteMax != null && Object.hasOwnProperty.call(message, "accBrakeAbsoluteMax"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.accBrakeAbsoluteMax);
        if (message.accBrakeAngularMax != null && Object.hasOwnProperty.call(message, "accBrakeAngularMax"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.accBrakeAngularMax);
        if (message.velAbsoluteMax != null && Object.hasOwnProperty.call(message, "velAbsoluteMax"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.velAbsoluteMax);
        if (message.velAngularMax != null && Object.hasOwnProperty.call(message, "velAngularMax"))
            writer.uint32(/* id 6, wireType 5 =*/53).float(message.velAngularMax);
        return writer;
    };

    /**
     * Encodes the specified RobotLimits message, length delimited. Does not implicitly {@link RobotLimits.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RobotLimits
     * @static
     * @param {IRobotLimits} message RobotLimits message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotLimits.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RobotLimits message from the specified reader or buffer.
     * @function decode
     * @memberof RobotLimits
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RobotLimits} RobotLimits
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotLimits.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RobotLimits();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.accSpeedupAbsoluteMax = reader.float();
                    break;
                }
            case 2: {
                    message.accSpeedupAngularMax = reader.float();
                    break;
                }
            case 3: {
                    message.accBrakeAbsoluteMax = reader.float();
                    break;
                }
            case 4: {
                    message.accBrakeAngularMax = reader.float();
                    break;
                }
            case 5: {
                    message.velAbsoluteMax = reader.float();
                    break;
                }
            case 6: {
                    message.velAngularMax = reader.float();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RobotLimits message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RobotLimits
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RobotLimits} RobotLimits
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotLimits.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RobotLimits message.
     * @function verify
     * @memberof RobotLimits
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RobotLimits.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.accSpeedupAbsoluteMax != null && message.hasOwnProperty("accSpeedupAbsoluteMax"))
            if (typeof message.accSpeedupAbsoluteMax !== "number")
                return "accSpeedupAbsoluteMax: number expected";
        if (message.accSpeedupAngularMax != null && message.hasOwnProperty("accSpeedupAngularMax"))
            if (typeof message.accSpeedupAngularMax !== "number")
                return "accSpeedupAngularMax: number expected";
        if (message.accBrakeAbsoluteMax != null && message.hasOwnProperty("accBrakeAbsoluteMax"))
            if (typeof message.accBrakeAbsoluteMax !== "number")
                return "accBrakeAbsoluteMax: number expected";
        if (message.accBrakeAngularMax != null && message.hasOwnProperty("accBrakeAngularMax"))
            if (typeof message.accBrakeAngularMax !== "number")
                return "accBrakeAngularMax: number expected";
        if (message.velAbsoluteMax != null && message.hasOwnProperty("velAbsoluteMax"))
            if (typeof message.velAbsoluteMax !== "number")
                return "velAbsoluteMax: number expected";
        if (message.velAngularMax != null && message.hasOwnProperty("velAngularMax"))
            if (typeof message.velAngularMax !== "number")
                return "velAngularMax: number expected";
        return null;
    };

    /**
     * Creates a RobotLimits message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RobotLimits
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RobotLimits} RobotLimits
     */
    RobotLimits.fromObject = function fromObject(object) {
        if (object instanceof $root.RobotLimits)
            return object;
        let message = new $root.RobotLimits();
        if (object.accSpeedupAbsoluteMax != null)
            message.accSpeedupAbsoluteMax = Number(object.accSpeedupAbsoluteMax);
        if (object.accSpeedupAngularMax != null)
            message.accSpeedupAngularMax = Number(object.accSpeedupAngularMax);
        if (object.accBrakeAbsoluteMax != null)
            message.accBrakeAbsoluteMax = Number(object.accBrakeAbsoluteMax);
        if (object.accBrakeAngularMax != null)
            message.accBrakeAngularMax = Number(object.accBrakeAngularMax);
        if (object.velAbsoluteMax != null)
            message.velAbsoluteMax = Number(object.velAbsoluteMax);
        if (object.velAngularMax != null)
            message.velAngularMax = Number(object.velAngularMax);
        return message;
    };

    /**
     * Creates a plain object from a RobotLimits message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RobotLimits
     * @static
     * @param {RobotLimits} message RobotLimits
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RobotLimits.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.accSpeedupAbsoluteMax = 0;
            object.accSpeedupAngularMax = 0;
            object.accBrakeAbsoluteMax = 0;
            object.accBrakeAngularMax = 0;
            object.velAbsoluteMax = 0;
            object.velAngularMax = 0;
        }
        if (message.accSpeedupAbsoluteMax != null && message.hasOwnProperty("accSpeedupAbsoluteMax"))
            object.accSpeedupAbsoluteMax = options.json && !isFinite(message.accSpeedupAbsoluteMax) ? String(message.accSpeedupAbsoluteMax) : message.accSpeedupAbsoluteMax;
        if (message.accSpeedupAngularMax != null && message.hasOwnProperty("accSpeedupAngularMax"))
            object.accSpeedupAngularMax = options.json && !isFinite(message.accSpeedupAngularMax) ? String(message.accSpeedupAngularMax) : message.accSpeedupAngularMax;
        if (message.accBrakeAbsoluteMax != null && message.hasOwnProperty("accBrakeAbsoluteMax"))
            object.accBrakeAbsoluteMax = options.json && !isFinite(message.accBrakeAbsoluteMax) ? String(message.accBrakeAbsoluteMax) : message.accBrakeAbsoluteMax;
        if (message.accBrakeAngularMax != null && message.hasOwnProperty("accBrakeAngularMax"))
            object.accBrakeAngularMax = options.json && !isFinite(message.accBrakeAngularMax) ? String(message.accBrakeAngularMax) : message.accBrakeAngularMax;
        if (message.velAbsoluteMax != null && message.hasOwnProperty("velAbsoluteMax"))
            object.velAbsoluteMax = options.json && !isFinite(message.velAbsoluteMax) ? String(message.velAbsoluteMax) : message.velAbsoluteMax;
        if (message.velAngularMax != null && message.hasOwnProperty("velAngularMax"))
            object.velAngularMax = options.json && !isFinite(message.velAngularMax) ? String(message.velAngularMax) : message.velAngularMax;
        return object;
    };

    /**
     * Converts this RobotLimits to JSON.
     * @function toJSON
     * @memberof RobotLimits
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RobotLimits.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RobotLimits
     * @function getTypeUrl
     * @memberof RobotLimits
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RobotLimits.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RobotLimits";
    };

    return RobotLimits;
})();

export const RobotWheelAngles = $root.RobotWheelAngles = (() => {

    /**
     * Properties of a RobotWheelAngles.
     * @exports IRobotWheelAngles
     * @interface IRobotWheelAngles
     * @property {number} frontRight RobotWheelAngles frontRight
     * @property {number} backRight RobotWheelAngles backRight
     * @property {number} backLeft RobotWheelAngles backLeft
     * @property {number} frontLeft RobotWheelAngles frontLeft
     */

    /**
     * Constructs a new RobotWheelAngles.
     * @exports RobotWheelAngles
     * @classdesc Represents a RobotWheelAngles.
     * @implements IRobotWheelAngles
     * @constructor
     * @param {IRobotWheelAngles=} [properties] Properties to set
     */
    function RobotWheelAngles(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RobotWheelAngles frontRight.
     * @member {number} frontRight
     * @memberof RobotWheelAngles
     * @instance
     */
    RobotWheelAngles.prototype.frontRight = 0;

    /**
     * RobotWheelAngles backRight.
     * @member {number} backRight
     * @memberof RobotWheelAngles
     * @instance
     */
    RobotWheelAngles.prototype.backRight = 0;

    /**
     * RobotWheelAngles backLeft.
     * @member {number} backLeft
     * @memberof RobotWheelAngles
     * @instance
     */
    RobotWheelAngles.prototype.backLeft = 0;

    /**
     * RobotWheelAngles frontLeft.
     * @member {number} frontLeft
     * @memberof RobotWheelAngles
     * @instance
     */
    RobotWheelAngles.prototype.frontLeft = 0;

    /**
     * Creates a new RobotWheelAngles instance using the specified properties.
     * @function create
     * @memberof RobotWheelAngles
     * @static
     * @param {IRobotWheelAngles=} [properties] Properties to set
     * @returns {RobotWheelAngles} RobotWheelAngles instance
     */
    RobotWheelAngles.create = function create(properties) {
        return new RobotWheelAngles(properties);
    };

    /**
     * Encodes the specified RobotWheelAngles message. Does not implicitly {@link RobotWheelAngles.verify|verify} messages.
     * @function encode
     * @memberof RobotWheelAngles
     * @static
     * @param {IRobotWheelAngles} message RobotWheelAngles message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotWheelAngles.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 5 =*/13).float(message.frontRight);
        writer.uint32(/* id 2, wireType 5 =*/21).float(message.backRight);
        writer.uint32(/* id 3, wireType 5 =*/29).float(message.backLeft);
        writer.uint32(/* id 4, wireType 5 =*/37).float(message.frontLeft);
        return writer;
    };

    /**
     * Encodes the specified RobotWheelAngles message, length delimited. Does not implicitly {@link RobotWheelAngles.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RobotWheelAngles
     * @static
     * @param {IRobotWheelAngles} message RobotWheelAngles message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotWheelAngles.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RobotWheelAngles message from the specified reader or buffer.
     * @function decode
     * @memberof RobotWheelAngles
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RobotWheelAngles} RobotWheelAngles
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotWheelAngles.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RobotWheelAngles();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.frontRight = reader.float();
                    break;
                }
            case 2: {
                    message.backRight = reader.float();
                    break;
                }
            case 3: {
                    message.backLeft = reader.float();
                    break;
                }
            case 4: {
                    message.frontLeft = reader.float();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("frontRight"))
            throw $util.ProtocolError("missing required 'frontRight'", { instance: message });
        if (!message.hasOwnProperty("backRight"))
            throw $util.ProtocolError("missing required 'backRight'", { instance: message });
        if (!message.hasOwnProperty("backLeft"))
            throw $util.ProtocolError("missing required 'backLeft'", { instance: message });
        if (!message.hasOwnProperty("frontLeft"))
            throw $util.ProtocolError("missing required 'frontLeft'", { instance: message });
        return message;
    };

    /**
     * Decodes a RobotWheelAngles message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RobotWheelAngles
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RobotWheelAngles} RobotWheelAngles
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotWheelAngles.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RobotWheelAngles message.
     * @function verify
     * @memberof RobotWheelAngles
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RobotWheelAngles.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (typeof message.frontRight !== "number")
            return "frontRight: number expected";
        if (typeof message.backRight !== "number")
            return "backRight: number expected";
        if (typeof message.backLeft !== "number")
            return "backLeft: number expected";
        if (typeof message.frontLeft !== "number")
            return "frontLeft: number expected";
        return null;
    };

    /**
     * Creates a RobotWheelAngles message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RobotWheelAngles
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RobotWheelAngles} RobotWheelAngles
     */
    RobotWheelAngles.fromObject = function fromObject(object) {
        if (object instanceof $root.RobotWheelAngles)
            return object;
        let message = new $root.RobotWheelAngles();
        if (object.frontRight != null)
            message.frontRight = Number(object.frontRight);
        if (object.backRight != null)
            message.backRight = Number(object.backRight);
        if (object.backLeft != null)
            message.backLeft = Number(object.backLeft);
        if (object.frontLeft != null)
            message.frontLeft = Number(object.frontLeft);
        return message;
    };

    /**
     * Creates a plain object from a RobotWheelAngles message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RobotWheelAngles
     * @static
     * @param {RobotWheelAngles} message RobotWheelAngles
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RobotWheelAngles.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.frontRight = 0;
            object.backRight = 0;
            object.backLeft = 0;
            object.frontLeft = 0;
        }
        if (message.frontRight != null && message.hasOwnProperty("frontRight"))
            object.frontRight = options.json && !isFinite(message.frontRight) ? String(message.frontRight) : message.frontRight;
        if (message.backRight != null && message.hasOwnProperty("backRight"))
            object.backRight = options.json && !isFinite(message.backRight) ? String(message.backRight) : message.backRight;
        if (message.backLeft != null && message.hasOwnProperty("backLeft"))
            object.backLeft = options.json && !isFinite(message.backLeft) ? String(message.backLeft) : message.backLeft;
        if (message.frontLeft != null && message.hasOwnProperty("frontLeft"))
            object.frontLeft = options.json && !isFinite(message.frontLeft) ? String(message.frontLeft) : message.frontLeft;
        return object;
    };

    /**
     * Converts this RobotWheelAngles to JSON.
     * @function toJSON
     * @memberof RobotWheelAngles
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RobotWheelAngles.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RobotWheelAngles
     * @function getTypeUrl
     * @memberof RobotWheelAngles
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RobotWheelAngles.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RobotWheelAngles";
    };

    return RobotWheelAngles;
})();

export const RobotSpecs = $root.RobotSpecs = (() => {

    /**
     * Properties of a RobotSpecs.
     * @exports IRobotSpecs
     * @interface IRobotSpecs
     * @property {IRobotId} id RobotSpecs id
     * @property {number|null} [radius] RobotSpecs radius
     * @property {number|null} [height] RobotSpecs height
     * @property {number|null} [mass] RobotSpecs mass
     * @property {number|null} [maxLinearKickSpeed] RobotSpecs maxLinearKickSpeed
     * @property {number|null} [maxChipKickSpeed] RobotSpecs maxChipKickSpeed
     * @property {number|null} [centerToDribbler] RobotSpecs centerToDribbler
     * @property {IRobotLimits|null} [limits] RobotSpecs limits
     * @property {IRobotWheelAngles|null} [wheelAngles] RobotSpecs wheelAngles
     * @property {Array.<google.protobuf.IAny>|null} [custom] RobotSpecs custom
     */

    /**
     * Constructs a new RobotSpecs.
     * @exports RobotSpecs
     * @classdesc Represents a RobotSpecs.
     * @implements IRobotSpecs
     * @constructor
     * @param {IRobotSpecs=} [properties] Properties to set
     */
    function RobotSpecs(properties) {
        this.custom = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RobotSpecs id.
     * @member {IRobotId} id
     * @memberof RobotSpecs
     * @instance
     */
    RobotSpecs.prototype.id = null;

    /**
     * RobotSpecs radius.
     * @member {number} radius
     * @memberof RobotSpecs
     * @instance
     */
    RobotSpecs.prototype.radius = 0.09;

    /**
     * RobotSpecs height.
     * @member {number} height
     * @memberof RobotSpecs
     * @instance
     */
    RobotSpecs.prototype.height = 0.15;

    /**
     * RobotSpecs mass.
     * @member {number} mass
     * @memberof RobotSpecs
     * @instance
     */
    RobotSpecs.prototype.mass = 0;

    /**
     * RobotSpecs maxLinearKickSpeed.
     * @member {number} maxLinearKickSpeed
     * @memberof RobotSpecs
     * @instance
     */
    RobotSpecs.prototype.maxLinearKickSpeed = 0;

    /**
     * RobotSpecs maxChipKickSpeed.
     * @member {number} maxChipKickSpeed
     * @memberof RobotSpecs
     * @instance
     */
    RobotSpecs.prototype.maxChipKickSpeed = 0;

    /**
     * RobotSpecs centerToDribbler.
     * @member {number} centerToDribbler
     * @memberof RobotSpecs
     * @instance
     */
    RobotSpecs.prototype.centerToDribbler = 0;

    /**
     * RobotSpecs limits.
     * @member {IRobotLimits|null|undefined} limits
     * @memberof RobotSpecs
     * @instance
     */
    RobotSpecs.prototype.limits = null;

    /**
     * RobotSpecs wheelAngles.
     * @member {IRobotWheelAngles|null|undefined} wheelAngles
     * @memberof RobotSpecs
     * @instance
     */
    RobotSpecs.prototype.wheelAngles = null;

    /**
     * RobotSpecs custom.
     * @member {Array.<google.protobuf.IAny>} custom
     * @memberof RobotSpecs
     * @instance
     */
    RobotSpecs.prototype.custom = $util.emptyArray;

    /**
     * Creates a new RobotSpecs instance using the specified properties.
     * @function create
     * @memberof RobotSpecs
     * @static
     * @param {IRobotSpecs=} [properties] Properties to set
     * @returns {RobotSpecs} RobotSpecs instance
     */
    RobotSpecs.create = function create(properties) {
        return new RobotSpecs(properties);
    };

    /**
     * Encodes the specified RobotSpecs message. Does not implicitly {@link RobotSpecs.verify|verify} messages.
     * @function encode
     * @memberof RobotSpecs
     * @static
     * @param {IRobotSpecs} message RobotSpecs message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotSpecs.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        $root.RobotId.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.radius != null && Object.hasOwnProperty.call(message, "radius"))
            writer.uint32(/* id 2, wireType 5 =*/21).float(message.radius);
        if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.height);
        if (message.mass != null && Object.hasOwnProperty.call(message, "mass"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.mass);
        if (message.maxLinearKickSpeed != null && Object.hasOwnProperty.call(message, "maxLinearKickSpeed"))
            writer.uint32(/* id 7, wireType 5 =*/61).float(message.maxLinearKickSpeed);
        if (message.maxChipKickSpeed != null && Object.hasOwnProperty.call(message, "maxChipKickSpeed"))
            writer.uint32(/* id 8, wireType 5 =*/69).float(message.maxChipKickSpeed);
        if (message.centerToDribbler != null && Object.hasOwnProperty.call(message, "centerToDribbler"))
            writer.uint32(/* id 9, wireType 5 =*/77).float(message.centerToDribbler);
        if (message.limits != null && Object.hasOwnProperty.call(message, "limits"))
            $root.RobotLimits.encode(message.limits, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
        if (message.wheelAngles != null && Object.hasOwnProperty.call(message, "wheelAngles"))
            $root.RobotWheelAngles.encode(message.wheelAngles, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
        if (message.custom != null && message.custom.length)
            for (let i = 0; i < message.custom.length; ++i)
                $root.google.protobuf.Any.encode(message.custom[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RobotSpecs message, length delimited. Does not implicitly {@link RobotSpecs.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RobotSpecs
     * @static
     * @param {IRobotSpecs} message RobotSpecs message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotSpecs.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RobotSpecs message from the specified reader or buffer.
     * @function decode
     * @memberof RobotSpecs
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RobotSpecs} RobotSpecs
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotSpecs.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RobotSpecs();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.id = $root.RobotId.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.radius = reader.float();
                    break;
                }
            case 3: {
                    message.height = reader.float();
                    break;
                }
            case 4: {
                    message.mass = reader.float();
                    break;
                }
            case 7: {
                    message.maxLinearKickSpeed = reader.float();
                    break;
                }
            case 8: {
                    message.maxChipKickSpeed = reader.float();
                    break;
                }
            case 9: {
                    message.centerToDribbler = reader.float();
                    break;
                }
            case 10: {
                    message.limits = $root.RobotLimits.decode(reader, reader.uint32());
                    break;
                }
            case 13: {
                    message.wheelAngles = $root.RobotWheelAngles.decode(reader, reader.uint32());
                    break;
                }
            case 14: {
                    if (!(message.custom && message.custom.length))
                        message.custom = [];
                    message.custom.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("id"))
            throw $util.ProtocolError("missing required 'id'", { instance: message });
        return message;
    };

    /**
     * Decodes a RobotSpecs message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RobotSpecs
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RobotSpecs} RobotSpecs
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotSpecs.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RobotSpecs message.
     * @function verify
     * @memberof RobotSpecs
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RobotSpecs.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        {
            let error = $root.RobotId.verify(message.id);
            if (error)
                return "id." + error;
        }
        if (message.radius != null && message.hasOwnProperty("radius"))
            if (typeof message.radius !== "number")
                return "radius: number expected";
        if (message.height != null && message.hasOwnProperty("height"))
            if (typeof message.height !== "number")
                return "height: number expected";
        if (message.mass != null && message.hasOwnProperty("mass"))
            if (typeof message.mass !== "number")
                return "mass: number expected";
        if (message.maxLinearKickSpeed != null && message.hasOwnProperty("maxLinearKickSpeed"))
            if (typeof message.maxLinearKickSpeed !== "number")
                return "maxLinearKickSpeed: number expected";
        if (message.maxChipKickSpeed != null && message.hasOwnProperty("maxChipKickSpeed"))
            if (typeof message.maxChipKickSpeed !== "number")
                return "maxChipKickSpeed: number expected";
        if (message.centerToDribbler != null && message.hasOwnProperty("centerToDribbler"))
            if (typeof message.centerToDribbler !== "number")
                return "centerToDribbler: number expected";
        if (message.limits != null && message.hasOwnProperty("limits")) {
            let error = $root.RobotLimits.verify(message.limits);
            if (error)
                return "limits." + error;
        }
        if (message.wheelAngles != null && message.hasOwnProperty("wheelAngles")) {
            let error = $root.RobotWheelAngles.verify(message.wheelAngles);
            if (error)
                return "wheelAngles." + error;
        }
        if (message.custom != null && message.hasOwnProperty("custom")) {
            if (!Array.isArray(message.custom))
                return "custom: array expected";
            for (let i = 0; i < message.custom.length; ++i) {
                let error = $root.google.protobuf.Any.verify(message.custom[i]);
                if (error)
                    return "custom." + error;
            }
        }
        return null;
    };

    /**
     * Creates a RobotSpecs message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RobotSpecs
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RobotSpecs} RobotSpecs
     */
    RobotSpecs.fromObject = function fromObject(object) {
        if (object instanceof $root.RobotSpecs)
            return object;
        let message = new $root.RobotSpecs();
        if (object.id != null) {
            if (typeof object.id !== "object")
                throw TypeError(".RobotSpecs.id: object expected");
            message.id = $root.RobotId.fromObject(object.id);
        }
        if (object.radius != null)
            message.radius = Number(object.radius);
        if (object.height != null)
            message.height = Number(object.height);
        if (object.mass != null)
            message.mass = Number(object.mass);
        if (object.maxLinearKickSpeed != null)
            message.maxLinearKickSpeed = Number(object.maxLinearKickSpeed);
        if (object.maxChipKickSpeed != null)
            message.maxChipKickSpeed = Number(object.maxChipKickSpeed);
        if (object.centerToDribbler != null)
            message.centerToDribbler = Number(object.centerToDribbler);
        if (object.limits != null) {
            if (typeof object.limits !== "object")
                throw TypeError(".RobotSpecs.limits: object expected");
            message.limits = $root.RobotLimits.fromObject(object.limits);
        }
        if (object.wheelAngles != null) {
            if (typeof object.wheelAngles !== "object")
                throw TypeError(".RobotSpecs.wheelAngles: object expected");
            message.wheelAngles = $root.RobotWheelAngles.fromObject(object.wheelAngles);
        }
        if (object.custom) {
            if (!Array.isArray(object.custom))
                throw TypeError(".RobotSpecs.custom: array expected");
            message.custom = [];
            for (let i = 0; i < object.custom.length; ++i) {
                if (typeof object.custom[i] !== "object")
                    throw TypeError(".RobotSpecs.custom: object expected");
                message.custom[i] = $root.google.protobuf.Any.fromObject(object.custom[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a RobotSpecs message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RobotSpecs
     * @static
     * @param {RobotSpecs} message RobotSpecs
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RobotSpecs.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.custom = [];
        if (options.defaults) {
            object.id = null;
            object.radius = 0.09;
            object.height = 0.15;
            object.mass = 0;
            object.maxLinearKickSpeed = 0;
            object.maxChipKickSpeed = 0;
            object.centerToDribbler = 0;
            object.limits = null;
            object.wheelAngles = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = $root.RobotId.toObject(message.id, options);
        if (message.radius != null && message.hasOwnProperty("radius"))
            object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
        if (message.height != null && message.hasOwnProperty("height"))
            object.height = options.json && !isFinite(message.height) ? String(message.height) : message.height;
        if (message.mass != null && message.hasOwnProperty("mass"))
            object.mass = options.json && !isFinite(message.mass) ? String(message.mass) : message.mass;
        if (message.maxLinearKickSpeed != null && message.hasOwnProperty("maxLinearKickSpeed"))
            object.maxLinearKickSpeed = options.json && !isFinite(message.maxLinearKickSpeed) ? String(message.maxLinearKickSpeed) : message.maxLinearKickSpeed;
        if (message.maxChipKickSpeed != null && message.hasOwnProperty("maxChipKickSpeed"))
            object.maxChipKickSpeed = options.json && !isFinite(message.maxChipKickSpeed) ? String(message.maxChipKickSpeed) : message.maxChipKickSpeed;
        if (message.centerToDribbler != null && message.hasOwnProperty("centerToDribbler"))
            object.centerToDribbler = options.json && !isFinite(message.centerToDribbler) ? String(message.centerToDribbler) : message.centerToDribbler;
        if (message.limits != null && message.hasOwnProperty("limits"))
            object.limits = $root.RobotLimits.toObject(message.limits, options);
        if (message.wheelAngles != null && message.hasOwnProperty("wheelAngles"))
            object.wheelAngles = $root.RobotWheelAngles.toObject(message.wheelAngles, options);
        if (message.custom && message.custom.length) {
            object.custom = [];
            for (let j = 0; j < message.custom.length; ++j)
                object.custom[j] = $root.google.protobuf.Any.toObject(message.custom[j], options);
        }
        return object;
    };

    /**
     * Converts this RobotSpecs to JSON.
     * @function toJSON
     * @memberof RobotSpecs
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RobotSpecs.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RobotSpecs
     * @function getTypeUrl
     * @memberof RobotSpecs
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RobotSpecs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RobotSpecs";
    };

    return RobotSpecs;
})();

export const RealismConfig = $root.RealismConfig = (() => {

    /**
     * Properties of a RealismConfig.
     * @exports IRealismConfig
     * @interface IRealismConfig
     * @property {Array.<google.protobuf.IAny>|null} [custom] RealismConfig custom
     */

    /**
     * Constructs a new RealismConfig.
     * @exports RealismConfig
     * @classdesc Represents a RealismConfig.
     * @implements IRealismConfig
     * @constructor
     * @param {IRealismConfig=} [properties] Properties to set
     */
    function RealismConfig(properties) {
        this.custom = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RealismConfig custom.
     * @member {Array.<google.protobuf.IAny>} custom
     * @memberof RealismConfig
     * @instance
     */
    RealismConfig.prototype.custom = $util.emptyArray;

    /**
     * Creates a new RealismConfig instance using the specified properties.
     * @function create
     * @memberof RealismConfig
     * @static
     * @param {IRealismConfig=} [properties] Properties to set
     * @returns {RealismConfig} RealismConfig instance
     */
    RealismConfig.create = function create(properties) {
        return new RealismConfig(properties);
    };

    /**
     * Encodes the specified RealismConfig message. Does not implicitly {@link RealismConfig.verify|verify} messages.
     * @function encode
     * @memberof RealismConfig
     * @static
     * @param {IRealismConfig} message RealismConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RealismConfig.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.custom != null && message.custom.length)
            for (let i = 0; i < message.custom.length; ++i)
                $root.google.protobuf.Any.encode(message.custom[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RealismConfig message, length delimited. Does not implicitly {@link RealismConfig.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RealismConfig
     * @static
     * @param {IRealismConfig} message RealismConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RealismConfig.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RealismConfig message from the specified reader or buffer.
     * @function decode
     * @memberof RealismConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RealismConfig} RealismConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RealismConfig.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RealismConfig();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.custom && message.custom.length))
                        message.custom = [];
                    message.custom.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RealismConfig message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RealismConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RealismConfig} RealismConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RealismConfig.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RealismConfig message.
     * @function verify
     * @memberof RealismConfig
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RealismConfig.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.custom != null && message.hasOwnProperty("custom")) {
            if (!Array.isArray(message.custom))
                return "custom: array expected";
            for (let i = 0; i < message.custom.length; ++i) {
                let error = $root.google.protobuf.Any.verify(message.custom[i]);
                if (error)
                    return "custom." + error;
            }
        }
        return null;
    };

    /**
     * Creates a RealismConfig message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RealismConfig
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RealismConfig} RealismConfig
     */
    RealismConfig.fromObject = function fromObject(object) {
        if (object instanceof $root.RealismConfig)
            return object;
        let message = new $root.RealismConfig();
        if (object.custom) {
            if (!Array.isArray(object.custom))
                throw TypeError(".RealismConfig.custom: array expected");
            message.custom = [];
            for (let i = 0; i < object.custom.length; ++i) {
                if (typeof object.custom[i] !== "object")
                    throw TypeError(".RealismConfig.custom: object expected");
                message.custom[i] = $root.google.protobuf.Any.fromObject(object.custom[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a RealismConfig message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RealismConfig
     * @static
     * @param {RealismConfig} message RealismConfig
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RealismConfig.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.custom = [];
        if (message.custom && message.custom.length) {
            object.custom = [];
            for (let j = 0; j < message.custom.length; ++j)
                object.custom[j] = $root.google.protobuf.Any.toObject(message.custom[j], options);
        }
        return object;
    };

    /**
     * Converts this RealismConfig to JSON.
     * @function toJSON
     * @memberof RealismConfig
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RealismConfig.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RealismConfig
     * @function getTypeUrl
     * @memberof RealismConfig
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RealismConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RealismConfig";
    };

    return RealismConfig;
})();

export const SimulatorConfig = $root.SimulatorConfig = (() => {

    /**
     * Properties of a SimulatorConfig.
     * @exports ISimulatorConfig
     * @interface ISimulatorConfig
     * @property {ISSL_GeometryData|null} [geometry] SimulatorConfig geometry
     * @property {Array.<IRobotSpecs>|null} [robotSpecs] SimulatorConfig robotSpecs
     * @property {IRealismConfig|null} [realismConfig] SimulatorConfig realismConfig
     * @property {number|null} [visionPort] SimulatorConfig visionPort
     */

    /**
     * Constructs a new SimulatorConfig.
     * @exports SimulatorConfig
     * @classdesc Represents a SimulatorConfig.
     * @implements ISimulatorConfig
     * @constructor
     * @param {ISimulatorConfig=} [properties] Properties to set
     */
    function SimulatorConfig(properties) {
        this.robotSpecs = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SimulatorConfig geometry.
     * @member {ISSL_GeometryData|null|undefined} geometry
     * @memberof SimulatorConfig
     * @instance
     */
    SimulatorConfig.prototype.geometry = null;

    /**
     * SimulatorConfig robotSpecs.
     * @member {Array.<IRobotSpecs>} robotSpecs
     * @memberof SimulatorConfig
     * @instance
     */
    SimulatorConfig.prototype.robotSpecs = $util.emptyArray;

    /**
     * SimulatorConfig realismConfig.
     * @member {IRealismConfig|null|undefined} realismConfig
     * @memberof SimulatorConfig
     * @instance
     */
    SimulatorConfig.prototype.realismConfig = null;

    /**
     * SimulatorConfig visionPort.
     * @member {number} visionPort
     * @memberof SimulatorConfig
     * @instance
     */
    SimulatorConfig.prototype.visionPort = 0;

    /**
     * Creates a new SimulatorConfig instance using the specified properties.
     * @function create
     * @memberof SimulatorConfig
     * @static
     * @param {ISimulatorConfig=} [properties] Properties to set
     * @returns {SimulatorConfig} SimulatorConfig instance
     */
    SimulatorConfig.create = function create(properties) {
        return new SimulatorConfig(properties);
    };

    /**
     * Encodes the specified SimulatorConfig message. Does not implicitly {@link SimulatorConfig.verify|verify} messages.
     * @function encode
     * @memberof SimulatorConfig
     * @static
     * @param {ISimulatorConfig} message SimulatorConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulatorConfig.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.geometry != null && Object.hasOwnProperty.call(message, "geometry"))
            $root.SSL_GeometryData.encode(message.geometry, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.robotSpecs != null && message.robotSpecs.length)
            for (let i = 0; i < message.robotSpecs.length; ++i)
                $root.RobotSpecs.encode(message.robotSpecs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.realismConfig != null && Object.hasOwnProperty.call(message, "realismConfig"))
            $root.RealismConfig.encode(message.realismConfig, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        if (message.visionPort != null && Object.hasOwnProperty.call(message, "visionPort"))
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.visionPort);
        return writer;
    };

    /**
     * Encodes the specified SimulatorConfig message, length delimited. Does not implicitly {@link SimulatorConfig.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SimulatorConfig
     * @static
     * @param {ISimulatorConfig} message SimulatorConfig message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulatorConfig.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SimulatorConfig message from the specified reader or buffer.
     * @function decode
     * @memberof SimulatorConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SimulatorConfig} SimulatorConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulatorConfig.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SimulatorConfig();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.geometry = $root.SSL_GeometryData.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    if (!(message.robotSpecs && message.robotSpecs.length))
                        message.robotSpecs = [];
                    message.robotSpecs.push($root.RobotSpecs.decode(reader, reader.uint32()));
                    break;
                }
            case 3: {
                    message.realismConfig = $root.RealismConfig.decode(reader, reader.uint32());
                    break;
                }
            case 4: {
                    message.visionPort = reader.uint32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SimulatorConfig message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SimulatorConfig
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SimulatorConfig} SimulatorConfig
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulatorConfig.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SimulatorConfig message.
     * @function verify
     * @memberof SimulatorConfig
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SimulatorConfig.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.geometry != null && message.hasOwnProperty("geometry")) {
            let error = $root.SSL_GeometryData.verify(message.geometry);
            if (error)
                return "geometry." + error;
        }
        if (message.robotSpecs != null && message.hasOwnProperty("robotSpecs")) {
            if (!Array.isArray(message.robotSpecs))
                return "robotSpecs: array expected";
            for (let i = 0; i < message.robotSpecs.length; ++i) {
                let error = $root.RobotSpecs.verify(message.robotSpecs[i]);
                if (error)
                    return "robotSpecs." + error;
            }
        }
        if (message.realismConfig != null && message.hasOwnProperty("realismConfig")) {
            let error = $root.RealismConfig.verify(message.realismConfig);
            if (error)
                return "realismConfig." + error;
        }
        if (message.visionPort != null && message.hasOwnProperty("visionPort"))
            if (!$util.isInteger(message.visionPort))
                return "visionPort: integer expected";
        return null;
    };

    /**
     * Creates a SimulatorConfig message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SimulatorConfig
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SimulatorConfig} SimulatorConfig
     */
    SimulatorConfig.fromObject = function fromObject(object) {
        if (object instanceof $root.SimulatorConfig)
            return object;
        let message = new $root.SimulatorConfig();
        if (object.geometry != null) {
            if (typeof object.geometry !== "object")
                throw TypeError(".SimulatorConfig.geometry: object expected");
            message.geometry = $root.SSL_GeometryData.fromObject(object.geometry);
        }
        if (object.robotSpecs) {
            if (!Array.isArray(object.robotSpecs))
                throw TypeError(".SimulatorConfig.robotSpecs: array expected");
            message.robotSpecs = [];
            for (let i = 0; i < object.robotSpecs.length; ++i) {
                if (typeof object.robotSpecs[i] !== "object")
                    throw TypeError(".SimulatorConfig.robotSpecs: object expected");
                message.robotSpecs[i] = $root.RobotSpecs.fromObject(object.robotSpecs[i]);
            }
        }
        if (object.realismConfig != null) {
            if (typeof object.realismConfig !== "object")
                throw TypeError(".SimulatorConfig.realismConfig: object expected");
            message.realismConfig = $root.RealismConfig.fromObject(object.realismConfig);
        }
        if (object.visionPort != null)
            message.visionPort = object.visionPort >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a SimulatorConfig message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SimulatorConfig
     * @static
     * @param {SimulatorConfig} message SimulatorConfig
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SimulatorConfig.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.robotSpecs = [];
        if (options.defaults) {
            object.geometry = null;
            object.realismConfig = null;
            object.visionPort = 0;
        }
        if (message.geometry != null && message.hasOwnProperty("geometry"))
            object.geometry = $root.SSL_GeometryData.toObject(message.geometry, options);
        if (message.robotSpecs && message.robotSpecs.length) {
            object.robotSpecs = [];
            for (let j = 0; j < message.robotSpecs.length; ++j)
                object.robotSpecs[j] = $root.RobotSpecs.toObject(message.robotSpecs[j], options);
        }
        if (message.realismConfig != null && message.hasOwnProperty("realismConfig"))
            object.realismConfig = $root.RealismConfig.toObject(message.realismConfig, options);
        if (message.visionPort != null && message.hasOwnProperty("visionPort"))
            object.visionPort = message.visionPort;
        return object;
    };

    /**
     * Converts this SimulatorConfig to JSON.
     * @function toJSON
     * @memberof SimulatorConfig
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SimulatorConfig.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SimulatorConfig
     * @function getTypeUrl
     * @memberof SimulatorConfig
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SimulatorConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SimulatorConfig";
    };

    return SimulatorConfig;
})();

export const Vector2f = $root.Vector2f = (() => {

    /**
     * Properties of a Vector2f.
     * @exports IVector2f
     * @interface IVector2f
     * @property {number} x Vector2f x
     * @property {number} y Vector2f y
     */

    /**
     * Constructs a new Vector2f.
     * @exports Vector2f
     * @classdesc Represents a Vector2f.
     * @implements IVector2f
     * @constructor
     * @param {IVector2f=} [properties] Properties to set
     */
    function Vector2f(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * Vector2f x.
     * @member {number} x
     * @memberof Vector2f
     * @instance
     */
    Vector2f.prototype.x = 0;

    /**
     * Vector2f y.
     * @member {number} y
     * @memberof Vector2f
     * @instance
     */
    Vector2f.prototype.y = 0;

    /**
     * Creates a new Vector2f instance using the specified properties.
     * @function create
     * @memberof Vector2f
     * @static
     * @param {IVector2f=} [properties] Properties to set
     * @returns {Vector2f} Vector2f instance
     */
    Vector2f.create = function create(properties) {
        return new Vector2f(properties);
    };

    /**
     * Encodes the specified Vector2f message. Does not implicitly {@link Vector2f.verify|verify} messages.
     * @function encode
     * @memberof Vector2f
     * @static
     * @param {IVector2f} message Vector2f message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Vector2f.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
        writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
        return writer;
    };

    /**
     * Encodes the specified Vector2f message, length delimited. Does not implicitly {@link Vector2f.verify|verify} messages.
     * @function encodeDelimited
     * @memberof Vector2f
     * @static
     * @param {IVector2f} message Vector2f message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    Vector2f.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a Vector2f message from the specified reader or buffer.
     * @function decode
     * @memberof Vector2f
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {Vector2f} Vector2f
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Vector2f.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.Vector2f();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.x = reader.float();
                    break;
                }
            case 2: {
                    message.y = reader.float();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("x"))
            throw $util.ProtocolError("missing required 'x'", { instance: message });
        if (!message.hasOwnProperty("y"))
            throw $util.ProtocolError("missing required 'y'", { instance: message });
        return message;
    };

    /**
     * Decodes a Vector2f message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof Vector2f
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {Vector2f} Vector2f
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    Vector2f.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a Vector2f message.
     * @function verify
     * @memberof Vector2f
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    Vector2f.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (typeof message.x !== "number")
            return "x: number expected";
        if (typeof message.y !== "number")
            return "y: number expected";
        return null;
    };

    /**
     * Creates a Vector2f message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Vector2f
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {Vector2f} Vector2f
     */
    Vector2f.fromObject = function fromObject(object) {
        if (object instanceof $root.Vector2f)
            return object;
        let message = new $root.Vector2f();
        if (object.x != null)
            message.x = Number(object.x);
        if (object.y != null)
            message.y = Number(object.y);
        return message;
    };

    /**
     * Creates a plain object from a Vector2f message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Vector2f
     * @static
     * @param {Vector2f} message Vector2f
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    Vector2f.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
        return object;
    };

    /**
     * Converts this Vector2f to JSON.
     * @function toJSON
     * @memberof Vector2f
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    Vector2f.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for Vector2f
     * @function getTypeUrl
     * @memberof Vector2f
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    Vector2f.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/Vector2f";
    };

    return Vector2f;
})();

export const SSL_FieldLineSegment = $root.SSL_FieldLineSegment = (() => {

    /**
     * Properties of a SSL_FieldLineSegment.
     * @exports ISSL_FieldLineSegment
     * @interface ISSL_FieldLineSegment
     * @property {string} name SSL_FieldLineSegment name
     * @property {IVector2f} p1 SSL_FieldLineSegment p1
     * @property {IVector2f} p2 SSL_FieldLineSegment p2
     * @property {number} thickness SSL_FieldLineSegment thickness
     * @property {SSL_FieldShapeType|null} [type] SSL_FieldLineSegment type
     */

    /**
     * Constructs a new SSL_FieldLineSegment.
     * @exports SSL_FieldLineSegment
     * @classdesc Represents a SSL_FieldLineSegment.
     * @implements ISSL_FieldLineSegment
     * @constructor
     * @param {ISSL_FieldLineSegment=} [properties] Properties to set
     */
    function SSL_FieldLineSegment(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SSL_FieldLineSegment name.
     * @member {string} name
     * @memberof SSL_FieldLineSegment
     * @instance
     */
    SSL_FieldLineSegment.prototype.name = "";

    /**
     * SSL_FieldLineSegment p1.
     * @member {IVector2f} p1
     * @memberof SSL_FieldLineSegment
     * @instance
     */
    SSL_FieldLineSegment.prototype.p1 = null;

    /**
     * SSL_FieldLineSegment p2.
     * @member {IVector2f} p2
     * @memberof SSL_FieldLineSegment
     * @instance
     */
    SSL_FieldLineSegment.prototype.p2 = null;

    /**
     * SSL_FieldLineSegment thickness.
     * @member {number} thickness
     * @memberof SSL_FieldLineSegment
     * @instance
     */
    SSL_FieldLineSegment.prototype.thickness = 0;

    /**
     * SSL_FieldLineSegment type.
     * @member {SSL_FieldShapeType} type
     * @memberof SSL_FieldLineSegment
     * @instance
     */
    SSL_FieldLineSegment.prototype.type = 0;

    /**
     * Creates a new SSL_FieldLineSegment instance using the specified properties.
     * @function create
     * @memberof SSL_FieldLineSegment
     * @static
     * @param {ISSL_FieldLineSegment=} [properties] Properties to set
     * @returns {SSL_FieldLineSegment} SSL_FieldLineSegment instance
     */
    SSL_FieldLineSegment.create = function create(properties) {
        return new SSL_FieldLineSegment(properties);
    };

    /**
     * Encodes the specified SSL_FieldLineSegment message. Does not implicitly {@link SSL_FieldLineSegment.verify|verify} messages.
     * @function encode
     * @memberof SSL_FieldLineSegment
     * @static
     * @param {ISSL_FieldLineSegment} message SSL_FieldLineSegment message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_FieldLineSegment.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        $root.Vector2f.encode(message.p1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        $root.Vector2f.encode(message.p2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        writer.uint32(/* id 4, wireType 5 =*/37).float(message.thickness);
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified SSL_FieldLineSegment message, length delimited. Does not implicitly {@link SSL_FieldLineSegment.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SSL_FieldLineSegment
     * @static
     * @param {ISSL_FieldLineSegment} message SSL_FieldLineSegment message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_FieldLineSegment.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SSL_FieldLineSegment message from the specified reader or buffer.
     * @function decode
     * @memberof SSL_FieldLineSegment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SSL_FieldLineSegment} SSL_FieldLineSegment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_FieldLineSegment.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SSL_FieldLineSegment();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.name = reader.string();
                    break;
                }
            case 2: {
                    message.p1 = $root.Vector2f.decode(reader, reader.uint32());
                    break;
                }
            case 3: {
                    message.p2 = $root.Vector2f.decode(reader, reader.uint32());
                    break;
                }
            case 4: {
                    message.thickness = reader.float();
                    break;
                }
            case 5: {
                    message.type = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("name"))
            throw $util.ProtocolError("missing required 'name'", { instance: message });
        if (!message.hasOwnProperty("p1"))
            throw $util.ProtocolError("missing required 'p1'", { instance: message });
        if (!message.hasOwnProperty("p2"))
            throw $util.ProtocolError("missing required 'p2'", { instance: message });
        if (!message.hasOwnProperty("thickness"))
            throw $util.ProtocolError("missing required 'thickness'", { instance: message });
        return message;
    };

    /**
     * Decodes a SSL_FieldLineSegment message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SSL_FieldLineSegment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SSL_FieldLineSegment} SSL_FieldLineSegment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_FieldLineSegment.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SSL_FieldLineSegment message.
     * @function verify
     * @memberof SSL_FieldLineSegment
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SSL_FieldLineSegment.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isString(message.name))
            return "name: string expected";
        {
            let error = $root.Vector2f.verify(message.p1);
            if (error)
                return "p1." + error;
        }
        {
            let error = $root.Vector2f.verify(message.p2);
            if (error)
                return "p2." + error;
        }
        if (typeof message.thickness !== "number")
            return "thickness: number expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
                break;
            }
        return null;
    };

    /**
     * Creates a SSL_FieldLineSegment message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SSL_FieldLineSegment
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SSL_FieldLineSegment} SSL_FieldLineSegment
     */
    SSL_FieldLineSegment.fromObject = function fromObject(object) {
        if (object instanceof $root.SSL_FieldLineSegment)
            return object;
        let message = new $root.SSL_FieldLineSegment();
        if (object.name != null)
            message.name = String(object.name);
        if (object.p1 != null) {
            if (typeof object.p1 !== "object")
                throw TypeError(".SSL_FieldLineSegment.p1: object expected");
            message.p1 = $root.Vector2f.fromObject(object.p1);
        }
        if (object.p2 != null) {
            if (typeof object.p2 !== "object")
                throw TypeError(".SSL_FieldLineSegment.p2: object expected");
            message.p2 = $root.Vector2f.fromObject(object.p2);
        }
        if (object.thickness != null)
            message.thickness = Number(object.thickness);
        switch (object.type) {
        default:
            if (typeof object.type === "number") {
                message.type = object.type;
                break;
            }
            break;
        case "Undefined":
        case 0:
            message.type = 0;
            break;
        case "CenterCircle":
        case 1:
            message.type = 1;
            break;
        case "TopTouchLine":
        case 2:
            message.type = 2;
            break;
        case "BottomTouchLine":
        case 3:
            message.type = 3;
            break;
        case "LeftGoalLine":
        case 4:
            message.type = 4;
            break;
        case "RightGoalLine":
        case 5:
            message.type = 5;
            break;
        case "HalfwayLine":
        case 6:
            message.type = 6;
            break;
        case "CenterLine":
        case 7:
            message.type = 7;
            break;
        case "LeftPenaltyStretch":
        case 8:
            message.type = 8;
            break;
        case "RightPenaltyStretch":
        case 9:
            message.type = 9;
            break;
        case "LeftFieldLeftPenaltyStretch":
        case 10:
            message.type = 10;
            break;
        case "LeftFieldRightPenaltyStretch":
        case 11:
            message.type = 11;
            break;
        case "RightFieldLeftPenaltyStretch":
        case 12:
            message.type = 12;
            break;
        case "RightFieldRightPenaltyStretch":
        case 13:
            message.type = 13;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a SSL_FieldLineSegment message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SSL_FieldLineSegment
     * @static
     * @param {SSL_FieldLineSegment} message SSL_FieldLineSegment
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SSL_FieldLineSegment.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            object.p1 = null;
            object.p2 = null;
            object.thickness = 0;
            object.type = options.enums === String ? "Undefined" : 0;
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.p1 != null && message.hasOwnProperty("p1"))
            object.p1 = $root.Vector2f.toObject(message.p1, options);
        if (message.p2 != null && message.hasOwnProperty("p2"))
            object.p2 = $root.Vector2f.toObject(message.p2, options);
        if (message.thickness != null && message.hasOwnProperty("thickness"))
            object.thickness = options.json && !isFinite(message.thickness) ? String(message.thickness) : message.thickness;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.SSL_FieldShapeType[message.type] === undefined ? message.type : $root.SSL_FieldShapeType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this SSL_FieldLineSegment to JSON.
     * @function toJSON
     * @memberof SSL_FieldLineSegment
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SSL_FieldLineSegment.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SSL_FieldLineSegment
     * @function getTypeUrl
     * @memberof SSL_FieldLineSegment
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SSL_FieldLineSegment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SSL_FieldLineSegment";
    };

    return SSL_FieldLineSegment;
})();

export const SSL_FieldCircularArc = $root.SSL_FieldCircularArc = (() => {

    /**
     * Properties of a SSL_FieldCircularArc.
     * @exports ISSL_FieldCircularArc
     * @interface ISSL_FieldCircularArc
     * @property {string} name SSL_FieldCircularArc name
     * @property {IVector2f} center SSL_FieldCircularArc center
     * @property {number} radius SSL_FieldCircularArc radius
     * @property {number} a1 SSL_FieldCircularArc a1
     * @property {number} a2 SSL_FieldCircularArc a2
     * @property {number} thickness SSL_FieldCircularArc thickness
     * @property {SSL_FieldShapeType|null} [type] SSL_FieldCircularArc type
     */

    /**
     * Constructs a new SSL_FieldCircularArc.
     * @exports SSL_FieldCircularArc
     * @classdesc Represents a SSL_FieldCircularArc.
     * @implements ISSL_FieldCircularArc
     * @constructor
     * @param {ISSL_FieldCircularArc=} [properties] Properties to set
     */
    function SSL_FieldCircularArc(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SSL_FieldCircularArc name.
     * @member {string} name
     * @memberof SSL_FieldCircularArc
     * @instance
     */
    SSL_FieldCircularArc.prototype.name = "";

    /**
     * SSL_FieldCircularArc center.
     * @member {IVector2f} center
     * @memberof SSL_FieldCircularArc
     * @instance
     */
    SSL_FieldCircularArc.prototype.center = null;

    /**
     * SSL_FieldCircularArc radius.
     * @member {number} radius
     * @memberof SSL_FieldCircularArc
     * @instance
     */
    SSL_FieldCircularArc.prototype.radius = 0;

    /**
     * SSL_FieldCircularArc a1.
     * @member {number} a1
     * @memberof SSL_FieldCircularArc
     * @instance
     */
    SSL_FieldCircularArc.prototype.a1 = 0;

    /**
     * SSL_FieldCircularArc a2.
     * @member {number} a2
     * @memberof SSL_FieldCircularArc
     * @instance
     */
    SSL_FieldCircularArc.prototype.a2 = 0;

    /**
     * SSL_FieldCircularArc thickness.
     * @member {number} thickness
     * @memberof SSL_FieldCircularArc
     * @instance
     */
    SSL_FieldCircularArc.prototype.thickness = 0;

    /**
     * SSL_FieldCircularArc type.
     * @member {SSL_FieldShapeType} type
     * @memberof SSL_FieldCircularArc
     * @instance
     */
    SSL_FieldCircularArc.prototype.type = 0;

    /**
     * Creates a new SSL_FieldCircularArc instance using the specified properties.
     * @function create
     * @memberof SSL_FieldCircularArc
     * @static
     * @param {ISSL_FieldCircularArc=} [properties] Properties to set
     * @returns {SSL_FieldCircularArc} SSL_FieldCircularArc instance
     */
    SSL_FieldCircularArc.create = function create(properties) {
        return new SSL_FieldCircularArc(properties);
    };

    /**
     * Encodes the specified SSL_FieldCircularArc message. Does not implicitly {@link SSL_FieldCircularArc.verify|verify} messages.
     * @function encode
     * @memberof SSL_FieldCircularArc
     * @static
     * @param {ISSL_FieldCircularArc} message SSL_FieldCircularArc message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_FieldCircularArc.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
        $root.Vector2f.encode(message.center, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        writer.uint32(/* id 3, wireType 5 =*/29).float(message.radius);
        writer.uint32(/* id 4, wireType 5 =*/37).float(message.a1);
        writer.uint32(/* id 5, wireType 5 =*/45).float(message.a2);
        writer.uint32(/* id 6, wireType 5 =*/53).float(message.thickness);
        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
        return writer;
    };

    /**
     * Encodes the specified SSL_FieldCircularArc message, length delimited. Does not implicitly {@link SSL_FieldCircularArc.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SSL_FieldCircularArc
     * @static
     * @param {ISSL_FieldCircularArc} message SSL_FieldCircularArc message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_FieldCircularArc.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SSL_FieldCircularArc message from the specified reader or buffer.
     * @function decode
     * @memberof SSL_FieldCircularArc
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SSL_FieldCircularArc} SSL_FieldCircularArc
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_FieldCircularArc.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SSL_FieldCircularArc();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.name = reader.string();
                    break;
                }
            case 2: {
                    message.center = $root.Vector2f.decode(reader, reader.uint32());
                    break;
                }
            case 3: {
                    message.radius = reader.float();
                    break;
                }
            case 4: {
                    message.a1 = reader.float();
                    break;
                }
            case 5: {
                    message.a2 = reader.float();
                    break;
                }
            case 6: {
                    message.thickness = reader.float();
                    break;
                }
            case 7: {
                    message.type = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("name"))
            throw $util.ProtocolError("missing required 'name'", { instance: message });
        if (!message.hasOwnProperty("center"))
            throw $util.ProtocolError("missing required 'center'", { instance: message });
        if (!message.hasOwnProperty("radius"))
            throw $util.ProtocolError("missing required 'radius'", { instance: message });
        if (!message.hasOwnProperty("a1"))
            throw $util.ProtocolError("missing required 'a1'", { instance: message });
        if (!message.hasOwnProperty("a2"))
            throw $util.ProtocolError("missing required 'a2'", { instance: message });
        if (!message.hasOwnProperty("thickness"))
            throw $util.ProtocolError("missing required 'thickness'", { instance: message });
        return message;
    };

    /**
     * Decodes a SSL_FieldCircularArc message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SSL_FieldCircularArc
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SSL_FieldCircularArc} SSL_FieldCircularArc
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_FieldCircularArc.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SSL_FieldCircularArc message.
     * @function verify
     * @memberof SSL_FieldCircularArc
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SSL_FieldCircularArc.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isString(message.name))
            return "name: string expected";
        {
            let error = $root.Vector2f.verify(message.center);
            if (error)
                return "center." + error;
        }
        if (typeof message.radius !== "number")
            return "radius: number expected";
        if (typeof message.a1 !== "number")
            return "a1: number expected";
        if (typeof message.a2 !== "number")
            return "a2: number expected";
        if (typeof message.thickness !== "number")
            return "thickness: number expected";
        if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
            default:
                return "type: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
                break;
            }
        return null;
    };

    /**
     * Creates a SSL_FieldCircularArc message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SSL_FieldCircularArc
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SSL_FieldCircularArc} SSL_FieldCircularArc
     */
    SSL_FieldCircularArc.fromObject = function fromObject(object) {
        if (object instanceof $root.SSL_FieldCircularArc)
            return object;
        let message = new $root.SSL_FieldCircularArc();
        if (object.name != null)
            message.name = String(object.name);
        if (object.center != null) {
            if (typeof object.center !== "object")
                throw TypeError(".SSL_FieldCircularArc.center: object expected");
            message.center = $root.Vector2f.fromObject(object.center);
        }
        if (object.radius != null)
            message.radius = Number(object.radius);
        if (object.a1 != null)
            message.a1 = Number(object.a1);
        if (object.a2 != null)
            message.a2 = Number(object.a2);
        if (object.thickness != null)
            message.thickness = Number(object.thickness);
        switch (object.type) {
        default:
            if (typeof object.type === "number") {
                message.type = object.type;
                break;
            }
            break;
        case "Undefined":
        case 0:
            message.type = 0;
            break;
        case "CenterCircle":
        case 1:
            message.type = 1;
            break;
        case "TopTouchLine":
        case 2:
            message.type = 2;
            break;
        case "BottomTouchLine":
        case 3:
            message.type = 3;
            break;
        case "LeftGoalLine":
        case 4:
            message.type = 4;
            break;
        case "RightGoalLine":
        case 5:
            message.type = 5;
            break;
        case "HalfwayLine":
        case 6:
            message.type = 6;
            break;
        case "CenterLine":
        case 7:
            message.type = 7;
            break;
        case "LeftPenaltyStretch":
        case 8:
            message.type = 8;
            break;
        case "RightPenaltyStretch":
        case 9:
            message.type = 9;
            break;
        case "LeftFieldLeftPenaltyStretch":
        case 10:
            message.type = 10;
            break;
        case "LeftFieldRightPenaltyStretch":
        case 11:
            message.type = 11;
            break;
        case "RightFieldLeftPenaltyStretch":
        case 12:
            message.type = 12;
            break;
        case "RightFieldRightPenaltyStretch":
        case 13:
            message.type = 13;
            break;
        }
        return message;
    };

    /**
     * Creates a plain object from a SSL_FieldCircularArc message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SSL_FieldCircularArc
     * @static
     * @param {SSL_FieldCircularArc} message SSL_FieldCircularArc
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SSL_FieldCircularArc.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.name = "";
            object.center = null;
            object.radius = 0;
            object.a1 = 0;
            object.a2 = 0;
            object.thickness = 0;
            object.type = options.enums === String ? "Undefined" : 0;
        }
        if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
        if (message.center != null && message.hasOwnProperty("center"))
            object.center = $root.Vector2f.toObject(message.center, options);
        if (message.radius != null && message.hasOwnProperty("radius"))
            object.radius = options.json && !isFinite(message.radius) ? String(message.radius) : message.radius;
        if (message.a1 != null && message.hasOwnProperty("a1"))
            object.a1 = options.json && !isFinite(message.a1) ? String(message.a1) : message.a1;
        if (message.a2 != null && message.hasOwnProperty("a2"))
            object.a2 = options.json && !isFinite(message.a2) ? String(message.a2) : message.a2;
        if (message.thickness != null && message.hasOwnProperty("thickness"))
            object.thickness = options.json && !isFinite(message.thickness) ? String(message.thickness) : message.thickness;
        if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.SSL_FieldShapeType[message.type] === undefined ? message.type : $root.SSL_FieldShapeType[message.type] : message.type;
        return object;
    };

    /**
     * Converts this SSL_FieldCircularArc to JSON.
     * @function toJSON
     * @memberof SSL_FieldCircularArc
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SSL_FieldCircularArc.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SSL_FieldCircularArc
     * @function getTypeUrl
     * @memberof SSL_FieldCircularArc
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SSL_FieldCircularArc.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SSL_FieldCircularArc";
    };

    return SSL_FieldCircularArc;
})();

export const SSL_GeometryFieldSize = $root.SSL_GeometryFieldSize = (() => {

    /**
     * Properties of a SSL_GeometryFieldSize.
     * @exports ISSL_GeometryFieldSize
     * @interface ISSL_GeometryFieldSize
     * @property {number} fieldLength SSL_GeometryFieldSize fieldLength
     * @property {number} fieldWidth SSL_GeometryFieldSize fieldWidth
     * @property {number} goalWidth SSL_GeometryFieldSize goalWidth
     * @property {number} goalDepth SSL_GeometryFieldSize goalDepth
     * @property {number} boundaryWidth SSL_GeometryFieldSize boundaryWidth
     * @property {Array.<ISSL_FieldLineSegment>|null} [fieldLines] SSL_GeometryFieldSize fieldLines
     * @property {Array.<ISSL_FieldCircularArc>|null} [fieldArcs] SSL_GeometryFieldSize fieldArcs
     * @property {number|null} [penaltyAreaDepth] SSL_GeometryFieldSize penaltyAreaDepth
     * @property {number|null} [penaltyAreaWidth] SSL_GeometryFieldSize penaltyAreaWidth
     */

    /**
     * Constructs a new SSL_GeometryFieldSize.
     * @exports SSL_GeometryFieldSize
     * @classdesc Represents a SSL_GeometryFieldSize.
     * @implements ISSL_GeometryFieldSize
     * @constructor
     * @param {ISSL_GeometryFieldSize=} [properties] Properties to set
     */
    function SSL_GeometryFieldSize(properties) {
        this.fieldLines = [];
        this.fieldArcs = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SSL_GeometryFieldSize fieldLength.
     * @member {number} fieldLength
     * @memberof SSL_GeometryFieldSize
     * @instance
     */
    SSL_GeometryFieldSize.prototype.fieldLength = 0;

    /**
     * SSL_GeometryFieldSize fieldWidth.
     * @member {number} fieldWidth
     * @memberof SSL_GeometryFieldSize
     * @instance
     */
    SSL_GeometryFieldSize.prototype.fieldWidth = 0;

    /**
     * SSL_GeometryFieldSize goalWidth.
     * @member {number} goalWidth
     * @memberof SSL_GeometryFieldSize
     * @instance
     */
    SSL_GeometryFieldSize.prototype.goalWidth = 0;

    /**
     * SSL_GeometryFieldSize goalDepth.
     * @member {number} goalDepth
     * @memberof SSL_GeometryFieldSize
     * @instance
     */
    SSL_GeometryFieldSize.prototype.goalDepth = 0;

    /**
     * SSL_GeometryFieldSize boundaryWidth.
     * @member {number} boundaryWidth
     * @memberof SSL_GeometryFieldSize
     * @instance
     */
    SSL_GeometryFieldSize.prototype.boundaryWidth = 0;

    /**
     * SSL_GeometryFieldSize fieldLines.
     * @member {Array.<ISSL_FieldLineSegment>} fieldLines
     * @memberof SSL_GeometryFieldSize
     * @instance
     */
    SSL_GeometryFieldSize.prototype.fieldLines = $util.emptyArray;

    /**
     * SSL_GeometryFieldSize fieldArcs.
     * @member {Array.<ISSL_FieldCircularArc>} fieldArcs
     * @memberof SSL_GeometryFieldSize
     * @instance
     */
    SSL_GeometryFieldSize.prototype.fieldArcs = $util.emptyArray;

    /**
     * SSL_GeometryFieldSize penaltyAreaDepth.
     * @member {number} penaltyAreaDepth
     * @memberof SSL_GeometryFieldSize
     * @instance
     */
    SSL_GeometryFieldSize.prototype.penaltyAreaDepth = 0;

    /**
     * SSL_GeometryFieldSize penaltyAreaWidth.
     * @member {number} penaltyAreaWidth
     * @memberof SSL_GeometryFieldSize
     * @instance
     */
    SSL_GeometryFieldSize.prototype.penaltyAreaWidth = 0;

    /**
     * Creates a new SSL_GeometryFieldSize instance using the specified properties.
     * @function create
     * @memberof SSL_GeometryFieldSize
     * @static
     * @param {ISSL_GeometryFieldSize=} [properties] Properties to set
     * @returns {SSL_GeometryFieldSize} SSL_GeometryFieldSize instance
     */
    SSL_GeometryFieldSize.create = function create(properties) {
        return new SSL_GeometryFieldSize(properties);
    };

    /**
     * Encodes the specified SSL_GeometryFieldSize message. Does not implicitly {@link SSL_GeometryFieldSize.verify|verify} messages.
     * @function encode
     * @memberof SSL_GeometryFieldSize
     * @static
     * @param {ISSL_GeometryFieldSize} message SSL_GeometryFieldSize message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_GeometryFieldSize.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fieldLength);
        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.fieldWidth);
        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.goalWidth);
        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.goalDepth);
        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.boundaryWidth);
        if (message.fieldLines != null && message.fieldLines.length)
            for (let i = 0; i < message.fieldLines.length; ++i)
                $root.SSL_FieldLineSegment.encode(message.fieldLines[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.fieldArcs != null && message.fieldArcs.length)
            for (let i = 0; i < message.fieldArcs.length; ++i)
                $root.SSL_FieldCircularArc.encode(message.fieldArcs[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        if (message.penaltyAreaDepth != null && Object.hasOwnProperty.call(message, "penaltyAreaDepth"))
            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.penaltyAreaDepth);
        if (message.penaltyAreaWidth != null && Object.hasOwnProperty.call(message, "penaltyAreaWidth"))
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.penaltyAreaWidth);
        return writer;
    };

    /**
     * Encodes the specified SSL_GeometryFieldSize message, length delimited. Does not implicitly {@link SSL_GeometryFieldSize.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SSL_GeometryFieldSize
     * @static
     * @param {ISSL_GeometryFieldSize} message SSL_GeometryFieldSize message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_GeometryFieldSize.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SSL_GeometryFieldSize message from the specified reader or buffer.
     * @function decode
     * @memberof SSL_GeometryFieldSize
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SSL_GeometryFieldSize} SSL_GeometryFieldSize
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_GeometryFieldSize.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SSL_GeometryFieldSize();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.fieldLength = reader.int32();
                    break;
                }
            case 2: {
                    message.fieldWidth = reader.int32();
                    break;
                }
            case 3: {
                    message.goalWidth = reader.int32();
                    break;
                }
            case 4: {
                    message.goalDepth = reader.int32();
                    break;
                }
            case 5: {
                    message.boundaryWidth = reader.int32();
                    break;
                }
            case 6: {
                    if (!(message.fieldLines && message.fieldLines.length))
                        message.fieldLines = [];
                    message.fieldLines.push($root.SSL_FieldLineSegment.decode(reader, reader.uint32()));
                    break;
                }
            case 7: {
                    if (!(message.fieldArcs && message.fieldArcs.length))
                        message.fieldArcs = [];
                    message.fieldArcs.push($root.SSL_FieldCircularArc.decode(reader, reader.uint32()));
                    break;
                }
            case 8: {
                    message.penaltyAreaDepth = reader.int32();
                    break;
                }
            case 9: {
                    message.penaltyAreaWidth = reader.int32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("fieldLength"))
            throw $util.ProtocolError("missing required 'fieldLength'", { instance: message });
        if (!message.hasOwnProperty("fieldWidth"))
            throw $util.ProtocolError("missing required 'fieldWidth'", { instance: message });
        if (!message.hasOwnProperty("goalWidth"))
            throw $util.ProtocolError("missing required 'goalWidth'", { instance: message });
        if (!message.hasOwnProperty("goalDepth"))
            throw $util.ProtocolError("missing required 'goalDepth'", { instance: message });
        if (!message.hasOwnProperty("boundaryWidth"))
            throw $util.ProtocolError("missing required 'boundaryWidth'", { instance: message });
        return message;
    };

    /**
     * Decodes a SSL_GeometryFieldSize message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SSL_GeometryFieldSize
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SSL_GeometryFieldSize} SSL_GeometryFieldSize
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_GeometryFieldSize.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SSL_GeometryFieldSize message.
     * @function verify
     * @memberof SSL_GeometryFieldSize
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SSL_GeometryFieldSize.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.fieldLength))
            return "fieldLength: integer expected";
        if (!$util.isInteger(message.fieldWidth))
            return "fieldWidth: integer expected";
        if (!$util.isInteger(message.goalWidth))
            return "goalWidth: integer expected";
        if (!$util.isInteger(message.goalDepth))
            return "goalDepth: integer expected";
        if (!$util.isInteger(message.boundaryWidth))
            return "boundaryWidth: integer expected";
        if (message.fieldLines != null && message.hasOwnProperty("fieldLines")) {
            if (!Array.isArray(message.fieldLines))
                return "fieldLines: array expected";
            for (let i = 0; i < message.fieldLines.length; ++i) {
                let error = $root.SSL_FieldLineSegment.verify(message.fieldLines[i]);
                if (error)
                    return "fieldLines." + error;
            }
        }
        if (message.fieldArcs != null && message.hasOwnProperty("fieldArcs")) {
            if (!Array.isArray(message.fieldArcs))
                return "fieldArcs: array expected";
            for (let i = 0; i < message.fieldArcs.length; ++i) {
                let error = $root.SSL_FieldCircularArc.verify(message.fieldArcs[i]);
                if (error)
                    return "fieldArcs." + error;
            }
        }
        if (message.penaltyAreaDepth != null && message.hasOwnProperty("penaltyAreaDepth"))
            if (!$util.isInteger(message.penaltyAreaDepth))
                return "penaltyAreaDepth: integer expected";
        if (message.penaltyAreaWidth != null && message.hasOwnProperty("penaltyAreaWidth"))
            if (!$util.isInteger(message.penaltyAreaWidth))
                return "penaltyAreaWidth: integer expected";
        return null;
    };

    /**
     * Creates a SSL_GeometryFieldSize message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SSL_GeometryFieldSize
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SSL_GeometryFieldSize} SSL_GeometryFieldSize
     */
    SSL_GeometryFieldSize.fromObject = function fromObject(object) {
        if (object instanceof $root.SSL_GeometryFieldSize)
            return object;
        let message = new $root.SSL_GeometryFieldSize();
        if (object.fieldLength != null)
            message.fieldLength = object.fieldLength | 0;
        if (object.fieldWidth != null)
            message.fieldWidth = object.fieldWidth | 0;
        if (object.goalWidth != null)
            message.goalWidth = object.goalWidth | 0;
        if (object.goalDepth != null)
            message.goalDepth = object.goalDepth | 0;
        if (object.boundaryWidth != null)
            message.boundaryWidth = object.boundaryWidth | 0;
        if (object.fieldLines) {
            if (!Array.isArray(object.fieldLines))
                throw TypeError(".SSL_GeometryFieldSize.fieldLines: array expected");
            message.fieldLines = [];
            for (let i = 0; i < object.fieldLines.length; ++i) {
                if (typeof object.fieldLines[i] !== "object")
                    throw TypeError(".SSL_GeometryFieldSize.fieldLines: object expected");
                message.fieldLines[i] = $root.SSL_FieldLineSegment.fromObject(object.fieldLines[i]);
            }
        }
        if (object.fieldArcs) {
            if (!Array.isArray(object.fieldArcs))
                throw TypeError(".SSL_GeometryFieldSize.fieldArcs: array expected");
            message.fieldArcs = [];
            for (let i = 0; i < object.fieldArcs.length; ++i) {
                if (typeof object.fieldArcs[i] !== "object")
                    throw TypeError(".SSL_GeometryFieldSize.fieldArcs: object expected");
                message.fieldArcs[i] = $root.SSL_FieldCircularArc.fromObject(object.fieldArcs[i]);
            }
        }
        if (object.penaltyAreaDepth != null)
            message.penaltyAreaDepth = object.penaltyAreaDepth | 0;
        if (object.penaltyAreaWidth != null)
            message.penaltyAreaWidth = object.penaltyAreaWidth | 0;
        return message;
    };

    /**
     * Creates a plain object from a SSL_GeometryFieldSize message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SSL_GeometryFieldSize
     * @static
     * @param {SSL_GeometryFieldSize} message SSL_GeometryFieldSize
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SSL_GeometryFieldSize.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.fieldLines = [];
            object.fieldArcs = [];
        }
        if (options.defaults) {
            object.fieldLength = 0;
            object.fieldWidth = 0;
            object.goalWidth = 0;
            object.goalDepth = 0;
            object.boundaryWidth = 0;
            object.penaltyAreaDepth = 0;
            object.penaltyAreaWidth = 0;
        }
        if (message.fieldLength != null && message.hasOwnProperty("fieldLength"))
            object.fieldLength = message.fieldLength;
        if (message.fieldWidth != null && message.hasOwnProperty("fieldWidth"))
            object.fieldWidth = message.fieldWidth;
        if (message.goalWidth != null && message.hasOwnProperty("goalWidth"))
            object.goalWidth = message.goalWidth;
        if (message.goalDepth != null && message.hasOwnProperty("goalDepth"))
            object.goalDepth = message.goalDepth;
        if (message.boundaryWidth != null && message.hasOwnProperty("boundaryWidth"))
            object.boundaryWidth = message.boundaryWidth;
        if (message.fieldLines && message.fieldLines.length) {
            object.fieldLines = [];
            for (let j = 0; j < message.fieldLines.length; ++j)
                object.fieldLines[j] = $root.SSL_FieldLineSegment.toObject(message.fieldLines[j], options);
        }
        if (message.fieldArcs && message.fieldArcs.length) {
            object.fieldArcs = [];
            for (let j = 0; j < message.fieldArcs.length; ++j)
                object.fieldArcs[j] = $root.SSL_FieldCircularArc.toObject(message.fieldArcs[j], options);
        }
        if (message.penaltyAreaDepth != null && message.hasOwnProperty("penaltyAreaDepth"))
            object.penaltyAreaDepth = message.penaltyAreaDepth;
        if (message.penaltyAreaWidth != null && message.hasOwnProperty("penaltyAreaWidth"))
            object.penaltyAreaWidth = message.penaltyAreaWidth;
        return object;
    };

    /**
     * Converts this SSL_GeometryFieldSize to JSON.
     * @function toJSON
     * @memberof SSL_GeometryFieldSize
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SSL_GeometryFieldSize.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SSL_GeometryFieldSize
     * @function getTypeUrl
     * @memberof SSL_GeometryFieldSize
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SSL_GeometryFieldSize.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SSL_GeometryFieldSize";
    };

    return SSL_GeometryFieldSize;
})();

export const SSL_GeometryCameraCalibration = $root.SSL_GeometryCameraCalibration = (() => {

    /**
     * Properties of a SSL_GeometryCameraCalibration.
     * @exports ISSL_GeometryCameraCalibration
     * @interface ISSL_GeometryCameraCalibration
     * @property {number} cameraId SSL_GeometryCameraCalibration cameraId
     * @property {number} focalLength SSL_GeometryCameraCalibration focalLength
     * @property {number} principalPointX SSL_GeometryCameraCalibration principalPointX
     * @property {number} principalPointY SSL_GeometryCameraCalibration principalPointY
     * @property {number} distortion SSL_GeometryCameraCalibration distortion
     * @property {number} q0 SSL_GeometryCameraCalibration q0
     * @property {number} q1 SSL_GeometryCameraCalibration q1
     * @property {number} q2 SSL_GeometryCameraCalibration q2
     * @property {number} q3 SSL_GeometryCameraCalibration q3
     * @property {number} tx SSL_GeometryCameraCalibration tx
     * @property {number} ty SSL_GeometryCameraCalibration ty
     * @property {number} tz SSL_GeometryCameraCalibration tz
     * @property {number|null} [derivedCameraWorldTx] SSL_GeometryCameraCalibration derivedCameraWorldTx
     * @property {number|null} [derivedCameraWorldTy] SSL_GeometryCameraCalibration derivedCameraWorldTy
     * @property {number|null} [derivedCameraWorldTz] SSL_GeometryCameraCalibration derivedCameraWorldTz
     * @property {number|null} [pixelImageWidth] SSL_GeometryCameraCalibration pixelImageWidth
     * @property {number|null} [pixelImageHeight] SSL_GeometryCameraCalibration pixelImageHeight
     */

    /**
     * Constructs a new SSL_GeometryCameraCalibration.
     * @exports SSL_GeometryCameraCalibration
     * @classdesc Represents a SSL_GeometryCameraCalibration.
     * @implements ISSL_GeometryCameraCalibration
     * @constructor
     * @param {ISSL_GeometryCameraCalibration=} [properties] Properties to set
     */
    function SSL_GeometryCameraCalibration(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SSL_GeometryCameraCalibration cameraId.
     * @member {number} cameraId
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.cameraId = 0;

    /**
     * SSL_GeometryCameraCalibration focalLength.
     * @member {number} focalLength
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.focalLength = 0;

    /**
     * SSL_GeometryCameraCalibration principalPointX.
     * @member {number} principalPointX
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.principalPointX = 0;

    /**
     * SSL_GeometryCameraCalibration principalPointY.
     * @member {number} principalPointY
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.principalPointY = 0;

    /**
     * SSL_GeometryCameraCalibration distortion.
     * @member {number} distortion
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.distortion = 0;

    /**
     * SSL_GeometryCameraCalibration q0.
     * @member {number} q0
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.q0 = 0;

    /**
     * SSL_GeometryCameraCalibration q1.
     * @member {number} q1
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.q1 = 0;

    /**
     * SSL_GeometryCameraCalibration q2.
     * @member {number} q2
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.q2 = 0;

    /**
     * SSL_GeometryCameraCalibration q3.
     * @member {number} q3
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.q3 = 0;

    /**
     * SSL_GeometryCameraCalibration tx.
     * @member {number} tx
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.tx = 0;

    /**
     * SSL_GeometryCameraCalibration ty.
     * @member {number} ty
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.ty = 0;

    /**
     * SSL_GeometryCameraCalibration tz.
     * @member {number} tz
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.tz = 0;

    /**
     * SSL_GeometryCameraCalibration derivedCameraWorldTx.
     * @member {number} derivedCameraWorldTx
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.derivedCameraWorldTx = 0;

    /**
     * SSL_GeometryCameraCalibration derivedCameraWorldTy.
     * @member {number} derivedCameraWorldTy
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.derivedCameraWorldTy = 0;

    /**
     * SSL_GeometryCameraCalibration derivedCameraWorldTz.
     * @member {number} derivedCameraWorldTz
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.derivedCameraWorldTz = 0;

    /**
     * SSL_GeometryCameraCalibration pixelImageWidth.
     * @member {number} pixelImageWidth
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.pixelImageWidth = 0;

    /**
     * SSL_GeometryCameraCalibration pixelImageHeight.
     * @member {number} pixelImageHeight
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     */
    SSL_GeometryCameraCalibration.prototype.pixelImageHeight = 0;

    /**
     * Creates a new SSL_GeometryCameraCalibration instance using the specified properties.
     * @function create
     * @memberof SSL_GeometryCameraCalibration
     * @static
     * @param {ISSL_GeometryCameraCalibration=} [properties] Properties to set
     * @returns {SSL_GeometryCameraCalibration} SSL_GeometryCameraCalibration instance
     */
    SSL_GeometryCameraCalibration.create = function create(properties) {
        return new SSL_GeometryCameraCalibration(properties);
    };

    /**
     * Encodes the specified SSL_GeometryCameraCalibration message. Does not implicitly {@link SSL_GeometryCameraCalibration.verify|verify} messages.
     * @function encode
     * @memberof SSL_GeometryCameraCalibration
     * @static
     * @param {ISSL_GeometryCameraCalibration} message SSL_GeometryCameraCalibration message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_GeometryCameraCalibration.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.cameraId);
        writer.uint32(/* id 2, wireType 5 =*/21).float(message.focalLength);
        writer.uint32(/* id 3, wireType 5 =*/29).float(message.principalPointX);
        writer.uint32(/* id 4, wireType 5 =*/37).float(message.principalPointY);
        writer.uint32(/* id 5, wireType 5 =*/45).float(message.distortion);
        writer.uint32(/* id 6, wireType 5 =*/53).float(message.q0);
        writer.uint32(/* id 7, wireType 5 =*/61).float(message.q1);
        writer.uint32(/* id 8, wireType 5 =*/69).float(message.q2);
        writer.uint32(/* id 9, wireType 5 =*/77).float(message.q3);
        writer.uint32(/* id 10, wireType 5 =*/85).float(message.tx);
        writer.uint32(/* id 11, wireType 5 =*/93).float(message.ty);
        writer.uint32(/* id 12, wireType 5 =*/101).float(message.tz);
        if (message.derivedCameraWorldTx != null && Object.hasOwnProperty.call(message, "derivedCameraWorldTx"))
            writer.uint32(/* id 13, wireType 5 =*/109).float(message.derivedCameraWorldTx);
        if (message.derivedCameraWorldTy != null && Object.hasOwnProperty.call(message, "derivedCameraWorldTy"))
            writer.uint32(/* id 14, wireType 5 =*/117).float(message.derivedCameraWorldTy);
        if (message.derivedCameraWorldTz != null && Object.hasOwnProperty.call(message, "derivedCameraWorldTz"))
            writer.uint32(/* id 15, wireType 5 =*/125).float(message.derivedCameraWorldTz);
        if (message.pixelImageWidth != null && Object.hasOwnProperty.call(message, "pixelImageWidth"))
            writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.pixelImageWidth);
        if (message.pixelImageHeight != null && Object.hasOwnProperty.call(message, "pixelImageHeight"))
            writer.uint32(/* id 17, wireType 0 =*/136).uint32(message.pixelImageHeight);
        return writer;
    };

    /**
     * Encodes the specified SSL_GeometryCameraCalibration message, length delimited. Does not implicitly {@link SSL_GeometryCameraCalibration.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SSL_GeometryCameraCalibration
     * @static
     * @param {ISSL_GeometryCameraCalibration} message SSL_GeometryCameraCalibration message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_GeometryCameraCalibration.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SSL_GeometryCameraCalibration message from the specified reader or buffer.
     * @function decode
     * @memberof SSL_GeometryCameraCalibration
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SSL_GeometryCameraCalibration} SSL_GeometryCameraCalibration
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_GeometryCameraCalibration.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SSL_GeometryCameraCalibration();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.cameraId = reader.uint32();
                    break;
                }
            case 2: {
                    message.focalLength = reader.float();
                    break;
                }
            case 3: {
                    message.principalPointX = reader.float();
                    break;
                }
            case 4: {
                    message.principalPointY = reader.float();
                    break;
                }
            case 5: {
                    message.distortion = reader.float();
                    break;
                }
            case 6: {
                    message.q0 = reader.float();
                    break;
                }
            case 7: {
                    message.q1 = reader.float();
                    break;
                }
            case 8: {
                    message.q2 = reader.float();
                    break;
                }
            case 9: {
                    message.q3 = reader.float();
                    break;
                }
            case 10: {
                    message.tx = reader.float();
                    break;
                }
            case 11: {
                    message.ty = reader.float();
                    break;
                }
            case 12: {
                    message.tz = reader.float();
                    break;
                }
            case 13: {
                    message.derivedCameraWorldTx = reader.float();
                    break;
                }
            case 14: {
                    message.derivedCameraWorldTy = reader.float();
                    break;
                }
            case 15: {
                    message.derivedCameraWorldTz = reader.float();
                    break;
                }
            case 16: {
                    message.pixelImageWidth = reader.uint32();
                    break;
                }
            case 17: {
                    message.pixelImageHeight = reader.uint32();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("cameraId"))
            throw $util.ProtocolError("missing required 'cameraId'", { instance: message });
        if (!message.hasOwnProperty("focalLength"))
            throw $util.ProtocolError("missing required 'focalLength'", { instance: message });
        if (!message.hasOwnProperty("principalPointX"))
            throw $util.ProtocolError("missing required 'principalPointX'", { instance: message });
        if (!message.hasOwnProperty("principalPointY"))
            throw $util.ProtocolError("missing required 'principalPointY'", { instance: message });
        if (!message.hasOwnProperty("distortion"))
            throw $util.ProtocolError("missing required 'distortion'", { instance: message });
        if (!message.hasOwnProperty("q0"))
            throw $util.ProtocolError("missing required 'q0'", { instance: message });
        if (!message.hasOwnProperty("q1"))
            throw $util.ProtocolError("missing required 'q1'", { instance: message });
        if (!message.hasOwnProperty("q2"))
            throw $util.ProtocolError("missing required 'q2'", { instance: message });
        if (!message.hasOwnProperty("q3"))
            throw $util.ProtocolError("missing required 'q3'", { instance: message });
        if (!message.hasOwnProperty("tx"))
            throw $util.ProtocolError("missing required 'tx'", { instance: message });
        if (!message.hasOwnProperty("ty"))
            throw $util.ProtocolError("missing required 'ty'", { instance: message });
        if (!message.hasOwnProperty("tz"))
            throw $util.ProtocolError("missing required 'tz'", { instance: message });
        return message;
    };

    /**
     * Decodes a SSL_GeometryCameraCalibration message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SSL_GeometryCameraCalibration
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SSL_GeometryCameraCalibration} SSL_GeometryCameraCalibration
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_GeometryCameraCalibration.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SSL_GeometryCameraCalibration message.
     * @function verify
     * @memberof SSL_GeometryCameraCalibration
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SSL_GeometryCameraCalibration.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.cameraId))
            return "cameraId: integer expected";
        if (typeof message.focalLength !== "number")
            return "focalLength: number expected";
        if (typeof message.principalPointX !== "number")
            return "principalPointX: number expected";
        if (typeof message.principalPointY !== "number")
            return "principalPointY: number expected";
        if (typeof message.distortion !== "number")
            return "distortion: number expected";
        if (typeof message.q0 !== "number")
            return "q0: number expected";
        if (typeof message.q1 !== "number")
            return "q1: number expected";
        if (typeof message.q2 !== "number")
            return "q2: number expected";
        if (typeof message.q3 !== "number")
            return "q3: number expected";
        if (typeof message.tx !== "number")
            return "tx: number expected";
        if (typeof message.ty !== "number")
            return "ty: number expected";
        if (typeof message.tz !== "number")
            return "tz: number expected";
        if (message.derivedCameraWorldTx != null && message.hasOwnProperty("derivedCameraWorldTx"))
            if (typeof message.derivedCameraWorldTx !== "number")
                return "derivedCameraWorldTx: number expected";
        if (message.derivedCameraWorldTy != null && message.hasOwnProperty("derivedCameraWorldTy"))
            if (typeof message.derivedCameraWorldTy !== "number")
                return "derivedCameraWorldTy: number expected";
        if (message.derivedCameraWorldTz != null && message.hasOwnProperty("derivedCameraWorldTz"))
            if (typeof message.derivedCameraWorldTz !== "number")
                return "derivedCameraWorldTz: number expected";
        if (message.pixelImageWidth != null && message.hasOwnProperty("pixelImageWidth"))
            if (!$util.isInteger(message.pixelImageWidth))
                return "pixelImageWidth: integer expected";
        if (message.pixelImageHeight != null && message.hasOwnProperty("pixelImageHeight"))
            if (!$util.isInteger(message.pixelImageHeight))
                return "pixelImageHeight: integer expected";
        return null;
    };

    /**
     * Creates a SSL_GeometryCameraCalibration message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SSL_GeometryCameraCalibration
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SSL_GeometryCameraCalibration} SSL_GeometryCameraCalibration
     */
    SSL_GeometryCameraCalibration.fromObject = function fromObject(object) {
        if (object instanceof $root.SSL_GeometryCameraCalibration)
            return object;
        let message = new $root.SSL_GeometryCameraCalibration();
        if (object.cameraId != null)
            message.cameraId = object.cameraId >>> 0;
        if (object.focalLength != null)
            message.focalLength = Number(object.focalLength);
        if (object.principalPointX != null)
            message.principalPointX = Number(object.principalPointX);
        if (object.principalPointY != null)
            message.principalPointY = Number(object.principalPointY);
        if (object.distortion != null)
            message.distortion = Number(object.distortion);
        if (object.q0 != null)
            message.q0 = Number(object.q0);
        if (object.q1 != null)
            message.q1 = Number(object.q1);
        if (object.q2 != null)
            message.q2 = Number(object.q2);
        if (object.q3 != null)
            message.q3 = Number(object.q3);
        if (object.tx != null)
            message.tx = Number(object.tx);
        if (object.ty != null)
            message.ty = Number(object.ty);
        if (object.tz != null)
            message.tz = Number(object.tz);
        if (object.derivedCameraWorldTx != null)
            message.derivedCameraWorldTx = Number(object.derivedCameraWorldTx);
        if (object.derivedCameraWorldTy != null)
            message.derivedCameraWorldTy = Number(object.derivedCameraWorldTy);
        if (object.derivedCameraWorldTz != null)
            message.derivedCameraWorldTz = Number(object.derivedCameraWorldTz);
        if (object.pixelImageWidth != null)
            message.pixelImageWidth = object.pixelImageWidth >>> 0;
        if (object.pixelImageHeight != null)
            message.pixelImageHeight = object.pixelImageHeight >>> 0;
        return message;
    };

    /**
     * Creates a plain object from a SSL_GeometryCameraCalibration message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SSL_GeometryCameraCalibration
     * @static
     * @param {SSL_GeometryCameraCalibration} message SSL_GeometryCameraCalibration
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SSL_GeometryCameraCalibration.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.cameraId = 0;
            object.focalLength = 0;
            object.principalPointX = 0;
            object.principalPointY = 0;
            object.distortion = 0;
            object.q0 = 0;
            object.q1 = 0;
            object.q2 = 0;
            object.q3 = 0;
            object.tx = 0;
            object.ty = 0;
            object.tz = 0;
            object.derivedCameraWorldTx = 0;
            object.derivedCameraWorldTy = 0;
            object.derivedCameraWorldTz = 0;
            object.pixelImageWidth = 0;
            object.pixelImageHeight = 0;
        }
        if (message.cameraId != null && message.hasOwnProperty("cameraId"))
            object.cameraId = message.cameraId;
        if (message.focalLength != null && message.hasOwnProperty("focalLength"))
            object.focalLength = options.json && !isFinite(message.focalLength) ? String(message.focalLength) : message.focalLength;
        if (message.principalPointX != null && message.hasOwnProperty("principalPointX"))
            object.principalPointX = options.json && !isFinite(message.principalPointX) ? String(message.principalPointX) : message.principalPointX;
        if (message.principalPointY != null && message.hasOwnProperty("principalPointY"))
            object.principalPointY = options.json && !isFinite(message.principalPointY) ? String(message.principalPointY) : message.principalPointY;
        if (message.distortion != null && message.hasOwnProperty("distortion"))
            object.distortion = options.json && !isFinite(message.distortion) ? String(message.distortion) : message.distortion;
        if (message.q0 != null && message.hasOwnProperty("q0"))
            object.q0 = options.json && !isFinite(message.q0) ? String(message.q0) : message.q0;
        if (message.q1 != null && message.hasOwnProperty("q1"))
            object.q1 = options.json && !isFinite(message.q1) ? String(message.q1) : message.q1;
        if (message.q2 != null && message.hasOwnProperty("q2"))
            object.q2 = options.json && !isFinite(message.q2) ? String(message.q2) : message.q2;
        if (message.q3 != null && message.hasOwnProperty("q3"))
            object.q3 = options.json && !isFinite(message.q3) ? String(message.q3) : message.q3;
        if (message.tx != null && message.hasOwnProperty("tx"))
            object.tx = options.json && !isFinite(message.tx) ? String(message.tx) : message.tx;
        if (message.ty != null && message.hasOwnProperty("ty"))
            object.ty = options.json && !isFinite(message.ty) ? String(message.ty) : message.ty;
        if (message.tz != null && message.hasOwnProperty("tz"))
            object.tz = options.json && !isFinite(message.tz) ? String(message.tz) : message.tz;
        if (message.derivedCameraWorldTx != null && message.hasOwnProperty("derivedCameraWorldTx"))
            object.derivedCameraWorldTx = options.json && !isFinite(message.derivedCameraWorldTx) ? String(message.derivedCameraWorldTx) : message.derivedCameraWorldTx;
        if (message.derivedCameraWorldTy != null && message.hasOwnProperty("derivedCameraWorldTy"))
            object.derivedCameraWorldTy = options.json && !isFinite(message.derivedCameraWorldTy) ? String(message.derivedCameraWorldTy) : message.derivedCameraWorldTy;
        if (message.derivedCameraWorldTz != null && message.hasOwnProperty("derivedCameraWorldTz"))
            object.derivedCameraWorldTz = options.json && !isFinite(message.derivedCameraWorldTz) ? String(message.derivedCameraWorldTz) : message.derivedCameraWorldTz;
        if (message.pixelImageWidth != null && message.hasOwnProperty("pixelImageWidth"))
            object.pixelImageWidth = message.pixelImageWidth;
        if (message.pixelImageHeight != null && message.hasOwnProperty("pixelImageHeight"))
            object.pixelImageHeight = message.pixelImageHeight;
        return object;
    };

    /**
     * Converts this SSL_GeometryCameraCalibration to JSON.
     * @function toJSON
     * @memberof SSL_GeometryCameraCalibration
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SSL_GeometryCameraCalibration.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SSL_GeometryCameraCalibration
     * @function getTypeUrl
     * @memberof SSL_GeometryCameraCalibration
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SSL_GeometryCameraCalibration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SSL_GeometryCameraCalibration";
    };

    return SSL_GeometryCameraCalibration;
})();

export const SSL_BallModelStraightTwoPhase = $root.SSL_BallModelStraightTwoPhase = (() => {

    /**
     * Properties of a SSL_BallModelStraightTwoPhase.
     * @exports ISSL_BallModelStraightTwoPhase
     * @interface ISSL_BallModelStraightTwoPhase
     * @property {number} accSlide SSL_BallModelStraightTwoPhase accSlide
     * @property {number} accRoll SSL_BallModelStraightTwoPhase accRoll
     * @property {number} kSwitch SSL_BallModelStraightTwoPhase kSwitch
     */

    /**
     * Constructs a new SSL_BallModelStraightTwoPhase.
     * @exports SSL_BallModelStraightTwoPhase
     * @classdesc Represents a SSL_BallModelStraightTwoPhase.
     * @implements ISSL_BallModelStraightTwoPhase
     * @constructor
     * @param {ISSL_BallModelStraightTwoPhase=} [properties] Properties to set
     */
    function SSL_BallModelStraightTwoPhase(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SSL_BallModelStraightTwoPhase accSlide.
     * @member {number} accSlide
     * @memberof SSL_BallModelStraightTwoPhase
     * @instance
     */
    SSL_BallModelStraightTwoPhase.prototype.accSlide = 0;

    /**
     * SSL_BallModelStraightTwoPhase accRoll.
     * @member {number} accRoll
     * @memberof SSL_BallModelStraightTwoPhase
     * @instance
     */
    SSL_BallModelStraightTwoPhase.prototype.accRoll = 0;

    /**
     * SSL_BallModelStraightTwoPhase kSwitch.
     * @member {number} kSwitch
     * @memberof SSL_BallModelStraightTwoPhase
     * @instance
     */
    SSL_BallModelStraightTwoPhase.prototype.kSwitch = 0;

    /**
     * Creates a new SSL_BallModelStraightTwoPhase instance using the specified properties.
     * @function create
     * @memberof SSL_BallModelStraightTwoPhase
     * @static
     * @param {ISSL_BallModelStraightTwoPhase=} [properties] Properties to set
     * @returns {SSL_BallModelStraightTwoPhase} SSL_BallModelStraightTwoPhase instance
     */
    SSL_BallModelStraightTwoPhase.create = function create(properties) {
        return new SSL_BallModelStraightTwoPhase(properties);
    };

    /**
     * Encodes the specified SSL_BallModelStraightTwoPhase message. Does not implicitly {@link SSL_BallModelStraightTwoPhase.verify|verify} messages.
     * @function encode
     * @memberof SSL_BallModelStraightTwoPhase
     * @static
     * @param {ISSL_BallModelStraightTwoPhase} message SSL_BallModelStraightTwoPhase message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_BallModelStraightTwoPhase.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 1 =*/9).double(message.accSlide);
        writer.uint32(/* id 2, wireType 1 =*/17).double(message.accRoll);
        writer.uint32(/* id 3, wireType 1 =*/25).double(message.kSwitch);
        return writer;
    };

    /**
     * Encodes the specified SSL_BallModelStraightTwoPhase message, length delimited. Does not implicitly {@link SSL_BallModelStraightTwoPhase.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SSL_BallModelStraightTwoPhase
     * @static
     * @param {ISSL_BallModelStraightTwoPhase} message SSL_BallModelStraightTwoPhase message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_BallModelStraightTwoPhase.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SSL_BallModelStraightTwoPhase message from the specified reader or buffer.
     * @function decode
     * @memberof SSL_BallModelStraightTwoPhase
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SSL_BallModelStraightTwoPhase} SSL_BallModelStraightTwoPhase
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_BallModelStraightTwoPhase.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SSL_BallModelStraightTwoPhase();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.accSlide = reader.double();
                    break;
                }
            case 2: {
                    message.accRoll = reader.double();
                    break;
                }
            case 3: {
                    message.kSwitch = reader.double();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("accSlide"))
            throw $util.ProtocolError("missing required 'accSlide'", { instance: message });
        if (!message.hasOwnProperty("accRoll"))
            throw $util.ProtocolError("missing required 'accRoll'", { instance: message });
        if (!message.hasOwnProperty("kSwitch"))
            throw $util.ProtocolError("missing required 'kSwitch'", { instance: message });
        return message;
    };

    /**
     * Decodes a SSL_BallModelStraightTwoPhase message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SSL_BallModelStraightTwoPhase
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SSL_BallModelStraightTwoPhase} SSL_BallModelStraightTwoPhase
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_BallModelStraightTwoPhase.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SSL_BallModelStraightTwoPhase message.
     * @function verify
     * @memberof SSL_BallModelStraightTwoPhase
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SSL_BallModelStraightTwoPhase.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (typeof message.accSlide !== "number")
            return "accSlide: number expected";
        if (typeof message.accRoll !== "number")
            return "accRoll: number expected";
        if (typeof message.kSwitch !== "number")
            return "kSwitch: number expected";
        return null;
    };

    /**
     * Creates a SSL_BallModelStraightTwoPhase message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SSL_BallModelStraightTwoPhase
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SSL_BallModelStraightTwoPhase} SSL_BallModelStraightTwoPhase
     */
    SSL_BallModelStraightTwoPhase.fromObject = function fromObject(object) {
        if (object instanceof $root.SSL_BallModelStraightTwoPhase)
            return object;
        let message = new $root.SSL_BallModelStraightTwoPhase();
        if (object.accSlide != null)
            message.accSlide = Number(object.accSlide);
        if (object.accRoll != null)
            message.accRoll = Number(object.accRoll);
        if (object.kSwitch != null)
            message.kSwitch = Number(object.kSwitch);
        return message;
    };

    /**
     * Creates a plain object from a SSL_BallModelStraightTwoPhase message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SSL_BallModelStraightTwoPhase
     * @static
     * @param {SSL_BallModelStraightTwoPhase} message SSL_BallModelStraightTwoPhase
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SSL_BallModelStraightTwoPhase.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.accSlide = 0;
            object.accRoll = 0;
            object.kSwitch = 0;
        }
        if (message.accSlide != null && message.hasOwnProperty("accSlide"))
            object.accSlide = options.json && !isFinite(message.accSlide) ? String(message.accSlide) : message.accSlide;
        if (message.accRoll != null && message.hasOwnProperty("accRoll"))
            object.accRoll = options.json && !isFinite(message.accRoll) ? String(message.accRoll) : message.accRoll;
        if (message.kSwitch != null && message.hasOwnProperty("kSwitch"))
            object.kSwitch = options.json && !isFinite(message.kSwitch) ? String(message.kSwitch) : message.kSwitch;
        return object;
    };

    /**
     * Converts this SSL_BallModelStraightTwoPhase to JSON.
     * @function toJSON
     * @memberof SSL_BallModelStraightTwoPhase
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SSL_BallModelStraightTwoPhase.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SSL_BallModelStraightTwoPhase
     * @function getTypeUrl
     * @memberof SSL_BallModelStraightTwoPhase
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SSL_BallModelStraightTwoPhase.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SSL_BallModelStraightTwoPhase";
    };

    return SSL_BallModelStraightTwoPhase;
})();

export const SSL_BallModelChipFixedLoss = $root.SSL_BallModelChipFixedLoss = (() => {

    /**
     * Properties of a SSL_BallModelChipFixedLoss.
     * @exports ISSL_BallModelChipFixedLoss
     * @interface ISSL_BallModelChipFixedLoss
     * @property {number} dampingXyFirstHop SSL_BallModelChipFixedLoss dampingXyFirstHop
     * @property {number} dampingXyOtherHops SSL_BallModelChipFixedLoss dampingXyOtherHops
     * @property {number} dampingZ SSL_BallModelChipFixedLoss dampingZ
     */

    /**
     * Constructs a new SSL_BallModelChipFixedLoss.
     * @exports SSL_BallModelChipFixedLoss
     * @classdesc Represents a SSL_BallModelChipFixedLoss.
     * @implements ISSL_BallModelChipFixedLoss
     * @constructor
     * @param {ISSL_BallModelChipFixedLoss=} [properties] Properties to set
     */
    function SSL_BallModelChipFixedLoss(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SSL_BallModelChipFixedLoss dampingXyFirstHop.
     * @member {number} dampingXyFirstHop
     * @memberof SSL_BallModelChipFixedLoss
     * @instance
     */
    SSL_BallModelChipFixedLoss.prototype.dampingXyFirstHop = 0;

    /**
     * SSL_BallModelChipFixedLoss dampingXyOtherHops.
     * @member {number} dampingXyOtherHops
     * @memberof SSL_BallModelChipFixedLoss
     * @instance
     */
    SSL_BallModelChipFixedLoss.prototype.dampingXyOtherHops = 0;

    /**
     * SSL_BallModelChipFixedLoss dampingZ.
     * @member {number} dampingZ
     * @memberof SSL_BallModelChipFixedLoss
     * @instance
     */
    SSL_BallModelChipFixedLoss.prototype.dampingZ = 0;

    /**
     * Creates a new SSL_BallModelChipFixedLoss instance using the specified properties.
     * @function create
     * @memberof SSL_BallModelChipFixedLoss
     * @static
     * @param {ISSL_BallModelChipFixedLoss=} [properties] Properties to set
     * @returns {SSL_BallModelChipFixedLoss} SSL_BallModelChipFixedLoss instance
     */
    SSL_BallModelChipFixedLoss.create = function create(properties) {
        return new SSL_BallModelChipFixedLoss(properties);
    };

    /**
     * Encodes the specified SSL_BallModelChipFixedLoss message. Does not implicitly {@link SSL_BallModelChipFixedLoss.verify|verify} messages.
     * @function encode
     * @memberof SSL_BallModelChipFixedLoss
     * @static
     * @param {ISSL_BallModelChipFixedLoss} message SSL_BallModelChipFixedLoss message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_BallModelChipFixedLoss.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 1 =*/9).double(message.dampingXyFirstHop);
        writer.uint32(/* id 2, wireType 1 =*/17).double(message.dampingXyOtherHops);
        writer.uint32(/* id 3, wireType 1 =*/25).double(message.dampingZ);
        return writer;
    };

    /**
     * Encodes the specified SSL_BallModelChipFixedLoss message, length delimited. Does not implicitly {@link SSL_BallModelChipFixedLoss.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SSL_BallModelChipFixedLoss
     * @static
     * @param {ISSL_BallModelChipFixedLoss} message SSL_BallModelChipFixedLoss message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_BallModelChipFixedLoss.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SSL_BallModelChipFixedLoss message from the specified reader or buffer.
     * @function decode
     * @memberof SSL_BallModelChipFixedLoss
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SSL_BallModelChipFixedLoss} SSL_BallModelChipFixedLoss
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_BallModelChipFixedLoss.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SSL_BallModelChipFixedLoss();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.dampingXyFirstHop = reader.double();
                    break;
                }
            case 2: {
                    message.dampingXyOtherHops = reader.double();
                    break;
                }
            case 3: {
                    message.dampingZ = reader.double();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("dampingXyFirstHop"))
            throw $util.ProtocolError("missing required 'dampingXyFirstHop'", { instance: message });
        if (!message.hasOwnProperty("dampingXyOtherHops"))
            throw $util.ProtocolError("missing required 'dampingXyOtherHops'", { instance: message });
        if (!message.hasOwnProperty("dampingZ"))
            throw $util.ProtocolError("missing required 'dampingZ'", { instance: message });
        return message;
    };

    /**
     * Decodes a SSL_BallModelChipFixedLoss message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SSL_BallModelChipFixedLoss
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SSL_BallModelChipFixedLoss} SSL_BallModelChipFixedLoss
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_BallModelChipFixedLoss.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SSL_BallModelChipFixedLoss message.
     * @function verify
     * @memberof SSL_BallModelChipFixedLoss
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SSL_BallModelChipFixedLoss.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (typeof message.dampingXyFirstHop !== "number")
            return "dampingXyFirstHop: number expected";
        if (typeof message.dampingXyOtherHops !== "number")
            return "dampingXyOtherHops: number expected";
        if (typeof message.dampingZ !== "number")
            return "dampingZ: number expected";
        return null;
    };

    /**
     * Creates a SSL_BallModelChipFixedLoss message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SSL_BallModelChipFixedLoss
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SSL_BallModelChipFixedLoss} SSL_BallModelChipFixedLoss
     */
    SSL_BallModelChipFixedLoss.fromObject = function fromObject(object) {
        if (object instanceof $root.SSL_BallModelChipFixedLoss)
            return object;
        let message = new $root.SSL_BallModelChipFixedLoss();
        if (object.dampingXyFirstHop != null)
            message.dampingXyFirstHop = Number(object.dampingXyFirstHop);
        if (object.dampingXyOtherHops != null)
            message.dampingXyOtherHops = Number(object.dampingXyOtherHops);
        if (object.dampingZ != null)
            message.dampingZ = Number(object.dampingZ);
        return message;
    };

    /**
     * Creates a plain object from a SSL_BallModelChipFixedLoss message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SSL_BallModelChipFixedLoss
     * @static
     * @param {SSL_BallModelChipFixedLoss} message SSL_BallModelChipFixedLoss
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SSL_BallModelChipFixedLoss.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.dampingXyFirstHop = 0;
            object.dampingXyOtherHops = 0;
            object.dampingZ = 0;
        }
        if (message.dampingXyFirstHop != null && message.hasOwnProperty("dampingXyFirstHop"))
            object.dampingXyFirstHop = options.json && !isFinite(message.dampingXyFirstHop) ? String(message.dampingXyFirstHop) : message.dampingXyFirstHop;
        if (message.dampingXyOtherHops != null && message.hasOwnProperty("dampingXyOtherHops"))
            object.dampingXyOtherHops = options.json && !isFinite(message.dampingXyOtherHops) ? String(message.dampingXyOtherHops) : message.dampingXyOtherHops;
        if (message.dampingZ != null && message.hasOwnProperty("dampingZ"))
            object.dampingZ = options.json && !isFinite(message.dampingZ) ? String(message.dampingZ) : message.dampingZ;
        return object;
    };

    /**
     * Converts this SSL_BallModelChipFixedLoss to JSON.
     * @function toJSON
     * @memberof SSL_BallModelChipFixedLoss
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SSL_BallModelChipFixedLoss.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SSL_BallModelChipFixedLoss
     * @function getTypeUrl
     * @memberof SSL_BallModelChipFixedLoss
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SSL_BallModelChipFixedLoss.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SSL_BallModelChipFixedLoss";
    };

    return SSL_BallModelChipFixedLoss;
})();

export const SSL_GeometryModels = $root.SSL_GeometryModels = (() => {

    /**
     * Properties of a SSL_GeometryModels.
     * @exports ISSL_GeometryModels
     * @interface ISSL_GeometryModels
     * @property {ISSL_BallModelStraightTwoPhase|null} [straightTwoPhase] SSL_GeometryModels straightTwoPhase
     * @property {ISSL_BallModelChipFixedLoss|null} [chipFixedLoss] SSL_GeometryModels chipFixedLoss
     */

    /**
     * Constructs a new SSL_GeometryModels.
     * @exports SSL_GeometryModels
     * @classdesc Represents a SSL_GeometryModels.
     * @implements ISSL_GeometryModels
     * @constructor
     * @param {ISSL_GeometryModels=} [properties] Properties to set
     */
    function SSL_GeometryModels(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SSL_GeometryModels straightTwoPhase.
     * @member {ISSL_BallModelStraightTwoPhase|null|undefined} straightTwoPhase
     * @memberof SSL_GeometryModels
     * @instance
     */
    SSL_GeometryModels.prototype.straightTwoPhase = null;

    /**
     * SSL_GeometryModels chipFixedLoss.
     * @member {ISSL_BallModelChipFixedLoss|null|undefined} chipFixedLoss
     * @memberof SSL_GeometryModels
     * @instance
     */
    SSL_GeometryModels.prototype.chipFixedLoss = null;

    /**
     * Creates a new SSL_GeometryModels instance using the specified properties.
     * @function create
     * @memberof SSL_GeometryModels
     * @static
     * @param {ISSL_GeometryModels=} [properties] Properties to set
     * @returns {SSL_GeometryModels} SSL_GeometryModels instance
     */
    SSL_GeometryModels.create = function create(properties) {
        return new SSL_GeometryModels(properties);
    };

    /**
     * Encodes the specified SSL_GeometryModels message. Does not implicitly {@link SSL_GeometryModels.verify|verify} messages.
     * @function encode
     * @memberof SSL_GeometryModels
     * @static
     * @param {ISSL_GeometryModels} message SSL_GeometryModels message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_GeometryModels.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.straightTwoPhase != null && Object.hasOwnProperty.call(message, "straightTwoPhase"))
            $root.SSL_BallModelStraightTwoPhase.encode(message.straightTwoPhase, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.chipFixedLoss != null && Object.hasOwnProperty.call(message, "chipFixedLoss"))
            $root.SSL_BallModelChipFixedLoss.encode(message.chipFixedLoss, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SSL_GeometryModels message, length delimited. Does not implicitly {@link SSL_GeometryModels.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SSL_GeometryModels
     * @static
     * @param {ISSL_GeometryModels} message SSL_GeometryModels message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_GeometryModels.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SSL_GeometryModels message from the specified reader or buffer.
     * @function decode
     * @memberof SSL_GeometryModels
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SSL_GeometryModels} SSL_GeometryModels
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_GeometryModels.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SSL_GeometryModels();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.straightTwoPhase = $root.SSL_BallModelStraightTwoPhase.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.chipFixedLoss = $root.SSL_BallModelChipFixedLoss.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SSL_GeometryModels message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SSL_GeometryModels
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SSL_GeometryModels} SSL_GeometryModels
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_GeometryModels.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SSL_GeometryModels message.
     * @function verify
     * @memberof SSL_GeometryModels
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SSL_GeometryModels.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.straightTwoPhase != null && message.hasOwnProperty("straightTwoPhase")) {
            let error = $root.SSL_BallModelStraightTwoPhase.verify(message.straightTwoPhase);
            if (error)
                return "straightTwoPhase." + error;
        }
        if (message.chipFixedLoss != null && message.hasOwnProperty("chipFixedLoss")) {
            let error = $root.SSL_BallModelChipFixedLoss.verify(message.chipFixedLoss);
            if (error)
                return "chipFixedLoss." + error;
        }
        return null;
    };

    /**
     * Creates a SSL_GeometryModels message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SSL_GeometryModels
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SSL_GeometryModels} SSL_GeometryModels
     */
    SSL_GeometryModels.fromObject = function fromObject(object) {
        if (object instanceof $root.SSL_GeometryModels)
            return object;
        let message = new $root.SSL_GeometryModels();
        if (object.straightTwoPhase != null) {
            if (typeof object.straightTwoPhase !== "object")
                throw TypeError(".SSL_GeometryModels.straightTwoPhase: object expected");
            message.straightTwoPhase = $root.SSL_BallModelStraightTwoPhase.fromObject(object.straightTwoPhase);
        }
        if (object.chipFixedLoss != null) {
            if (typeof object.chipFixedLoss !== "object")
                throw TypeError(".SSL_GeometryModels.chipFixedLoss: object expected");
            message.chipFixedLoss = $root.SSL_BallModelChipFixedLoss.fromObject(object.chipFixedLoss);
        }
        return message;
    };

    /**
     * Creates a plain object from a SSL_GeometryModels message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SSL_GeometryModels
     * @static
     * @param {SSL_GeometryModels} message SSL_GeometryModels
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SSL_GeometryModels.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.straightTwoPhase = null;
            object.chipFixedLoss = null;
        }
        if (message.straightTwoPhase != null && message.hasOwnProperty("straightTwoPhase"))
            object.straightTwoPhase = $root.SSL_BallModelStraightTwoPhase.toObject(message.straightTwoPhase, options);
        if (message.chipFixedLoss != null && message.hasOwnProperty("chipFixedLoss"))
            object.chipFixedLoss = $root.SSL_BallModelChipFixedLoss.toObject(message.chipFixedLoss, options);
        return object;
    };

    /**
     * Converts this SSL_GeometryModels to JSON.
     * @function toJSON
     * @memberof SSL_GeometryModels
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SSL_GeometryModels.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SSL_GeometryModels
     * @function getTypeUrl
     * @memberof SSL_GeometryModels
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SSL_GeometryModels.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SSL_GeometryModels";
    };

    return SSL_GeometryModels;
})();

export const SSL_GeometryData = $root.SSL_GeometryData = (() => {

    /**
     * Properties of a SSL_GeometryData.
     * @exports ISSL_GeometryData
     * @interface ISSL_GeometryData
     * @property {ISSL_GeometryFieldSize} field SSL_GeometryData field
     * @property {Array.<ISSL_GeometryCameraCalibration>|null} [calib] SSL_GeometryData calib
     * @property {ISSL_GeometryModels|null} [models] SSL_GeometryData models
     */

    /**
     * Constructs a new SSL_GeometryData.
     * @exports SSL_GeometryData
     * @classdesc Represents a SSL_GeometryData.
     * @implements ISSL_GeometryData
     * @constructor
     * @param {ISSL_GeometryData=} [properties] Properties to set
     */
    function SSL_GeometryData(properties) {
        this.calib = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SSL_GeometryData field.
     * @member {ISSL_GeometryFieldSize} field
     * @memberof SSL_GeometryData
     * @instance
     */
    SSL_GeometryData.prototype.field = null;

    /**
     * SSL_GeometryData calib.
     * @member {Array.<ISSL_GeometryCameraCalibration>} calib
     * @memberof SSL_GeometryData
     * @instance
     */
    SSL_GeometryData.prototype.calib = $util.emptyArray;

    /**
     * SSL_GeometryData models.
     * @member {ISSL_GeometryModels|null|undefined} models
     * @memberof SSL_GeometryData
     * @instance
     */
    SSL_GeometryData.prototype.models = null;

    /**
     * Creates a new SSL_GeometryData instance using the specified properties.
     * @function create
     * @memberof SSL_GeometryData
     * @static
     * @param {ISSL_GeometryData=} [properties] Properties to set
     * @returns {SSL_GeometryData} SSL_GeometryData instance
     */
    SSL_GeometryData.create = function create(properties) {
        return new SSL_GeometryData(properties);
    };

    /**
     * Encodes the specified SSL_GeometryData message. Does not implicitly {@link SSL_GeometryData.verify|verify} messages.
     * @function encode
     * @memberof SSL_GeometryData
     * @static
     * @param {ISSL_GeometryData} message SSL_GeometryData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_GeometryData.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        $root.SSL_GeometryFieldSize.encode(message.field, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.calib != null && message.calib.length)
            for (let i = 0; i < message.calib.length; ++i)
                $root.SSL_GeometryCameraCalibration.encode(message.calib[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.models != null && Object.hasOwnProperty.call(message, "models"))
            $root.SSL_GeometryModels.encode(message.models, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SSL_GeometryData message, length delimited. Does not implicitly {@link SSL_GeometryData.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SSL_GeometryData
     * @static
     * @param {ISSL_GeometryData} message SSL_GeometryData message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_GeometryData.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SSL_GeometryData message from the specified reader or buffer.
     * @function decode
     * @memberof SSL_GeometryData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SSL_GeometryData} SSL_GeometryData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_GeometryData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SSL_GeometryData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.field = $root.SSL_GeometryFieldSize.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    if (!(message.calib && message.calib.length))
                        message.calib = [];
                    message.calib.push($root.SSL_GeometryCameraCalibration.decode(reader, reader.uint32()));
                    break;
                }
            case 3: {
                    message.models = $root.SSL_GeometryModels.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("field"))
            throw $util.ProtocolError("missing required 'field'", { instance: message });
        return message;
    };

    /**
     * Decodes a SSL_GeometryData message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SSL_GeometryData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SSL_GeometryData} SSL_GeometryData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_GeometryData.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SSL_GeometryData message.
     * @function verify
     * @memberof SSL_GeometryData
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SSL_GeometryData.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        {
            let error = $root.SSL_GeometryFieldSize.verify(message.field);
            if (error)
                return "field." + error;
        }
        if (message.calib != null && message.hasOwnProperty("calib")) {
            if (!Array.isArray(message.calib))
                return "calib: array expected";
            for (let i = 0; i < message.calib.length; ++i) {
                let error = $root.SSL_GeometryCameraCalibration.verify(message.calib[i]);
                if (error)
                    return "calib." + error;
            }
        }
        if (message.models != null && message.hasOwnProperty("models")) {
            let error = $root.SSL_GeometryModels.verify(message.models);
            if (error)
                return "models." + error;
        }
        return null;
    };

    /**
     * Creates a SSL_GeometryData message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SSL_GeometryData
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SSL_GeometryData} SSL_GeometryData
     */
    SSL_GeometryData.fromObject = function fromObject(object) {
        if (object instanceof $root.SSL_GeometryData)
            return object;
        let message = new $root.SSL_GeometryData();
        if (object.field != null) {
            if (typeof object.field !== "object")
                throw TypeError(".SSL_GeometryData.field: object expected");
            message.field = $root.SSL_GeometryFieldSize.fromObject(object.field);
        }
        if (object.calib) {
            if (!Array.isArray(object.calib))
                throw TypeError(".SSL_GeometryData.calib: array expected");
            message.calib = [];
            for (let i = 0; i < object.calib.length; ++i) {
                if (typeof object.calib[i] !== "object")
                    throw TypeError(".SSL_GeometryData.calib: object expected");
                message.calib[i] = $root.SSL_GeometryCameraCalibration.fromObject(object.calib[i]);
            }
        }
        if (object.models != null) {
            if (typeof object.models !== "object")
                throw TypeError(".SSL_GeometryData.models: object expected");
            message.models = $root.SSL_GeometryModels.fromObject(object.models);
        }
        return message;
    };

    /**
     * Creates a plain object from a SSL_GeometryData message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SSL_GeometryData
     * @static
     * @param {SSL_GeometryData} message SSL_GeometryData
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SSL_GeometryData.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.calib = [];
        if (options.defaults) {
            object.field = null;
            object.models = null;
        }
        if (message.field != null && message.hasOwnProperty("field"))
            object.field = $root.SSL_GeometryFieldSize.toObject(message.field, options);
        if (message.calib && message.calib.length) {
            object.calib = [];
            for (let j = 0; j < message.calib.length; ++j)
                object.calib[j] = $root.SSL_GeometryCameraCalibration.toObject(message.calib[j], options);
        }
        if (message.models != null && message.hasOwnProperty("models"))
            object.models = $root.SSL_GeometryModels.toObject(message.models, options);
        return object;
    };

    /**
     * Converts this SSL_GeometryData to JSON.
     * @function toJSON
     * @memberof SSL_GeometryData
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SSL_GeometryData.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SSL_GeometryData
     * @function getTypeUrl
     * @memberof SSL_GeometryData
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SSL_GeometryData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SSL_GeometryData";
    };

    return SSL_GeometryData;
})();

/**
 * SSL_FieldShapeType enum.
 * @exports SSL_FieldShapeType
 * @enum {number}
 * @property {number} Undefined=0 Undefined value
 * @property {number} CenterCircle=1 CenterCircle value
 * @property {number} TopTouchLine=2 TopTouchLine value
 * @property {number} BottomTouchLine=3 BottomTouchLine value
 * @property {number} LeftGoalLine=4 LeftGoalLine value
 * @property {number} RightGoalLine=5 RightGoalLine value
 * @property {number} HalfwayLine=6 HalfwayLine value
 * @property {number} CenterLine=7 CenterLine value
 * @property {number} LeftPenaltyStretch=8 LeftPenaltyStretch value
 * @property {number} RightPenaltyStretch=9 RightPenaltyStretch value
 * @property {number} LeftFieldLeftPenaltyStretch=10 LeftFieldLeftPenaltyStretch value
 * @property {number} LeftFieldRightPenaltyStretch=11 LeftFieldRightPenaltyStretch value
 * @property {number} RightFieldLeftPenaltyStretch=12 RightFieldLeftPenaltyStretch value
 * @property {number} RightFieldRightPenaltyStretch=13 RightFieldRightPenaltyStretch value
 */
export const SSL_FieldShapeType = $root.SSL_FieldShapeType = (() => {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Undefined"] = 0;
    values[valuesById[1] = "CenterCircle"] = 1;
    values[valuesById[2] = "TopTouchLine"] = 2;
    values[valuesById[3] = "BottomTouchLine"] = 3;
    values[valuesById[4] = "LeftGoalLine"] = 4;
    values[valuesById[5] = "RightGoalLine"] = 5;
    values[valuesById[6] = "HalfwayLine"] = 6;
    values[valuesById[7] = "CenterLine"] = 7;
    values[valuesById[8] = "LeftPenaltyStretch"] = 8;
    values[valuesById[9] = "RightPenaltyStretch"] = 9;
    values[valuesById[10] = "LeftFieldLeftPenaltyStretch"] = 10;
    values[valuesById[11] = "LeftFieldRightPenaltyStretch"] = 11;
    values[valuesById[12] = "RightFieldLeftPenaltyStretch"] = 12;
    values[valuesById[13] = "RightFieldRightPenaltyStretch"] = 13;
    return values;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type_url = reader.string();
                            break;
                        }
                    case 2: {
                            message.value = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                let message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length >= 0)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Any
             * @function getTypeUrl
             * @memberof google.protobuf.Any
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Any.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Any";
            };

            return Any;
        })();

        return protobuf;
    })();

    return google;
})();

export const SimulatorError = $root.SimulatorError = (() => {

    /**
     * Properties of a SimulatorError.
     * @exports ISimulatorError
     * @interface ISimulatorError
     * @property {string|null} [code] SimulatorError code
     * @property {string|null} [message] SimulatorError message
     */

    /**
     * Constructs a new SimulatorError.
     * @exports SimulatorError
     * @classdesc Represents a SimulatorError.
     * @implements ISimulatorError
     * @constructor
     * @param {ISimulatorError=} [properties] Properties to set
     */
    function SimulatorError(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SimulatorError code.
     * @member {string} code
     * @memberof SimulatorError
     * @instance
     */
    SimulatorError.prototype.code = "";

    /**
     * SimulatorError message.
     * @member {string} message
     * @memberof SimulatorError
     * @instance
     */
    SimulatorError.prototype.message = "";

    /**
     * Creates a new SimulatorError instance using the specified properties.
     * @function create
     * @memberof SimulatorError
     * @static
     * @param {ISimulatorError=} [properties] Properties to set
     * @returns {SimulatorError} SimulatorError instance
     */
    SimulatorError.create = function create(properties) {
        return new SimulatorError(properties);
    };

    /**
     * Encodes the specified SimulatorError message. Does not implicitly {@link SimulatorError.verify|verify} messages.
     * @function encode
     * @memberof SimulatorError
     * @static
     * @param {ISimulatorError} message SimulatorError message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulatorError.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.code != null && Object.hasOwnProperty.call(message, "code"))
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);
        if (message.message != null && Object.hasOwnProperty.call(message, "message"))
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
        return writer;
    };

    /**
     * Encodes the specified SimulatorError message, length delimited. Does not implicitly {@link SimulatorError.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SimulatorError
     * @static
     * @param {ISimulatorError} message SimulatorError message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulatorError.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SimulatorError message from the specified reader or buffer.
     * @function decode
     * @memberof SimulatorError
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SimulatorError} SimulatorError
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulatorError.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SimulatorError();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.code = reader.string();
                    break;
                }
            case 2: {
                    message.message = reader.string();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SimulatorError message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SimulatorError
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SimulatorError} SimulatorError
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulatorError.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SimulatorError message.
     * @function verify
     * @memberof SimulatorError
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SimulatorError.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.code != null && message.hasOwnProperty("code"))
            if (!$util.isString(message.code))
                return "code: string expected";
        if (message.message != null && message.hasOwnProperty("message"))
            if (!$util.isString(message.message))
                return "message: string expected";
        return null;
    };

    /**
     * Creates a SimulatorError message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SimulatorError
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SimulatorError} SimulatorError
     */
    SimulatorError.fromObject = function fromObject(object) {
        if (object instanceof $root.SimulatorError)
            return object;
        let message = new $root.SimulatorError();
        if (object.code != null)
            message.code = String(object.code);
        if (object.message != null)
            message.message = String(object.message);
        return message;
    };

    /**
     * Creates a plain object from a SimulatorError message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SimulatorError
     * @static
     * @param {SimulatorError} message SimulatorError
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SimulatorError.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.code = "";
            object.message = "";
        }
        if (message.code != null && message.hasOwnProperty("code"))
            object.code = message.code;
        if (message.message != null && message.hasOwnProperty("message"))
            object.message = message.message;
        return object;
    };

    /**
     * Converts this SimulatorError to JSON.
     * @function toJSON
     * @memberof SimulatorError
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SimulatorError.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SimulatorError
     * @function getTypeUrl
     * @memberof SimulatorError
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SimulatorError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SimulatorError";
    };

    return SimulatorError;
})();

export const RobotCommand = $root.RobotCommand = (() => {

    /**
     * Properties of a RobotCommand.
     * @exports IRobotCommand
     * @interface IRobotCommand
     * @property {number} id RobotCommand id
     * @property {IRobotMoveCommand|null} [moveCommand] RobotCommand moveCommand
     * @property {number|null} [kickSpeed] RobotCommand kickSpeed
     * @property {number|null} [kickAngle] RobotCommand kickAngle
     * @property {number|null} [dribblerSpeed] RobotCommand dribblerSpeed
     */

    /**
     * Constructs a new RobotCommand.
     * @exports RobotCommand
     * @classdesc Represents a RobotCommand.
     * @implements IRobotCommand
     * @constructor
     * @param {IRobotCommand=} [properties] Properties to set
     */
    function RobotCommand(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RobotCommand id.
     * @member {number} id
     * @memberof RobotCommand
     * @instance
     */
    RobotCommand.prototype.id = 0;

    /**
     * RobotCommand moveCommand.
     * @member {IRobotMoveCommand|null|undefined} moveCommand
     * @memberof RobotCommand
     * @instance
     */
    RobotCommand.prototype.moveCommand = null;

    /**
     * RobotCommand kickSpeed.
     * @member {number} kickSpeed
     * @memberof RobotCommand
     * @instance
     */
    RobotCommand.prototype.kickSpeed = 0;

    /**
     * RobotCommand kickAngle.
     * @member {number} kickAngle
     * @memberof RobotCommand
     * @instance
     */
    RobotCommand.prototype.kickAngle = 0;

    /**
     * RobotCommand dribblerSpeed.
     * @member {number} dribblerSpeed
     * @memberof RobotCommand
     * @instance
     */
    RobotCommand.prototype.dribblerSpeed = 0;

    /**
     * Creates a new RobotCommand instance using the specified properties.
     * @function create
     * @memberof RobotCommand
     * @static
     * @param {IRobotCommand=} [properties] Properties to set
     * @returns {RobotCommand} RobotCommand instance
     */
    RobotCommand.create = function create(properties) {
        return new RobotCommand(properties);
    };

    /**
     * Encodes the specified RobotCommand message. Does not implicitly {@link RobotCommand.verify|verify} messages.
     * @function encode
     * @memberof RobotCommand
     * @static
     * @param {IRobotCommand} message RobotCommand message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotCommand.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
        if (message.moveCommand != null && Object.hasOwnProperty.call(message, "moveCommand"))
            $root.RobotMoveCommand.encode(message.moveCommand, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.kickSpeed != null && Object.hasOwnProperty.call(message, "kickSpeed"))
            writer.uint32(/* id 3, wireType 5 =*/29).float(message.kickSpeed);
        if (message.kickAngle != null && Object.hasOwnProperty.call(message, "kickAngle"))
            writer.uint32(/* id 4, wireType 5 =*/37).float(message.kickAngle);
        if (message.dribblerSpeed != null && Object.hasOwnProperty.call(message, "dribblerSpeed"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.dribblerSpeed);
        return writer;
    };

    /**
     * Encodes the specified RobotCommand message, length delimited. Does not implicitly {@link RobotCommand.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RobotCommand
     * @static
     * @param {IRobotCommand} message RobotCommand message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotCommand.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RobotCommand message from the specified reader or buffer.
     * @function decode
     * @memberof RobotCommand
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RobotCommand} RobotCommand
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotCommand.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RobotCommand();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.id = reader.uint32();
                    break;
                }
            case 2: {
                    message.moveCommand = $root.RobotMoveCommand.decode(reader, reader.uint32());
                    break;
                }
            case 3: {
                    message.kickSpeed = reader.float();
                    break;
                }
            case 4: {
                    message.kickAngle = reader.float();
                    break;
                }
            case 5: {
                    message.dribblerSpeed = reader.float();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("id"))
            throw $util.ProtocolError("missing required 'id'", { instance: message });
        return message;
    };

    /**
     * Decodes a RobotCommand message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RobotCommand
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RobotCommand} RobotCommand
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotCommand.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RobotCommand message.
     * @function verify
     * @memberof RobotCommand
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RobotCommand.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.id))
            return "id: integer expected";
        if (message.moveCommand != null && message.hasOwnProperty("moveCommand")) {
            let error = $root.RobotMoveCommand.verify(message.moveCommand);
            if (error)
                return "moveCommand." + error;
        }
        if (message.kickSpeed != null && message.hasOwnProperty("kickSpeed"))
            if (typeof message.kickSpeed !== "number")
                return "kickSpeed: number expected";
        if (message.kickAngle != null && message.hasOwnProperty("kickAngle"))
            if (typeof message.kickAngle !== "number")
                return "kickAngle: number expected";
        if (message.dribblerSpeed != null && message.hasOwnProperty("dribblerSpeed"))
            if (typeof message.dribblerSpeed !== "number")
                return "dribblerSpeed: number expected";
        return null;
    };

    /**
     * Creates a RobotCommand message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RobotCommand
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RobotCommand} RobotCommand
     */
    RobotCommand.fromObject = function fromObject(object) {
        if (object instanceof $root.RobotCommand)
            return object;
        let message = new $root.RobotCommand();
        if (object.id != null)
            message.id = object.id >>> 0;
        if (object.moveCommand != null) {
            if (typeof object.moveCommand !== "object")
                throw TypeError(".RobotCommand.moveCommand: object expected");
            message.moveCommand = $root.RobotMoveCommand.fromObject(object.moveCommand);
        }
        if (object.kickSpeed != null)
            message.kickSpeed = Number(object.kickSpeed);
        if (object.kickAngle != null)
            message.kickAngle = Number(object.kickAngle);
        if (object.dribblerSpeed != null)
            message.dribblerSpeed = Number(object.dribblerSpeed);
        return message;
    };

    /**
     * Creates a plain object from a RobotCommand message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RobotCommand
     * @static
     * @param {RobotCommand} message RobotCommand
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RobotCommand.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.id = 0;
            object.moveCommand = null;
            object.kickSpeed = 0;
            object.kickAngle = 0;
            object.dribblerSpeed = 0;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.moveCommand != null && message.hasOwnProperty("moveCommand"))
            object.moveCommand = $root.RobotMoveCommand.toObject(message.moveCommand, options);
        if (message.kickSpeed != null && message.hasOwnProperty("kickSpeed"))
            object.kickSpeed = options.json && !isFinite(message.kickSpeed) ? String(message.kickSpeed) : message.kickSpeed;
        if (message.kickAngle != null && message.hasOwnProperty("kickAngle"))
            object.kickAngle = options.json && !isFinite(message.kickAngle) ? String(message.kickAngle) : message.kickAngle;
        if (message.dribblerSpeed != null && message.hasOwnProperty("dribblerSpeed"))
            object.dribblerSpeed = options.json && !isFinite(message.dribblerSpeed) ? String(message.dribblerSpeed) : message.dribblerSpeed;
        return object;
    };

    /**
     * Converts this RobotCommand to JSON.
     * @function toJSON
     * @memberof RobotCommand
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RobotCommand.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RobotCommand
     * @function getTypeUrl
     * @memberof RobotCommand
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RobotCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RobotCommand";
    };

    return RobotCommand;
})();

export const RobotMoveCommand = $root.RobotMoveCommand = (() => {

    /**
     * Properties of a RobotMoveCommand.
     * @exports IRobotMoveCommand
     * @interface IRobotMoveCommand
     * @property {IMoveWheelVelocity|null} [wheelVelocity] RobotMoveCommand wheelVelocity
     * @property {IMoveLocalVelocity|null} [localVelocity] RobotMoveCommand localVelocity
     * @property {IMoveGlobalVelocity|null} [globalVelocity] RobotMoveCommand globalVelocity
     */

    /**
     * Constructs a new RobotMoveCommand.
     * @exports RobotMoveCommand
     * @classdesc Represents a RobotMoveCommand.
     * @implements IRobotMoveCommand
     * @constructor
     * @param {IRobotMoveCommand=} [properties] Properties to set
     */
    function RobotMoveCommand(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RobotMoveCommand wheelVelocity.
     * @member {IMoveWheelVelocity|null|undefined} wheelVelocity
     * @memberof RobotMoveCommand
     * @instance
     */
    RobotMoveCommand.prototype.wheelVelocity = null;

    /**
     * RobotMoveCommand localVelocity.
     * @member {IMoveLocalVelocity|null|undefined} localVelocity
     * @memberof RobotMoveCommand
     * @instance
     */
    RobotMoveCommand.prototype.localVelocity = null;

    /**
     * RobotMoveCommand globalVelocity.
     * @member {IMoveGlobalVelocity|null|undefined} globalVelocity
     * @memberof RobotMoveCommand
     * @instance
     */
    RobotMoveCommand.prototype.globalVelocity = null;

    // OneOf field names bound to virtual getters and setters
    let $oneOfFields;

    /**
     * RobotMoveCommand command.
     * @member {"wheelVelocity"|"localVelocity"|"globalVelocity"|undefined} command
     * @memberof RobotMoveCommand
     * @instance
     */
    Object.defineProperty(RobotMoveCommand.prototype, "command", {
        get: $util.oneOfGetter($oneOfFields = ["wheelVelocity", "localVelocity", "globalVelocity"]),
        set: $util.oneOfSetter($oneOfFields)
    });

    /**
     * Creates a new RobotMoveCommand instance using the specified properties.
     * @function create
     * @memberof RobotMoveCommand
     * @static
     * @param {IRobotMoveCommand=} [properties] Properties to set
     * @returns {RobotMoveCommand} RobotMoveCommand instance
     */
    RobotMoveCommand.create = function create(properties) {
        return new RobotMoveCommand(properties);
    };

    /**
     * Encodes the specified RobotMoveCommand message. Does not implicitly {@link RobotMoveCommand.verify|verify} messages.
     * @function encode
     * @memberof RobotMoveCommand
     * @static
     * @param {IRobotMoveCommand} message RobotMoveCommand message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotMoveCommand.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.wheelVelocity != null && Object.hasOwnProperty.call(message, "wheelVelocity"))
            $root.MoveWheelVelocity.encode(message.wheelVelocity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.localVelocity != null && Object.hasOwnProperty.call(message, "localVelocity"))
            $root.MoveLocalVelocity.encode(message.localVelocity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.globalVelocity != null && Object.hasOwnProperty.call(message, "globalVelocity"))
            $root.MoveGlobalVelocity.encode(message.globalVelocity, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RobotMoveCommand message, length delimited. Does not implicitly {@link RobotMoveCommand.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RobotMoveCommand
     * @static
     * @param {IRobotMoveCommand} message RobotMoveCommand message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotMoveCommand.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RobotMoveCommand message from the specified reader or buffer.
     * @function decode
     * @memberof RobotMoveCommand
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RobotMoveCommand} RobotMoveCommand
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotMoveCommand.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RobotMoveCommand();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.wheelVelocity = $root.MoveWheelVelocity.decode(reader, reader.uint32());
                    break;
                }
            case 2: {
                    message.localVelocity = $root.MoveLocalVelocity.decode(reader, reader.uint32());
                    break;
                }
            case 3: {
                    message.globalVelocity = $root.MoveGlobalVelocity.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RobotMoveCommand message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RobotMoveCommand
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RobotMoveCommand} RobotMoveCommand
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotMoveCommand.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RobotMoveCommand message.
     * @function verify
     * @memberof RobotMoveCommand
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RobotMoveCommand.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        let properties = {};
        if (message.wheelVelocity != null && message.hasOwnProperty("wheelVelocity")) {
            properties.command = 1;
            {
                let error = $root.MoveWheelVelocity.verify(message.wheelVelocity);
                if (error)
                    return "wheelVelocity." + error;
            }
        }
        if (message.localVelocity != null && message.hasOwnProperty("localVelocity")) {
            if (properties.command === 1)
                return "command: multiple values";
            properties.command = 1;
            {
                let error = $root.MoveLocalVelocity.verify(message.localVelocity);
                if (error)
                    return "localVelocity." + error;
            }
        }
        if (message.globalVelocity != null && message.hasOwnProperty("globalVelocity")) {
            if (properties.command === 1)
                return "command: multiple values";
            properties.command = 1;
            {
                let error = $root.MoveGlobalVelocity.verify(message.globalVelocity);
                if (error)
                    return "globalVelocity." + error;
            }
        }
        return null;
    };

    /**
     * Creates a RobotMoveCommand message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RobotMoveCommand
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RobotMoveCommand} RobotMoveCommand
     */
    RobotMoveCommand.fromObject = function fromObject(object) {
        if (object instanceof $root.RobotMoveCommand)
            return object;
        let message = new $root.RobotMoveCommand();
        if (object.wheelVelocity != null) {
            if (typeof object.wheelVelocity !== "object")
                throw TypeError(".RobotMoveCommand.wheelVelocity: object expected");
            message.wheelVelocity = $root.MoveWheelVelocity.fromObject(object.wheelVelocity);
        }
        if (object.localVelocity != null) {
            if (typeof object.localVelocity !== "object")
                throw TypeError(".RobotMoveCommand.localVelocity: object expected");
            message.localVelocity = $root.MoveLocalVelocity.fromObject(object.localVelocity);
        }
        if (object.globalVelocity != null) {
            if (typeof object.globalVelocity !== "object")
                throw TypeError(".RobotMoveCommand.globalVelocity: object expected");
            message.globalVelocity = $root.MoveGlobalVelocity.fromObject(object.globalVelocity);
        }
        return message;
    };

    /**
     * Creates a plain object from a RobotMoveCommand message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RobotMoveCommand
     * @static
     * @param {RobotMoveCommand} message RobotMoveCommand
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RobotMoveCommand.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (message.wheelVelocity != null && message.hasOwnProperty("wheelVelocity")) {
            object.wheelVelocity = $root.MoveWheelVelocity.toObject(message.wheelVelocity, options);
            if (options.oneofs)
                object.command = "wheelVelocity";
        }
        if (message.localVelocity != null && message.hasOwnProperty("localVelocity")) {
            object.localVelocity = $root.MoveLocalVelocity.toObject(message.localVelocity, options);
            if (options.oneofs)
                object.command = "localVelocity";
        }
        if (message.globalVelocity != null && message.hasOwnProperty("globalVelocity")) {
            object.globalVelocity = $root.MoveGlobalVelocity.toObject(message.globalVelocity, options);
            if (options.oneofs)
                object.command = "globalVelocity";
        }
        return object;
    };

    /**
     * Converts this RobotMoveCommand to JSON.
     * @function toJSON
     * @memberof RobotMoveCommand
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RobotMoveCommand.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RobotMoveCommand
     * @function getTypeUrl
     * @memberof RobotMoveCommand
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RobotMoveCommand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RobotMoveCommand";
    };

    return RobotMoveCommand;
})();

export const MoveWheelVelocity = $root.MoveWheelVelocity = (() => {

    /**
     * Properties of a MoveWheelVelocity.
     * @exports IMoveWheelVelocity
     * @interface IMoveWheelVelocity
     * @property {number} frontRight MoveWheelVelocity frontRight
     * @property {number} backRight MoveWheelVelocity backRight
     * @property {number} backLeft MoveWheelVelocity backLeft
     * @property {number} frontLeft MoveWheelVelocity frontLeft
     */

    /**
     * Constructs a new MoveWheelVelocity.
     * @exports MoveWheelVelocity
     * @classdesc Represents a MoveWheelVelocity.
     * @implements IMoveWheelVelocity
     * @constructor
     * @param {IMoveWheelVelocity=} [properties] Properties to set
     */
    function MoveWheelVelocity(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MoveWheelVelocity frontRight.
     * @member {number} frontRight
     * @memberof MoveWheelVelocity
     * @instance
     */
    MoveWheelVelocity.prototype.frontRight = 0;

    /**
     * MoveWheelVelocity backRight.
     * @member {number} backRight
     * @memberof MoveWheelVelocity
     * @instance
     */
    MoveWheelVelocity.prototype.backRight = 0;

    /**
     * MoveWheelVelocity backLeft.
     * @member {number} backLeft
     * @memberof MoveWheelVelocity
     * @instance
     */
    MoveWheelVelocity.prototype.backLeft = 0;

    /**
     * MoveWheelVelocity frontLeft.
     * @member {number} frontLeft
     * @memberof MoveWheelVelocity
     * @instance
     */
    MoveWheelVelocity.prototype.frontLeft = 0;

    /**
     * Creates a new MoveWheelVelocity instance using the specified properties.
     * @function create
     * @memberof MoveWheelVelocity
     * @static
     * @param {IMoveWheelVelocity=} [properties] Properties to set
     * @returns {MoveWheelVelocity} MoveWheelVelocity instance
     */
    MoveWheelVelocity.create = function create(properties) {
        return new MoveWheelVelocity(properties);
    };

    /**
     * Encodes the specified MoveWheelVelocity message. Does not implicitly {@link MoveWheelVelocity.verify|verify} messages.
     * @function encode
     * @memberof MoveWheelVelocity
     * @static
     * @param {IMoveWheelVelocity} message MoveWheelVelocity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoveWheelVelocity.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 5 =*/13).float(message.frontRight);
        writer.uint32(/* id 2, wireType 5 =*/21).float(message.backRight);
        writer.uint32(/* id 3, wireType 5 =*/29).float(message.backLeft);
        writer.uint32(/* id 4, wireType 5 =*/37).float(message.frontLeft);
        return writer;
    };

    /**
     * Encodes the specified MoveWheelVelocity message, length delimited. Does not implicitly {@link MoveWheelVelocity.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MoveWheelVelocity
     * @static
     * @param {IMoveWheelVelocity} message MoveWheelVelocity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoveWheelVelocity.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MoveWheelVelocity message from the specified reader or buffer.
     * @function decode
     * @memberof MoveWheelVelocity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MoveWheelVelocity} MoveWheelVelocity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoveWheelVelocity.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MoveWheelVelocity();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.frontRight = reader.float();
                    break;
                }
            case 2: {
                    message.backRight = reader.float();
                    break;
                }
            case 3: {
                    message.backLeft = reader.float();
                    break;
                }
            case 4: {
                    message.frontLeft = reader.float();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("frontRight"))
            throw $util.ProtocolError("missing required 'frontRight'", { instance: message });
        if (!message.hasOwnProperty("backRight"))
            throw $util.ProtocolError("missing required 'backRight'", { instance: message });
        if (!message.hasOwnProperty("backLeft"))
            throw $util.ProtocolError("missing required 'backLeft'", { instance: message });
        if (!message.hasOwnProperty("frontLeft"))
            throw $util.ProtocolError("missing required 'frontLeft'", { instance: message });
        return message;
    };

    /**
     * Decodes a MoveWheelVelocity message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MoveWheelVelocity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MoveWheelVelocity} MoveWheelVelocity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoveWheelVelocity.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MoveWheelVelocity message.
     * @function verify
     * @memberof MoveWheelVelocity
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MoveWheelVelocity.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (typeof message.frontRight !== "number")
            return "frontRight: number expected";
        if (typeof message.backRight !== "number")
            return "backRight: number expected";
        if (typeof message.backLeft !== "number")
            return "backLeft: number expected";
        if (typeof message.frontLeft !== "number")
            return "frontLeft: number expected";
        return null;
    };

    /**
     * Creates a MoveWheelVelocity message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MoveWheelVelocity
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MoveWheelVelocity} MoveWheelVelocity
     */
    MoveWheelVelocity.fromObject = function fromObject(object) {
        if (object instanceof $root.MoveWheelVelocity)
            return object;
        let message = new $root.MoveWheelVelocity();
        if (object.frontRight != null)
            message.frontRight = Number(object.frontRight);
        if (object.backRight != null)
            message.backRight = Number(object.backRight);
        if (object.backLeft != null)
            message.backLeft = Number(object.backLeft);
        if (object.frontLeft != null)
            message.frontLeft = Number(object.frontLeft);
        return message;
    };

    /**
     * Creates a plain object from a MoveWheelVelocity message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MoveWheelVelocity
     * @static
     * @param {MoveWheelVelocity} message MoveWheelVelocity
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MoveWheelVelocity.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.frontRight = 0;
            object.backRight = 0;
            object.backLeft = 0;
            object.frontLeft = 0;
        }
        if (message.frontRight != null && message.hasOwnProperty("frontRight"))
            object.frontRight = options.json && !isFinite(message.frontRight) ? String(message.frontRight) : message.frontRight;
        if (message.backRight != null && message.hasOwnProperty("backRight"))
            object.backRight = options.json && !isFinite(message.backRight) ? String(message.backRight) : message.backRight;
        if (message.backLeft != null && message.hasOwnProperty("backLeft"))
            object.backLeft = options.json && !isFinite(message.backLeft) ? String(message.backLeft) : message.backLeft;
        if (message.frontLeft != null && message.hasOwnProperty("frontLeft"))
            object.frontLeft = options.json && !isFinite(message.frontLeft) ? String(message.frontLeft) : message.frontLeft;
        return object;
    };

    /**
     * Converts this MoveWheelVelocity to JSON.
     * @function toJSON
     * @memberof MoveWheelVelocity
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MoveWheelVelocity.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for MoveWheelVelocity
     * @function getTypeUrl
     * @memberof MoveWheelVelocity
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    MoveWheelVelocity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/MoveWheelVelocity";
    };

    return MoveWheelVelocity;
})();

export const MoveLocalVelocity = $root.MoveLocalVelocity = (() => {

    /**
     * Properties of a MoveLocalVelocity.
     * @exports IMoveLocalVelocity
     * @interface IMoveLocalVelocity
     * @property {number} forward MoveLocalVelocity forward
     * @property {number} left MoveLocalVelocity left
     * @property {number} angular MoveLocalVelocity angular
     */

    /**
     * Constructs a new MoveLocalVelocity.
     * @exports MoveLocalVelocity
     * @classdesc Represents a MoveLocalVelocity.
     * @implements IMoveLocalVelocity
     * @constructor
     * @param {IMoveLocalVelocity=} [properties] Properties to set
     */
    function MoveLocalVelocity(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MoveLocalVelocity forward.
     * @member {number} forward
     * @memberof MoveLocalVelocity
     * @instance
     */
    MoveLocalVelocity.prototype.forward = 0;

    /**
     * MoveLocalVelocity left.
     * @member {number} left
     * @memberof MoveLocalVelocity
     * @instance
     */
    MoveLocalVelocity.prototype.left = 0;

    /**
     * MoveLocalVelocity angular.
     * @member {number} angular
     * @memberof MoveLocalVelocity
     * @instance
     */
    MoveLocalVelocity.prototype.angular = 0;

    /**
     * Creates a new MoveLocalVelocity instance using the specified properties.
     * @function create
     * @memberof MoveLocalVelocity
     * @static
     * @param {IMoveLocalVelocity=} [properties] Properties to set
     * @returns {MoveLocalVelocity} MoveLocalVelocity instance
     */
    MoveLocalVelocity.create = function create(properties) {
        return new MoveLocalVelocity(properties);
    };

    /**
     * Encodes the specified MoveLocalVelocity message. Does not implicitly {@link MoveLocalVelocity.verify|verify} messages.
     * @function encode
     * @memberof MoveLocalVelocity
     * @static
     * @param {IMoveLocalVelocity} message MoveLocalVelocity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoveLocalVelocity.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 5 =*/13).float(message.forward);
        writer.uint32(/* id 2, wireType 5 =*/21).float(message.left);
        writer.uint32(/* id 3, wireType 5 =*/29).float(message.angular);
        return writer;
    };

    /**
     * Encodes the specified MoveLocalVelocity message, length delimited. Does not implicitly {@link MoveLocalVelocity.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MoveLocalVelocity
     * @static
     * @param {IMoveLocalVelocity} message MoveLocalVelocity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoveLocalVelocity.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MoveLocalVelocity message from the specified reader or buffer.
     * @function decode
     * @memberof MoveLocalVelocity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MoveLocalVelocity} MoveLocalVelocity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoveLocalVelocity.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MoveLocalVelocity();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.forward = reader.float();
                    break;
                }
            case 2: {
                    message.left = reader.float();
                    break;
                }
            case 3: {
                    message.angular = reader.float();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("forward"))
            throw $util.ProtocolError("missing required 'forward'", { instance: message });
        if (!message.hasOwnProperty("left"))
            throw $util.ProtocolError("missing required 'left'", { instance: message });
        if (!message.hasOwnProperty("angular"))
            throw $util.ProtocolError("missing required 'angular'", { instance: message });
        return message;
    };

    /**
     * Decodes a MoveLocalVelocity message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MoveLocalVelocity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MoveLocalVelocity} MoveLocalVelocity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoveLocalVelocity.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MoveLocalVelocity message.
     * @function verify
     * @memberof MoveLocalVelocity
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MoveLocalVelocity.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (typeof message.forward !== "number")
            return "forward: number expected";
        if (typeof message.left !== "number")
            return "left: number expected";
        if (typeof message.angular !== "number")
            return "angular: number expected";
        return null;
    };

    /**
     * Creates a MoveLocalVelocity message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MoveLocalVelocity
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MoveLocalVelocity} MoveLocalVelocity
     */
    MoveLocalVelocity.fromObject = function fromObject(object) {
        if (object instanceof $root.MoveLocalVelocity)
            return object;
        let message = new $root.MoveLocalVelocity();
        if (object.forward != null)
            message.forward = Number(object.forward);
        if (object.left != null)
            message.left = Number(object.left);
        if (object.angular != null)
            message.angular = Number(object.angular);
        return message;
    };

    /**
     * Creates a plain object from a MoveLocalVelocity message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MoveLocalVelocity
     * @static
     * @param {MoveLocalVelocity} message MoveLocalVelocity
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MoveLocalVelocity.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.forward = 0;
            object.left = 0;
            object.angular = 0;
        }
        if (message.forward != null && message.hasOwnProperty("forward"))
            object.forward = options.json && !isFinite(message.forward) ? String(message.forward) : message.forward;
        if (message.left != null && message.hasOwnProperty("left"))
            object.left = options.json && !isFinite(message.left) ? String(message.left) : message.left;
        if (message.angular != null && message.hasOwnProperty("angular"))
            object.angular = options.json && !isFinite(message.angular) ? String(message.angular) : message.angular;
        return object;
    };

    /**
     * Converts this MoveLocalVelocity to JSON.
     * @function toJSON
     * @memberof MoveLocalVelocity
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MoveLocalVelocity.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for MoveLocalVelocity
     * @function getTypeUrl
     * @memberof MoveLocalVelocity
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    MoveLocalVelocity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/MoveLocalVelocity";
    };

    return MoveLocalVelocity;
})();

export const MoveGlobalVelocity = $root.MoveGlobalVelocity = (() => {

    /**
     * Properties of a MoveGlobalVelocity.
     * @exports IMoveGlobalVelocity
     * @interface IMoveGlobalVelocity
     * @property {number} x MoveGlobalVelocity x
     * @property {number} y MoveGlobalVelocity y
     * @property {number} angular MoveGlobalVelocity angular
     */

    /**
     * Constructs a new MoveGlobalVelocity.
     * @exports MoveGlobalVelocity
     * @classdesc Represents a MoveGlobalVelocity.
     * @implements IMoveGlobalVelocity
     * @constructor
     * @param {IMoveGlobalVelocity=} [properties] Properties to set
     */
    function MoveGlobalVelocity(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * MoveGlobalVelocity x.
     * @member {number} x
     * @memberof MoveGlobalVelocity
     * @instance
     */
    MoveGlobalVelocity.prototype.x = 0;

    /**
     * MoveGlobalVelocity y.
     * @member {number} y
     * @memberof MoveGlobalVelocity
     * @instance
     */
    MoveGlobalVelocity.prototype.y = 0;

    /**
     * MoveGlobalVelocity angular.
     * @member {number} angular
     * @memberof MoveGlobalVelocity
     * @instance
     */
    MoveGlobalVelocity.prototype.angular = 0;

    /**
     * Creates a new MoveGlobalVelocity instance using the specified properties.
     * @function create
     * @memberof MoveGlobalVelocity
     * @static
     * @param {IMoveGlobalVelocity=} [properties] Properties to set
     * @returns {MoveGlobalVelocity} MoveGlobalVelocity instance
     */
    MoveGlobalVelocity.create = function create(properties) {
        return new MoveGlobalVelocity(properties);
    };

    /**
     * Encodes the specified MoveGlobalVelocity message. Does not implicitly {@link MoveGlobalVelocity.verify|verify} messages.
     * @function encode
     * @memberof MoveGlobalVelocity
     * @static
     * @param {IMoveGlobalVelocity} message MoveGlobalVelocity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoveGlobalVelocity.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
        writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
        writer.uint32(/* id 3, wireType 5 =*/29).float(message.angular);
        return writer;
    };

    /**
     * Encodes the specified MoveGlobalVelocity message, length delimited. Does not implicitly {@link MoveGlobalVelocity.verify|verify} messages.
     * @function encodeDelimited
     * @memberof MoveGlobalVelocity
     * @static
     * @param {IMoveGlobalVelocity} message MoveGlobalVelocity message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    MoveGlobalVelocity.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a MoveGlobalVelocity message from the specified reader or buffer.
     * @function decode
     * @memberof MoveGlobalVelocity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MoveGlobalVelocity} MoveGlobalVelocity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoveGlobalVelocity.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MoveGlobalVelocity();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.x = reader.float();
                    break;
                }
            case 2: {
                    message.y = reader.float();
                    break;
                }
            case 3: {
                    message.angular = reader.float();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("x"))
            throw $util.ProtocolError("missing required 'x'", { instance: message });
        if (!message.hasOwnProperty("y"))
            throw $util.ProtocolError("missing required 'y'", { instance: message });
        if (!message.hasOwnProperty("angular"))
            throw $util.ProtocolError("missing required 'angular'", { instance: message });
        return message;
    };

    /**
     * Decodes a MoveGlobalVelocity message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof MoveGlobalVelocity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {MoveGlobalVelocity} MoveGlobalVelocity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MoveGlobalVelocity.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a MoveGlobalVelocity message.
     * @function verify
     * @memberof MoveGlobalVelocity
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    MoveGlobalVelocity.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (typeof message.x !== "number")
            return "x: number expected";
        if (typeof message.y !== "number")
            return "y: number expected";
        if (typeof message.angular !== "number")
            return "angular: number expected";
        return null;
    };

    /**
     * Creates a MoveGlobalVelocity message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof MoveGlobalVelocity
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {MoveGlobalVelocity} MoveGlobalVelocity
     */
    MoveGlobalVelocity.fromObject = function fromObject(object) {
        if (object instanceof $root.MoveGlobalVelocity)
            return object;
        let message = new $root.MoveGlobalVelocity();
        if (object.x != null)
            message.x = Number(object.x);
        if (object.y != null)
            message.y = Number(object.y);
        if (object.angular != null)
            message.angular = Number(object.angular);
        return message;
    };

    /**
     * Creates a plain object from a MoveGlobalVelocity message. Also converts values to other types if specified.
     * @function toObject
     * @memberof MoveGlobalVelocity
     * @static
     * @param {MoveGlobalVelocity} message MoveGlobalVelocity
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    MoveGlobalVelocity.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.x = 0;
            object.y = 0;
            object.angular = 0;
        }
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
        if (message.angular != null && message.hasOwnProperty("angular"))
            object.angular = options.json && !isFinite(message.angular) ? String(message.angular) : message.angular;
        return object;
    };

    /**
     * Converts this MoveGlobalVelocity to JSON.
     * @function toJSON
     * @memberof MoveGlobalVelocity
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    MoveGlobalVelocity.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for MoveGlobalVelocity
     * @function getTypeUrl
     * @memberof MoveGlobalVelocity
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    MoveGlobalVelocity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/MoveGlobalVelocity";
    };

    return MoveGlobalVelocity;
})();

export const RobotControl = $root.RobotControl = (() => {

    /**
     * Properties of a RobotControl.
     * @exports IRobotControl
     * @interface IRobotControl
     * @property {Array.<IRobotCommand>|null} [robotCommands] RobotControl robotCommands
     */

    /**
     * Constructs a new RobotControl.
     * @exports RobotControl
     * @classdesc Represents a RobotControl.
     * @implements IRobotControl
     * @constructor
     * @param {IRobotControl=} [properties] Properties to set
     */
    function RobotControl(properties) {
        this.robotCommands = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RobotControl robotCommands.
     * @member {Array.<IRobotCommand>} robotCommands
     * @memberof RobotControl
     * @instance
     */
    RobotControl.prototype.robotCommands = $util.emptyArray;

    /**
     * Creates a new RobotControl instance using the specified properties.
     * @function create
     * @memberof RobotControl
     * @static
     * @param {IRobotControl=} [properties] Properties to set
     * @returns {RobotControl} RobotControl instance
     */
    RobotControl.create = function create(properties) {
        return new RobotControl(properties);
    };

    /**
     * Encodes the specified RobotControl message. Does not implicitly {@link RobotControl.verify|verify} messages.
     * @function encode
     * @memberof RobotControl
     * @static
     * @param {IRobotControl} message RobotControl message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotControl.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.robotCommands != null && message.robotCommands.length)
            for (let i = 0; i < message.robotCommands.length; ++i)
                $root.RobotCommand.encode(message.robotCommands[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RobotControl message, length delimited. Does not implicitly {@link RobotControl.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RobotControl
     * @static
     * @param {IRobotControl} message RobotControl message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotControl.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RobotControl message from the specified reader or buffer.
     * @function decode
     * @memberof RobotControl
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RobotControl} RobotControl
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotControl.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RobotControl();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.robotCommands && message.robotCommands.length))
                        message.robotCommands = [];
                    message.robotCommands.push($root.RobotCommand.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RobotControl message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RobotControl
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RobotControl} RobotControl
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotControl.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RobotControl message.
     * @function verify
     * @memberof RobotControl
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RobotControl.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.robotCommands != null && message.hasOwnProperty("robotCommands")) {
            if (!Array.isArray(message.robotCommands))
                return "robotCommands: array expected";
            for (let i = 0; i < message.robotCommands.length; ++i) {
                let error = $root.RobotCommand.verify(message.robotCommands[i]);
                if (error)
                    return "robotCommands." + error;
            }
        }
        return null;
    };

    /**
     * Creates a RobotControl message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RobotControl
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RobotControl} RobotControl
     */
    RobotControl.fromObject = function fromObject(object) {
        if (object instanceof $root.RobotControl)
            return object;
        let message = new $root.RobotControl();
        if (object.robotCommands) {
            if (!Array.isArray(object.robotCommands))
                throw TypeError(".RobotControl.robotCommands: array expected");
            message.robotCommands = [];
            for (let i = 0; i < object.robotCommands.length; ++i) {
                if (typeof object.robotCommands[i] !== "object")
                    throw TypeError(".RobotControl.robotCommands: object expected");
                message.robotCommands[i] = $root.RobotCommand.fromObject(object.robotCommands[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a RobotControl message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RobotControl
     * @static
     * @param {RobotControl} message RobotControl
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RobotControl.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.robotCommands = [];
        if (message.robotCommands && message.robotCommands.length) {
            object.robotCommands = [];
            for (let j = 0; j < message.robotCommands.length; ++j)
                object.robotCommands[j] = $root.RobotCommand.toObject(message.robotCommands[j], options);
        }
        return object;
    };

    /**
     * Converts this RobotControl to JSON.
     * @function toJSON
     * @memberof RobotControl
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RobotControl.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RobotControl
     * @function getTypeUrl
     * @memberof RobotControl
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RobotControl.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RobotControl";
    };

    return RobotControl;
})();

export const RobotFeedback = $root.RobotFeedback = (() => {

    /**
     * Properties of a RobotFeedback.
     * @exports IRobotFeedback
     * @interface IRobotFeedback
     * @property {number} id RobotFeedback id
     * @property {boolean|null} [dribblerBallContact] RobotFeedback dribblerBallContact
     * @property {google.protobuf.IAny|null} [custom] RobotFeedback custom
     */

    /**
     * Constructs a new RobotFeedback.
     * @exports RobotFeedback
     * @classdesc Represents a RobotFeedback.
     * @implements IRobotFeedback
     * @constructor
     * @param {IRobotFeedback=} [properties] Properties to set
     */
    function RobotFeedback(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RobotFeedback id.
     * @member {number} id
     * @memberof RobotFeedback
     * @instance
     */
    RobotFeedback.prototype.id = 0;

    /**
     * RobotFeedback dribblerBallContact.
     * @member {boolean} dribblerBallContact
     * @memberof RobotFeedback
     * @instance
     */
    RobotFeedback.prototype.dribblerBallContact = false;

    /**
     * RobotFeedback custom.
     * @member {google.protobuf.IAny|null|undefined} custom
     * @memberof RobotFeedback
     * @instance
     */
    RobotFeedback.prototype.custom = null;

    /**
     * Creates a new RobotFeedback instance using the specified properties.
     * @function create
     * @memberof RobotFeedback
     * @static
     * @param {IRobotFeedback=} [properties] Properties to set
     * @returns {RobotFeedback} RobotFeedback instance
     */
    RobotFeedback.create = function create(properties) {
        return new RobotFeedback(properties);
    };

    /**
     * Encodes the specified RobotFeedback message. Does not implicitly {@link RobotFeedback.verify|verify} messages.
     * @function encode
     * @memberof RobotFeedback
     * @static
     * @param {IRobotFeedback} message RobotFeedback message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotFeedback.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
        if (message.dribblerBallContact != null && Object.hasOwnProperty.call(message, "dribblerBallContact"))
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.dribblerBallContact);
        if (message.custom != null && Object.hasOwnProperty.call(message, "custom"))
            $root.google.protobuf.Any.encode(message.custom, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RobotFeedback message, length delimited. Does not implicitly {@link RobotFeedback.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RobotFeedback
     * @static
     * @param {IRobotFeedback} message RobotFeedback message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotFeedback.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RobotFeedback message from the specified reader or buffer.
     * @function decode
     * @memberof RobotFeedback
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RobotFeedback} RobotFeedback
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotFeedback.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RobotFeedback();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.id = reader.uint32();
                    break;
                }
            case 2: {
                    message.dribblerBallContact = reader.bool();
                    break;
                }
            case 3: {
                    message.custom = $root.google.protobuf.Any.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("id"))
            throw $util.ProtocolError("missing required 'id'", { instance: message });
        return message;
    };

    /**
     * Decodes a RobotFeedback message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RobotFeedback
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RobotFeedback} RobotFeedback
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotFeedback.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RobotFeedback message.
     * @function verify
     * @memberof RobotFeedback
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RobotFeedback.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.id))
            return "id: integer expected";
        if (message.dribblerBallContact != null && message.hasOwnProperty("dribblerBallContact"))
            if (typeof message.dribblerBallContact !== "boolean")
                return "dribblerBallContact: boolean expected";
        if (message.custom != null && message.hasOwnProperty("custom")) {
            let error = $root.google.protobuf.Any.verify(message.custom);
            if (error)
                return "custom." + error;
        }
        return null;
    };

    /**
     * Creates a RobotFeedback message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RobotFeedback
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RobotFeedback} RobotFeedback
     */
    RobotFeedback.fromObject = function fromObject(object) {
        if (object instanceof $root.RobotFeedback)
            return object;
        let message = new $root.RobotFeedback();
        if (object.id != null)
            message.id = object.id >>> 0;
        if (object.dribblerBallContact != null)
            message.dribblerBallContact = Boolean(object.dribblerBallContact);
        if (object.custom != null) {
            if (typeof object.custom !== "object")
                throw TypeError(".RobotFeedback.custom: object expected");
            message.custom = $root.google.protobuf.Any.fromObject(object.custom);
        }
        return message;
    };

    /**
     * Creates a plain object from a RobotFeedback message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RobotFeedback
     * @static
     * @param {RobotFeedback} message RobotFeedback
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RobotFeedback.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.id = 0;
            object.dribblerBallContact = false;
            object.custom = null;
        }
        if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
        if (message.dribblerBallContact != null && message.hasOwnProperty("dribblerBallContact"))
            object.dribblerBallContact = message.dribblerBallContact;
        if (message.custom != null && message.hasOwnProperty("custom"))
            object.custom = $root.google.protobuf.Any.toObject(message.custom, options);
        return object;
    };

    /**
     * Converts this RobotFeedback to JSON.
     * @function toJSON
     * @memberof RobotFeedback
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RobotFeedback.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RobotFeedback
     * @function getTypeUrl
     * @memberof RobotFeedback
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RobotFeedback.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RobotFeedback";
    };

    return RobotFeedback;
})();

export const RobotControlResponse = $root.RobotControlResponse = (() => {

    /**
     * Properties of a RobotControlResponse.
     * @exports IRobotControlResponse
     * @interface IRobotControlResponse
     * @property {Array.<ISimulatorError>|null} [errors] RobotControlResponse errors
     * @property {Array.<IRobotFeedback>|null} [feedback] RobotControlResponse feedback
     */

    /**
     * Constructs a new RobotControlResponse.
     * @exports RobotControlResponse
     * @classdesc Represents a RobotControlResponse.
     * @implements IRobotControlResponse
     * @constructor
     * @param {IRobotControlResponse=} [properties] Properties to set
     */
    function RobotControlResponse(properties) {
        this.errors = [];
        this.feedback = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * RobotControlResponse errors.
     * @member {Array.<ISimulatorError>} errors
     * @memberof RobotControlResponse
     * @instance
     */
    RobotControlResponse.prototype.errors = $util.emptyArray;

    /**
     * RobotControlResponse feedback.
     * @member {Array.<IRobotFeedback>} feedback
     * @memberof RobotControlResponse
     * @instance
     */
    RobotControlResponse.prototype.feedback = $util.emptyArray;

    /**
     * Creates a new RobotControlResponse instance using the specified properties.
     * @function create
     * @memberof RobotControlResponse
     * @static
     * @param {IRobotControlResponse=} [properties] Properties to set
     * @returns {RobotControlResponse} RobotControlResponse instance
     */
    RobotControlResponse.create = function create(properties) {
        return new RobotControlResponse(properties);
    };

    /**
     * Encodes the specified RobotControlResponse message. Does not implicitly {@link RobotControlResponse.verify|verify} messages.
     * @function encode
     * @memberof RobotControlResponse
     * @static
     * @param {IRobotControlResponse} message RobotControlResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotControlResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.errors != null && message.errors.length)
            for (let i = 0; i < message.errors.length; ++i)
                $root.SimulatorError.encode(message.errors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.feedback != null && message.feedback.length)
            for (let i = 0; i < message.feedback.length; ++i)
                $root.RobotFeedback.encode(message.feedback[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified RobotControlResponse message, length delimited. Does not implicitly {@link RobotControlResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof RobotControlResponse
     * @static
     * @param {IRobotControlResponse} message RobotControlResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    RobotControlResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a RobotControlResponse message from the specified reader or buffer.
     * @function decode
     * @memberof RobotControlResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {RobotControlResponse} RobotControlResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotControlResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.RobotControlResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.errors && message.errors.length))
                        message.errors = [];
                    message.errors.push($root.SimulatorError.decode(reader, reader.uint32()));
                    break;
                }
            case 2: {
                    if (!(message.feedback && message.feedback.length))
                        message.feedback = [];
                    message.feedback.push($root.RobotFeedback.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a RobotControlResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof RobotControlResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {RobotControlResponse} RobotControlResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    RobotControlResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a RobotControlResponse message.
     * @function verify
     * @memberof RobotControlResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    RobotControlResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.errors != null && message.hasOwnProperty("errors")) {
            if (!Array.isArray(message.errors))
                return "errors: array expected";
            for (let i = 0; i < message.errors.length; ++i) {
                let error = $root.SimulatorError.verify(message.errors[i]);
                if (error)
                    return "errors." + error;
            }
        }
        if (message.feedback != null && message.hasOwnProperty("feedback")) {
            if (!Array.isArray(message.feedback))
                return "feedback: array expected";
            for (let i = 0; i < message.feedback.length; ++i) {
                let error = $root.RobotFeedback.verify(message.feedback[i]);
                if (error)
                    return "feedback." + error;
            }
        }
        return null;
    };

    /**
     * Creates a RobotControlResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof RobotControlResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {RobotControlResponse} RobotControlResponse
     */
    RobotControlResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.RobotControlResponse)
            return object;
        let message = new $root.RobotControlResponse();
        if (object.errors) {
            if (!Array.isArray(object.errors))
                throw TypeError(".RobotControlResponse.errors: array expected");
            message.errors = [];
            for (let i = 0; i < object.errors.length; ++i) {
                if (typeof object.errors[i] !== "object")
                    throw TypeError(".RobotControlResponse.errors: object expected");
                message.errors[i] = $root.SimulatorError.fromObject(object.errors[i]);
            }
        }
        if (object.feedback) {
            if (!Array.isArray(object.feedback))
                throw TypeError(".RobotControlResponse.feedback: array expected");
            message.feedback = [];
            for (let i = 0; i < object.feedback.length; ++i) {
                if (typeof object.feedback[i] !== "object")
                    throw TypeError(".RobotControlResponse.feedback: object expected");
                message.feedback[i] = $root.RobotFeedback.fromObject(object.feedback[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a RobotControlResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof RobotControlResponse
     * @static
     * @param {RobotControlResponse} message RobotControlResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    RobotControlResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.errors = [];
            object.feedback = [];
        }
        if (message.errors && message.errors.length) {
            object.errors = [];
            for (let j = 0; j < message.errors.length; ++j)
                object.errors[j] = $root.SimulatorError.toObject(message.errors[j], options);
        }
        if (message.feedback && message.feedback.length) {
            object.feedback = [];
            for (let j = 0; j < message.feedback.length; ++j)
                object.feedback[j] = $root.RobotFeedback.toObject(message.feedback[j], options);
        }
        return object;
    };

    /**
     * Converts this RobotControlResponse to JSON.
     * @function toJSON
     * @memberof RobotControlResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    RobotControlResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for RobotControlResponse
     * @function getTypeUrl
     * @memberof RobotControlResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    RobotControlResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/RobotControlResponse";
    };

    return RobotControlResponse;
})();

export const SimulationSyncRequest = $root.SimulationSyncRequest = (() => {

    /**
     * Properties of a SimulationSyncRequest.
     * @exports ISimulationSyncRequest
     * @interface ISimulationSyncRequest
     * @property {number|null} [simStep] SimulationSyncRequest simStep
     * @property {ISimulatorCommand|null} [simulatorCommand] SimulationSyncRequest simulatorCommand
     * @property {IRobotControl|null} [robotControl] SimulationSyncRequest robotControl
     */

    /**
     * Constructs a new SimulationSyncRequest.
     * @exports SimulationSyncRequest
     * @classdesc Represents a SimulationSyncRequest.
     * @implements ISimulationSyncRequest
     * @constructor
     * @param {ISimulationSyncRequest=} [properties] Properties to set
     */
    function SimulationSyncRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SimulationSyncRequest simStep.
     * @member {number} simStep
     * @memberof SimulationSyncRequest
     * @instance
     */
    SimulationSyncRequest.prototype.simStep = 0;

    /**
     * SimulationSyncRequest simulatorCommand.
     * @member {ISimulatorCommand|null|undefined} simulatorCommand
     * @memberof SimulationSyncRequest
     * @instance
     */
    SimulationSyncRequest.prototype.simulatorCommand = null;

    /**
     * SimulationSyncRequest robotControl.
     * @member {IRobotControl|null|undefined} robotControl
     * @memberof SimulationSyncRequest
     * @instance
     */
    SimulationSyncRequest.prototype.robotControl = null;

    /**
     * Creates a new SimulationSyncRequest instance using the specified properties.
     * @function create
     * @memberof SimulationSyncRequest
     * @static
     * @param {ISimulationSyncRequest=} [properties] Properties to set
     * @returns {SimulationSyncRequest} SimulationSyncRequest instance
     */
    SimulationSyncRequest.create = function create(properties) {
        return new SimulationSyncRequest(properties);
    };

    /**
     * Encodes the specified SimulationSyncRequest message. Does not implicitly {@link SimulationSyncRequest.verify|verify} messages.
     * @function encode
     * @memberof SimulationSyncRequest
     * @static
     * @param {ISimulationSyncRequest} message SimulationSyncRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulationSyncRequest.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.simStep != null && Object.hasOwnProperty.call(message, "simStep"))
            writer.uint32(/* id 1, wireType 5 =*/13).float(message.simStep);
        if (message.simulatorCommand != null && Object.hasOwnProperty.call(message, "simulatorCommand"))
            $root.SimulatorCommand.encode(message.simulatorCommand, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        if (message.robotControl != null && Object.hasOwnProperty.call(message, "robotControl"))
            $root.RobotControl.encode(message.robotControl, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SimulationSyncRequest message, length delimited. Does not implicitly {@link SimulationSyncRequest.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SimulationSyncRequest
     * @static
     * @param {ISimulationSyncRequest} message SimulationSyncRequest message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulationSyncRequest.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SimulationSyncRequest message from the specified reader or buffer.
     * @function decode
     * @memberof SimulationSyncRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SimulationSyncRequest} SimulationSyncRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulationSyncRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SimulationSyncRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.simStep = reader.float();
                    break;
                }
            case 2: {
                    message.simulatorCommand = $root.SimulatorCommand.decode(reader, reader.uint32());
                    break;
                }
            case 3: {
                    message.robotControl = $root.RobotControl.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SimulationSyncRequest message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SimulationSyncRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SimulationSyncRequest} SimulationSyncRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulationSyncRequest.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SimulationSyncRequest message.
     * @function verify
     * @memberof SimulationSyncRequest
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SimulationSyncRequest.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.simStep != null && message.hasOwnProperty("simStep"))
            if (typeof message.simStep !== "number")
                return "simStep: number expected";
        if (message.simulatorCommand != null && message.hasOwnProperty("simulatorCommand")) {
            let error = $root.SimulatorCommand.verify(message.simulatorCommand);
            if (error)
                return "simulatorCommand." + error;
        }
        if (message.robotControl != null && message.hasOwnProperty("robotControl")) {
            let error = $root.RobotControl.verify(message.robotControl);
            if (error)
                return "robotControl." + error;
        }
        return null;
    };

    /**
     * Creates a SimulationSyncRequest message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SimulationSyncRequest
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SimulationSyncRequest} SimulationSyncRequest
     */
    SimulationSyncRequest.fromObject = function fromObject(object) {
        if (object instanceof $root.SimulationSyncRequest)
            return object;
        let message = new $root.SimulationSyncRequest();
        if (object.simStep != null)
            message.simStep = Number(object.simStep);
        if (object.simulatorCommand != null) {
            if (typeof object.simulatorCommand !== "object")
                throw TypeError(".SimulationSyncRequest.simulatorCommand: object expected");
            message.simulatorCommand = $root.SimulatorCommand.fromObject(object.simulatorCommand);
        }
        if (object.robotControl != null) {
            if (typeof object.robotControl !== "object")
                throw TypeError(".SimulationSyncRequest.robotControl: object expected");
            message.robotControl = $root.RobotControl.fromObject(object.robotControl);
        }
        return message;
    };

    /**
     * Creates a plain object from a SimulationSyncRequest message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SimulationSyncRequest
     * @static
     * @param {SimulationSyncRequest} message SimulationSyncRequest
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SimulationSyncRequest.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.simStep = 0;
            object.simulatorCommand = null;
            object.robotControl = null;
        }
        if (message.simStep != null && message.hasOwnProperty("simStep"))
            object.simStep = options.json && !isFinite(message.simStep) ? String(message.simStep) : message.simStep;
        if (message.simulatorCommand != null && message.hasOwnProperty("simulatorCommand"))
            object.simulatorCommand = $root.SimulatorCommand.toObject(message.simulatorCommand, options);
        if (message.robotControl != null && message.hasOwnProperty("robotControl"))
            object.robotControl = $root.RobotControl.toObject(message.robotControl, options);
        return object;
    };

    /**
     * Converts this SimulationSyncRequest to JSON.
     * @function toJSON
     * @memberof SimulationSyncRequest
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SimulationSyncRequest.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SimulationSyncRequest
     * @function getTypeUrl
     * @memberof SimulationSyncRequest
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SimulationSyncRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SimulationSyncRequest";
    };

    return SimulationSyncRequest;
})();

export const SimulationSyncResponse = $root.SimulationSyncResponse = (() => {

    /**
     * Properties of a SimulationSyncResponse.
     * @exports ISimulationSyncResponse
     * @interface ISimulationSyncResponse
     * @property {Array.<ISSL_DetectionFrame>|null} [detection] SimulationSyncResponse detection
     * @property {IRobotControlResponse|null} [robotControlResponse] SimulationSyncResponse robotControlResponse
     */

    /**
     * Constructs a new SimulationSyncResponse.
     * @exports SimulationSyncResponse
     * @classdesc Represents a SimulationSyncResponse.
     * @implements ISimulationSyncResponse
     * @constructor
     * @param {ISimulationSyncResponse=} [properties] Properties to set
     */
    function SimulationSyncResponse(properties) {
        this.detection = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SimulationSyncResponse detection.
     * @member {Array.<ISSL_DetectionFrame>} detection
     * @memberof SimulationSyncResponse
     * @instance
     */
    SimulationSyncResponse.prototype.detection = $util.emptyArray;

    /**
     * SimulationSyncResponse robotControlResponse.
     * @member {IRobotControlResponse|null|undefined} robotControlResponse
     * @memberof SimulationSyncResponse
     * @instance
     */
    SimulationSyncResponse.prototype.robotControlResponse = null;

    /**
     * Creates a new SimulationSyncResponse instance using the specified properties.
     * @function create
     * @memberof SimulationSyncResponse
     * @static
     * @param {ISimulationSyncResponse=} [properties] Properties to set
     * @returns {SimulationSyncResponse} SimulationSyncResponse instance
     */
    SimulationSyncResponse.create = function create(properties) {
        return new SimulationSyncResponse(properties);
    };

    /**
     * Encodes the specified SimulationSyncResponse message. Does not implicitly {@link SimulationSyncResponse.verify|verify} messages.
     * @function encode
     * @memberof SimulationSyncResponse
     * @static
     * @param {ISimulationSyncResponse} message SimulationSyncResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulationSyncResponse.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        if (message.detection != null && message.detection.length)
            for (let i = 0; i < message.detection.length; ++i)
                $root.SSL_DetectionFrame.encode(message.detection[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
        if (message.robotControlResponse != null && Object.hasOwnProperty.call(message, "robotControlResponse"))
            $root.RobotControlResponse.encode(message.robotControlResponse, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SimulationSyncResponse message, length delimited. Does not implicitly {@link SimulationSyncResponse.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SimulationSyncResponse
     * @static
     * @param {ISimulationSyncResponse} message SimulationSyncResponse message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SimulationSyncResponse.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SimulationSyncResponse message from the specified reader or buffer.
     * @function decode
     * @memberof SimulationSyncResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SimulationSyncResponse} SimulationSyncResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulationSyncResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SimulationSyncResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    if (!(message.detection && message.detection.length))
                        message.detection = [];
                    message.detection.push($root.SSL_DetectionFrame.decode(reader, reader.uint32()));
                    break;
                }
            case 2: {
                    message.robotControlResponse = $root.RobotControlResponse.decode(reader, reader.uint32());
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        return message;
    };

    /**
     * Decodes a SimulationSyncResponse message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SimulationSyncResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SimulationSyncResponse} SimulationSyncResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SimulationSyncResponse.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SimulationSyncResponse message.
     * @function verify
     * @memberof SimulationSyncResponse
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SimulationSyncResponse.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (message.detection != null && message.hasOwnProperty("detection")) {
            if (!Array.isArray(message.detection))
                return "detection: array expected";
            for (let i = 0; i < message.detection.length; ++i) {
                let error = $root.SSL_DetectionFrame.verify(message.detection[i]);
                if (error)
                    return "detection." + error;
            }
        }
        if (message.robotControlResponse != null && message.hasOwnProperty("robotControlResponse")) {
            let error = $root.RobotControlResponse.verify(message.robotControlResponse);
            if (error)
                return "robotControlResponse." + error;
        }
        return null;
    };

    /**
     * Creates a SimulationSyncResponse message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SimulationSyncResponse
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SimulationSyncResponse} SimulationSyncResponse
     */
    SimulationSyncResponse.fromObject = function fromObject(object) {
        if (object instanceof $root.SimulationSyncResponse)
            return object;
        let message = new $root.SimulationSyncResponse();
        if (object.detection) {
            if (!Array.isArray(object.detection))
                throw TypeError(".SimulationSyncResponse.detection: array expected");
            message.detection = [];
            for (let i = 0; i < object.detection.length; ++i) {
                if (typeof object.detection[i] !== "object")
                    throw TypeError(".SimulationSyncResponse.detection: object expected");
                message.detection[i] = $root.SSL_DetectionFrame.fromObject(object.detection[i]);
            }
        }
        if (object.robotControlResponse != null) {
            if (typeof object.robotControlResponse !== "object")
                throw TypeError(".SimulationSyncResponse.robotControlResponse: object expected");
            message.robotControlResponse = $root.RobotControlResponse.fromObject(object.robotControlResponse);
        }
        return message;
    };

    /**
     * Creates a plain object from a SimulationSyncResponse message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SimulationSyncResponse
     * @static
     * @param {SimulationSyncResponse} message SimulationSyncResponse
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SimulationSyncResponse.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults)
            object.detection = [];
        if (options.defaults)
            object.robotControlResponse = null;
        if (message.detection && message.detection.length) {
            object.detection = [];
            for (let j = 0; j < message.detection.length; ++j)
                object.detection[j] = $root.SSL_DetectionFrame.toObject(message.detection[j], options);
        }
        if (message.robotControlResponse != null && message.hasOwnProperty("robotControlResponse"))
            object.robotControlResponse = $root.RobotControlResponse.toObject(message.robotControlResponse, options);
        return object;
    };

    /**
     * Converts this SimulationSyncResponse to JSON.
     * @function toJSON
     * @memberof SimulationSyncResponse
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SimulationSyncResponse.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SimulationSyncResponse
     * @function getTypeUrl
     * @memberof SimulationSyncResponse
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SimulationSyncResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SimulationSyncResponse";
    };

    return SimulationSyncResponse;
})();

export const SSL_DetectionBall = $root.SSL_DetectionBall = (() => {

    /**
     * Properties of a SSL_DetectionBall.
     * @exports ISSL_DetectionBall
     * @interface ISSL_DetectionBall
     * @property {number} confidence SSL_DetectionBall confidence
     * @property {number|null} [area] SSL_DetectionBall area
     * @property {number} x SSL_DetectionBall x
     * @property {number} y SSL_DetectionBall y
     * @property {number|null} [z] SSL_DetectionBall z
     * @property {number} pixelX SSL_DetectionBall pixelX
     * @property {number} pixelY SSL_DetectionBall pixelY
     */

    /**
     * Constructs a new SSL_DetectionBall.
     * @exports SSL_DetectionBall
     * @classdesc Represents a SSL_DetectionBall.
     * @implements ISSL_DetectionBall
     * @constructor
     * @param {ISSL_DetectionBall=} [properties] Properties to set
     */
    function SSL_DetectionBall(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SSL_DetectionBall confidence.
     * @member {number} confidence
     * @memberof SSL_DetectionBall
     * @instance
     */
    SSL_DetectionBall.prototype.confidence = 0;

    /**
     * SSL_DetectionBall area.
     * @member {number} area
     * @memberof SSL_DetectionBall
     * @instance
     */
    SSL_DetectionBall.prototype.area = 0;

    /**
     * SSL_DetectionBall x.
     * @member {number} x
     * @memberof SSL_DetectionBall
     * @instance
     */
    SSL_DetectionBall.prototype.x = 0;

    /**
     * SSL_DetectionBall y.
     * @member {number} y
     * @memberof SSL_DetectionBall
     * @instance
     */
    SSL_DetectionBall.prototype.y = 0;

    /**
     * SSL_DetectionBall z.
     * @member {number} z
     * @memberof SSL_DetectionBall
     * @instance
     */
    SSL_DetectionBall.prototype.z = 0;

    /**
     * SSL_DetectionBall pixelX.
     * @member {number} pixelX
     * @memberof SSL_DetectionBall
     * @instance
     */
    SSL_DetectionBall.prototype.pixelX = 0;

    /**
     * SSL_DetectionBall pixelY.
     * @member {number} pixelY
     * @memberof SSL_DetectionBall
     * @instance
     */
    SSL_DetectionBall.prototype.pixelY = 0;

    /**
     * Creates a new SSL_DetectionBall instance using the specified properties.
     * @function create
     * @memberof SSL_DetectionBall
     * @static
     * @param {ISSL_DetectionBall=} [properties] Properties to set
     * @returns {SSL_DetectionBall} SSL_DetectionBall instance
     */
    SSL_DetectionBall.create = function create(properties) {
        return new SSL_DetectionBall(properties);
    };

    /**
     * Encodes the specified SSL_DetectionBall message. Does not implicitly {@link SSL_DetectionBall.verify|verify} messages.
     * @function encode
     * @memberof SSL_DetectionBall
     * @static
     * @param {ISSL_DetectionBall} message SSL_DetectionBall message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_DetectionBall.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 5 =*/13).float(message.confidence);
        if (message.area != null && Object.hasOwnProperty.call(message, "area"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.area);
        writer.uint32(/* id 3, wireType 5 =*/29).float(message.x);
        writer.uint32(/* id 4, wireType 5 =*/37).float(message.y);
        if (message.z != null && Object.hasOwnProperty.call(message, "z"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.z);
        writer.uint32(/* id 6, wireType 5 =*/53).float(message.pixelX);
        writer.uint32(/* id 7, wireType 5 =*/61).float(message.pixelY);
        return writer;
    };

    /**
     * Encodes the specified SSL_DetectionBall message, length delimited. Does not implicitly {@link SSL_DetectionBall.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SSL_DetectionBall
     * @static
     * @param {ISSL_DetectionBall} message SSL_DetectionBall message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_DetectionBall.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SSL_DetectionBall message from the specified reader or buffer.
     * @function decode
     * @memberof SSL_DetectionBall
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SSL_DetectionBall} SSL_DetectionBall
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_DetectionBall.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SSL_DetectionBall();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.confidence = reader.float();
                    break;
                }
            case 2: {
                    message.area = reader.uint32();
                    break;
                }
            case 3: {
                    message.x = reader.float();
                    break;
                }
            case 4: {
                    message.y = reader.float();
                    break;
                }
            case 5: {
                    message.z = reader.float();
                    break;
                }
            case 6: {
                    message.pixelX = reader.float();
                    break;
                }
            case 7: {
                    message.pixelY = reader.float();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("confidence"))
            throw $util.ProtocolError("missing required 'confidence'", { instance: message });
        if (!message.hasOwnProperty("x"))
            throw $util.ProtocolError("missing required 'x'", { instance: message });
        if (!message.hasOwnProperty("y"))
            throw $util.ProtocolError("missing required 'y'", { instance: message });
        if (!message.hasOwnProperty("pixelX"))
            throw $util.ProtocolError("missing required 'pixelX'", { instance: message });
        if (!message.hasOwnProperty("pixelY"))
            throw $util.ProtocolError("missing required 'pixelY'", { instance: message });
        return message;
    };

    /**
     * Decodes a SSL_DetectionBall message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SSL_DetectionBall
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SSL_DetectionBall} SSL_DetectionBall
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_DetectionBall.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SSL_DetectionBall message.
     * @function verify
     * @memberof SSL_DetectionBall
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SSL_DetectionBall.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (typeof message.confidence !== "number")
            return "confidence: number expected";
        if (message.area != null && message.hasOwnProperty("area"))
            if (!$util.isInteger(message.area))
                return "area: integer expected";
        if (typeof message.x !== "number")
            return "x: number expected";
        if (typeof message.y !== "number")
            return "y: number expected";
        if (message.z != null && message.hasOwnProperty("z"))
            if (typeof message.z !== "number")
                return "z: number expected";
        if (typeof message.pixelX !== "number")
            return "pixelX: number expected";
        if (typeof message.pixelY !== "number")
            return "pixelY: number expected";
        return null;
    };

    /**
     * Creates a SSL_DetectionBall message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SSL_DetectionBall
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SSL_DetectionBall} SSL_DetectionBall
     */
    SSL_DetectionBall.fromObject = function fromObject(object) {
        if (object instanceof $root.SSL_DetectionBall)
            return object;
        let message = new $root.SSL_DetectionBall();
        if (object.confidence != null)
            message.confidence = Number(object.confidence);
        if (object.area != null)
            message.area = object.area >>> 0;
        if (object.x != null)
            message.x = Number(object.x);
        if (object.y != null)
            message.y = Number(object.y);
        if (object.z != null)
            message.z = Number(object.z);
        if (object.pixelX != null)
            message.pixelX = Number(object.pixelX);
        if (object.pixelY != null)
            message.pixelY = Number(object.pixelY);
        return message;
    };

    /**
     * Creates a plain object from a SSL_DetectionBall message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SSL_DetectionBall
     * @static
     * @param {SSL_DetectionBall} message SSL_DetectionBall
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SSL_DetectionBall.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.confidence = 0;
            object.area = 0;
            object.x = 0;
            object.y = 0;
            object.z = 0;
            object.pixelX = 0;
            object.pixelY = 0;
        }
        if (message.confidence != null && message.hasOwnProperty("confidence"))
            object.confidence = options.json && !isFinite(message.confidence) ? String(message.confidence) : message.confidence;
        if (message.area != null && message.hasOwnProperty("area"))
            object.area = message.area;
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
        if (message.z != null && message.hasOwnProperty("z"))
            object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
        if (message.pixelX != null && message.hasOwnProperty("pixelX"))
            object.pixelX = options.json && !isFinite(message.pixelX) ? String(message.pixelX) : message.pixelX;
        if (message.pixelY != null && message.hasOwnProperty("pixelY"))
            object.pixelY = options.json && !isFinite(message.pixelY) ? String(message.pixelY) : message.pixelY;
        return object;
    };

    /**
     * Converts this SSL_DetectionBall to JSON.
     * @function toJSON
     * @memberof SSL_DetectionBall
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SSL_DetectionBall.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SSL_DetectionBall
     * @function getTypeUrl
     * @memberof SSL_DetectionBall
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SSL_DetectionBall.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SSL_DetectionBall";
    };

    return SSL_DetectionBall;
})();

export const SSL_DetectionRobot = $root.SSL_DetectionRobot = (() => {

    /**
     * Properties of a SSL_DetectionRobot.
     * @exports ISSL_DetectionRobot
     * @interface ISSL_DetectionRobot
     * @property {number} confidence SSL_DetectionRobot confidence
     * @property {number|null} [robotId] SSL_DetectionRobot robotId
     * @property {number} x SSL_DetectionRobot x
     * @property {number} y SSL_DetectionRobot y
     * @property {number|null} [orientation] SSL_DetectionRobot orientation
     * @property {number} pixelX SSL_DetectionRobot pixelX
     * @property {number} pixelY SSL_DetectionRobot pixelY
     * @property {number|null} [height] SSL_DetectionRobot height
     */

    /**
     * Constructs a new SSL_DetectionRobot.
     * @exports SSL_DetectionRobot
     * @classdesc Represents a SSL_DetectionRobot.
     * @implements ISSL_DetectionRobot
     * @constructor
     * @param {ISSL_DetectionRobot=} [properties] Properties to set
     */
    function SSL_DetectionRobot(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SSL_DetectionRobot confidence.
     * @member {number} confidence
     * @memberof SSL_DetectionRobot
     * @instance
     */
    SSL_DetectionRobot.prototype.confidence = 0;

    /**
     * SSL_DetectionRobot robotId.
     * @member {number} robotId
     * @memberof SSL_DetectionRobot
     * @instance
     */
    SSL_DetectionRobot.prototype.robotId = 0;

    /**
     * SSL_DetectionRobot x.
     * @member {number} x
     * @memberof SSL_DetectionRobot
     * @instance
     */
    SSL_DetectionRobot.prototype.x = 0;

    /**
     * SSL_DetectionRobot y.
     * @member {number} y
     * @memberof SSL_DetectionRobot
     * @instance
     */
    SSL_DetectionRobot.prototype.y = 0;

    /**
     * SSL_DetectionRobot orientation.
     * @member {number} orientation
     * @memberof SSL_DetectionRobot
     * @instance
     */
    SSL_DetectionRobot.prototype.orientation = 0;

    /**
     * SSL_DetectionRobot pixelX.
     * @member {number} pixelX
     * @memberof SSL_DetectionRobot
     * @instance
     */
    SSL_DetectionRobot.prototype.pixelX = 0;

    /**
     * SSL_DetectionRobot pixelY.
     * @member {number} pixelY
     * @memberof SSL_DetectionRobot
     * @instance
     */
    SSL_DetectionRobot.prototype.pixelY = 0;

    /**
     * SSL_DetectionRobot height.
     * @member {number} height
     * @memberof SSL_DetectionRobot
     * @instance
     */
    SSL_DetectionRobot.prototype.height = 0;

    /**
     * Creates a new SSL_DetectionRobot instance using the specified properties.
     * @function create
     * @memberof SSL_DetectionRobot
     * @static
     * @param {ISSL_DetectionRobot=} [properties] Properties to set
     * @returns {SSL_DetectionRobot} SSL_DetectionRobot instance
     */
    SSL_DetectionRobot.create = function create(properties) {
        return new SSL_DetectionRobot(properties);
    };

    /**
     * Encodes the specified SSL_DetectionRobot message. Does not implicitly {@link SSL_DetectionRobot.verify|verify} messages.
     * @function encode
     * @memberof SSL_DetectionRobot
     * @static
     * @param {ISSL_DetectionRobot} message SSL_DetectionRobot message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_DetectionRobot.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 5 =*/13).float(message.confidence);
        if (message.robotId != null && Object.hasOwnProperty.call(message, "robotId"))
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.robotId);
        writer.uint32(/* id 3, wireType 5 =*/29).float(message.x);
        writer.uint32(/* id 4, wireType 5 =*/37).float(message.y);
        if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
            writer.uint32(/* id 5, wireType 5 =*/45).float(message.orientation);
        writer.uint32(/* id 6, wireType 5 =*/53).float(message.pixelX);
        writer.uint32(/* id 7, wireType 5 =*/61).float(message.pixelY);
        if (message.height != null && Object.hasOwnProperty.call(message, "height"))
            writer.uint32(/* id 8, wireType 5 =*/69).float(message.height);
        return writer;
    };

    /**
     * Encodes the specified SSL_DetectionRobot message, length delimited. Does not implicitly {@link SSL_DetectionRobot.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SSL_DetectionRobot
     * @static
     * @param {ISSL_DetectionRobot} message SSL_DetectionRobot message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_DetectionRobot.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SSL_DetectionRobot message from the specified reader or buffer.
     * @function decode
     * @memberof SSL_DetectionRobot
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SSL_DetectionRobot} SSL_DetectionRobot
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_DetectionRobot.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SSL_DetectionRobot();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.confidence = reader.float();
                    break;
                }
            case 2: {
                    message.robotId = reader.uint32();
                    break;
                }
            case 3: {
                    message.x = reader.float();
                    break;
                }
            case 4: {
                    message.y = reader.float();
                    break;
                }
            case 5: {
                    message.orientation = reader.float();
                    break;
                }
            case 6: {
                    message.pixelX = reader.float();
                    break;
                }
            case 7: {
                    message.pixelY = reader.float();
                    break;
                }
            case 8: {
                    message.height = reader.float();
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("confidence"))
            throw $util.ProtocolError("missing required 'confidence'", { instance: message });
        if (!message.hasOwnProperty("x"))
            throw $util.ProtocolError("missing required 'x'", { instance: message });
        if (!message.hasOwnProperty("y"))
            throw $util.ProtocolError("missing required 'y'", { instance: message });
        if (!message.hasOwnProperty("pixelX"))
            throw $util.ProtocolError("missing required 'pixelX'", { instance: message });
        if (!message.hasOwnProperty("pixelY"))
            throw $util.ProtocolError("missing required 'pixelY'", { instance: message });
        return message;
    };

    /**
     * Decodes a SSL_DetectionRobot message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SSL_DetectionRobot
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SSL_DetectionRobot} SSL_DetectionRobot
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_DetectionRobot.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SSL_DetectionRobot message.
     * @function verify
     * @memberof SSL_DetectionRobot
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SSL_DetectionRobot.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (typeof message.confidence !== "number")
            return "confidence: number expected";
        if (message.robotId != null && message.hasOwnProperty("robotId"))
            if (!$util.isInteger(message.robotId))
                return "robotId: integer expected";
        if (typeof message.x !== "number")
            return "x: number expected";
        if (typeof message.y !== "number")
            return "y: number expected";
        if (message.orientation != null && message.hasOwnProperty("orientation"))
            if (typeof message.orientation !== "number")
                return "orientation: number expected";
        if (typeof message.pixelX !== "number")
            return "pixelX: number expected";
        if (typeof message.pixelY !== "number")
            return "pixelY: number expected";
        if (message.height != null && message.hasOwnProperty("height"))
            if (typeof message.height !== "number")
                return "height: number expected";
        return null;
    };

    /**
     * Creates a SSL_DetectionRobot message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SSL_DetectionRobot
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SSL_DetectionRobot} SSL_DetectionRobot
     */
    SSL_DetectionRobot.fromObject = function fromObject(object) {
        if (object instanceof $root.SSL_DetectionRobot)
            return object;
        let message = new $root.SSL_DetectionRobot();
        if (object.confidence != null)
            message.confidence = Number(object.confidence);
        if (object.robotId != null)
            message.robotId = object.robotId >>> 0;
        if (object.x != null)
            message.x = Number(object.x);
        if (object.y != null)
            message.y = Number(object.y);
        if (object.orientation != null)
            message.orientation = Number(object.orientation);
        if (object.pixelX != null)
            message.pixelX = Number(object.pixelX);
        if (object.pixelY != null)
            message.pixelY = Number(object.pixelY);
        if (object.height != null)
            message.height = Number(object.height);
        return message;
    };

    /**
     * Creates a plain object from a SSL_DetectionRobot message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SSL_DetectionRobot
     * @static
     * @param {SSL_DetectionRobot} message SSL_DetectionRobot
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SSL_DetectionRobot.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.defaults) {
            object.confidence = 0;
            object.robotId = 0;
            object.x = 0;
            object.y = 0;
            object.orientation = 0;
            object.pixelX = 0;
            object.pixelY = 0;
            object.height = 0;
        }
        if (message.confidence != null && message.hasOwnProperty("confidence"))
            object.confidence = options.json && !isFinite(message.confidence) ? String(message.confidence) : message.confidence;
        if (message.robotId != null && message.hasOwnProperty("robotId"))
            object.robotId = message.robotId;
        if (message.x != null && message.hasOwnProperty("x"))
            object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
        if (message.y != null && message.hasOwnProperty("y"))
            object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
        if (message.orientation != null && message.hasOwnProperty("orientation"))
            object.orientation = options.json && !isFinite(message.orientation) ? String(message.orientation) : message.orientation;
        if (message.pixelX != null && message.hasOwnProperty("pixelX"))
            object.pixelX = options.json && !isFinite(message.pixelX) ? String(message.pixelX) : message.pixelX;
        if (message.pixelY != null && message.hasOwnProperty("pixelY"))
            object.pixelY = options.json && !isFinite(message.pixelY) ? String(message.pixelY) : message.pixelY;
        if (message.height != null && message.hasOwnProperty("height"))
            object.height = options.json && !isFinite(message.height) ? String(message.height) : message.height;
        return object;
    };

    /**
     * Converts this SSL_DetectionRobot to JSON.
     * @function toJSON
     * @memberof SSL_DetectionRobot
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SSL_DetectionRobot.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SSL_DetectionRobot
     * @function getTypeUrl
     * @memberof SSL_DetectionRobot
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SSL_DetectionRobot.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SSL_DetectionRobot";
    };

    return SSL_DetectionRobot;
})();

export const SSL_DetectionFrame = $root.SSL_DetectionFrame = (() => {

    /**
     * Properties of a SSL_DetectionFrame.
     * @exports ISSL_DetectionFrame
     * @interface ISSL_DetectionFrame
     * @property {number} frameNumber SSL_DetectionFrame frameNumber
     * @property {number} tCapture SSL_DetectionFrame tCapture
     * @property {number} tSent SSL_DetectionFrame tSent
     * @property {number} cameraId SSL_DetectionFrame cameraId
     * @property {Array.<ISSL_DetectionBall>|null} [balls] SSL_DetectionFrame balls
     * @property {Array.<ISSL_DetectionRobot>|null} [robotsYellow] SSL_DetectionFrame robotsYellow
     * @property {Array.<ISSL_DetectionRobot>|null} [robotsBlue] SSL_DetectionFrame robotsBlue
     */

    /**
     * Constructs a new SSL_DetectionFrame.
     * @exports SSL_DetectionFrame
     * @classdesc Represents a SSL_DetectionFrame.
     * @implements ISSL_DetectionFrame
     * @constructor
     * @param {ISSL_DetectionFrame=} [properties] Properties to set
     */
    function SSL_DetectionFrame(properties) {
        this.balls = [];
        this.robotsYellow = [];
        this.robotsBlue = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }

    /**
     * SSL_DetectionFrame frameNumber.
     * @member {number} frameNumber
     * @memberof SSL_DetectionFrame
     * @instance
     */
    SSL_DetectionFrame.prototype.frameNumber = 0;

    /**
     * SSL_DetectionFrame tCapture.
     * @member {number} tCapture
     * @memberof SSL_DetectionFrame
     * @instance
     */
    SSL_DetectionFrame.prototype.tCapture = 0;

    /**
     * SSL_DetectionFrame tSent.
     * @member {number} tSent
     * @memberof SSL_DetectionFrame
     * @instance
     */
    SSL_DetectionFrame.prototype.tSent = 0;

    /**
     * SSL_DetectionFrame cameraId.
     * @member {number} cameraId
     * @memberof SSL_DetectionFrame
     * @instance
     */
    SSL_DetectionFrame.prototype.cameraId = 0;

    /**
     * SSL_DetectionFrame balls.
     * @member {Array.<ISSL_DetectionBall>} balls
     * @memberof SSL_DetectionFrame
     * @instance
     */
    SSL_DetectionFrame.prototype.balls = $util.emptyArray;

    /**
     * SSL_DetectionFrame robotsYellow.
     * @member {Array.<ISSL_DetectionRobot>} robotsYellow
     * @memberof SSL_DetectionFrame
     * @instance
     */
    SSL_DetectionFrame.prototype.robotsYellow = $util.emptyArray;

    /**
     * SSL_DetectionFrame robotsBlue.
     * @member {Array.<ISSL_DetectionRobot>} robotsBlue
     * @memberof SSL_DetectionFrame
     * @instance
     */
    SSL_DetectionFrame.prototype.robotsBlue = $util.emptyArray;

    /**
     * Creates a new SSL_DetectionFrame instance using the specified properties.
     * @function create
     * @memberof SSL_DetectionFrame
     * @static
     * @param {ISSL_DetectionFrame=} [properties] Properties to set
     * @returns {SSL_DetectionFrame} SSL_DetectionFrame instance
     */
    SSL_DetectionFrame.create = function create(properties) {
        return new SSL_DetectionFrame(properties);
    };

    /**
     * Encodes the specified SSL_DetectionFrame message. Does not implicitly {@link SSL_DetectionFrame.verify|verify} messages.
     * @function encode
     * @memberof SSL_DetectionFrame
     * @static
     * @param {ISSL_DetectionFrame} message SSL_DetectionFrame message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_DetectionFrame.encode = function encode(message, writer) {
        if (!writer)
            writer = $Writer.create();
        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.frameNumber);
        writer.uint32(/* id 2, wireType 1 =*/17).double(message.tCapture);
        writer.uint32(/* id 3, wireType 1 =*/25).double(message.tSent);
        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.cameraId);
        if (message.balls != null && message.balls.length)
            for (let i = 0; i < message.balls.length; ++i)
                $root.SSL_DetectionBall.encode(message.balls[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
        if (message.robotsYellow != null && message.robotsYellow.length)
            for (let i = 0; i < message.robotsYellow.length; ++i)
                $root.SSL_DetectionRobot.encode(message.robotsYellow[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
        if (message.robotsBlue != null && message.robotsBlue.length)
            for (let i = 0; i < message.robotsBlue.length; ++i)
                $root.SSL_DetectionRobot.encode(message.robotsBlue[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
        return writer;
    };

    /**
     * Encodes the specified SSL_DetectionFrame message, length delimited. Does not implicitly {@link SSL_DetectionFrame.verify|verify} messages.
     * @function encodeDelimited
     * @memberof SSL_DetectionFrame
     * @static
     * @param {ISSL_DetectionFrame} message SSL_DetectionFrame message or plain object to encode
     * @param {$protobuf.Writer} [writer] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */
    SSL_DetectionFrame.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
    };

    /**
     * Decodes a SSL_DetectionFrame message from the specified reader or buffer.
     * @function decode
     * @memberof SSL_DetectionFrame
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {SSL_DetectionFrame} SSL_DetectionFrame
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_DetectionFrame.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.SSL_DetectionFrame();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
            case 1: {
                    message.frameNumber = reader.uint32();
                    break;
                }
            case 2: {
                    message.tCapture = reader.double();
                    break;
                }
            case 3: {
                    message.tSent = reader.double();
                    break;
                }
            case 4: {
                    message.cameraId = reader.uint32();
                    break;
                }
            case 5: {
                    if (!(message.balls && message.balls.length))
                        message.balls = [];
                    message.balls.push($root.SSL_DetectionBall.decode(reader, reader.uint32()));
                    break;
                }
            case 6: {
                    if (!(message.robotsYellow && message.robotsYellow.length))
                        message.robotsYellow = [];
                    message.robotsYellow.push($root.SSL_DetectionRobot.decode(reader, reader.uint32()));
                    break;
                }
            case 7: {
                    if (!(message.robotsBlue && message.robotsBlue.length))
                        message.robotsBlue = [];
                    message.robotsBlue.push($root.SSL_DetectionRobot.decode(reader, reader.uint32()));
                    break;
                }
            default:
                reader.skipType(tag & 7);
                break;
            }
        }
        if (!message.hasOwnProperty("frameNumber"))
            throw $util.ProtocolError("missing required 'frameNumber'", { instance: message });
        if (!message.hasOwnProperty("tCapture"))
            throw $util.ProtocolError("missing required 'tCapture'", { instance: message });
        if (!message.hasOwnProperty("tSent"))
            throw $util.ProtocolError("missing required 'tSent'", { instance: message });
        if (!message.hasOwnProperty("cameraId"))
            throw $util.ProtocolError("missing required 'cameraId'", { instance: message });
        return message;
    };

    /**
     * Decodes a SSL_DetectionFrame message from the specified reader or buffer, length delimited.
     * @function decodeDelimited
     * @memberof SSL_DetectionFrame
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @returns {SSL_DetectionFrame} SSL_DetectionFrame
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    SSL_DetectionFrame.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
    };

    /**
     * Verifies a SSL_DetectionFrame message.
     * @function verify
     * @memberof SSL_DetectionFrame
     * @static
     * @param {Object.<string,*>} message Plain object to verify
     * @returns {string|null} `null` if valid, otherwise the reason why it is not
     */
    SSL_DetectionFrame.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
            return "object expected";
        if (!$util.isInteger(message.frameNumber))
            return "frameNumber: integer expected";
        if (typeof message.tCapture !== "number")
            return "tCapture: number expected";
        if (typeof message.tSent !== "number")
            return "tSent: number expected";
        if (!$util.isInteger(message.cameraId))
            return "cameraId: integer expected";
        if (message.balls != null && message.hasOwnProperty("balls")) {
            if (!Array.isArray(message.balls))
                return "balls: array expected";
            for (let i = 0; i < message.balls.length; ++i) {
                let error = $root.SSL_DetectionBall.verify(message.balls[i]);
                if (error)
                    return "balls." + error;
            }
        }
        if (message.robotsYellow != null && message.hasOwnProperty("robotsYellow")) {
            if (!Array.isArray(message.robotsYellow))
                return "robotsYellow: array expected";
            for (let i = 0; i < message.robotsYellow.length; ++i) {
                let error = $root.SSL_DetectionRobot.verify(message.robotsYellow[i]);
                if (error)
                    return "robotsYellow." + error;
            }
        }
        if (message.robotsBlue != null && message.hasOwnProperty("robotsBlue")) {
            if (!Array.isArray(message.robotsBlue))
                return "robotsBlue: array expected";
            for (let i = 0; i < message.robotsBlue.length; ++i) {
                let error = $root.SSL_DetectionRobot.verify(message.robotsBlue[i]);
                if (error)
                    return "robotsBlue." + error;
            }
        }
        return null;
    };

    /**
     * Creates a SSL_DetectionFrame message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof SSL_DetectionFrame
     * @static
     * @param {Object.<string,*>} object Plain object
     * @returns {SSL_DetectionFrame} SSL_DetectionFrame
     */
    SSL_DetectionFrame.fromObject = function fromObject(object) {
        if (object instanceof $root.SSL_DetectionFrame)
            return object;
        let message = new $root.SSL_DetectionFrame();
        if (object.frameNumber != null)
            message.frameNumber = object.frameNumber >>> 0;
        if (object.tCapture != null)
            message.tCapture = Number(object.tCapture);
        if (object.tSent != null)
            message.tSent = Number(object.tSent);
        if (object.cameraId != null)
            message.cameraId = object.cameraId >>> 0;
        if (object.balls) {
            if (!Array.isArray(object.balls))
                throw TypeError(".SSL_DetectionFrame.balls: array expected");
            message.balls = [];
            for (let i = 0; i < object.balls.length; ++i) {
                if (typeof object.balls[i] !== "object")
                    throw TypeError(".SSL_DetectionFrame.balls: object expected");
                message.balls[i] = $root.SSL_DetectionBall.fromObject(object.balls[i]);
            }
        }
        if (object.robotsYellow) {
            if (!Array.isArray(object.robotsYellow))
                throw TypeError(".SSL_DetectionFrame.robotsYellow: array expected");
            message.robotsYellow = [];
            for (let i = 0; i < object.robotsYellow.length; ++i) {
                if (typeof object.robotsYellow[i] !== "object")
                    throw TypeError(".SSL_DetectionFrame.robotsYellow: object expected");
                message.robotsYellow[i] = $root.SSL_DetectionRobot.fromObject(object.robotsYellow[i]);
            }
        }
        if (object.robotsBlue) {
            if (!Array.isArray(object.robotsBlue))
                throw TypeError(".SSL_DetectionFrame.robotsBlue: array expected");
            message.robotsBlue = [];
            for (let i = 0; i < object.robotsBlue.length; ++i) {
                if (typeof object.robotsBlue[i] !== "object")
                    throw TypeError(".SSL_DetectionFrame.robotsBlue: object expected");
                message.robotsBlue[i] = $root.SSL_DetectionRobot.fromObject(object.robotsBlue[i]);
            }
        }
        return message;
    };

    /**
     * Creates a plain object from a SSL_DetectionFrame message. Also converts values to other types if specified.
     * @function toObject
     * @memberof SSL_DetectionFrame
     * @static
     * @param {SSL_DetectionFrame} message SSL_DetectionFrame
     * @param {$protobuf.IConversionOptions} [options] Conversion options
     * @returns {Object.<string,*>} Plain object
     */
    SSL_DetectionFrame.toObject = function toObject(message, options) {
        if (!options)
            options = {};
        let object = {};
        if (options.arrays || options.defaults) {
            object.balls = [];
            object.robotsYellow = [];
            object.robotsBlue = [];
        }
        if (options.defaults) {
            object.frameNumber = 0;
            object.tCapture = 0;
            object.tSent = 0;
            object.cameraId = 0;
        }
        if (message.frameNumber != null && message.hasOwnProperty("frameNumber"))
            object.frameNumber = message.frameNumber;
        if (message.tCapture != null && message.hasOwnProperty("tCapture"))
            object.tCapture = options.json && !isFinite(message.tCapture) ? String(message.tCapture) : message.tCapture;
        if (message.tSent != null && message.hasOwnProperty("tSent"))
            object.tSent = options.json && !isFinite(message.tSent) ? String(message.tSent) : message.tSent;
        if (message.cameraId != null && message.hasOwnProperty("cameraId"))
            object.cameraId = message.cameraId;
        if (message.balls && message.balls.length) {
            object.balls = [];
            for (let j = 0; j < message.balls.length; ++j)
                object.balls[j] = $root.SSL_DetectionBall.toObject(message.balls[j], options);
        }
        if (message.robotsYellow && message.robotsYellow.length) {
            object.robotsYellow = [];
            for (let j = 0; j < message.robotsYellow.length; ++j)
                object.robotsYellow[j] = $root.SSL_DetectionRobot.toObject(message.robotsYellow[j], options);
        }
        if (message.robotsBlue && message.robotsBlue.length) {
            object.robotsBlue = [];
            for (let j = 0; j < message.robotsBlue.length; ++j)
                object.robotsBlue[j] = $root.SSL_DetectionRobot.toObject(message.robotsBlue[j], options);
        }
        return object;
    };

    /**
     * Converts this SSL_DetectionFrame to JSON.
     * @function toJSON
     * @memberof SSL_DetectionFrame
     * @instance
     * @returns {Object.<string,*>} JSON object
     */
    SSL_DetectionFrame.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };

    /**
     * Gets the default type url for SSL_DetectionFrame
     * @function getTypeUrl
     * @memberof SSL_DetectionFrame
     * @static
     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
     * @returns {string} The default type url
     */
    SSL_DetectionFrame.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
            typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/SSL_DetectionFrame";
    };

    return SSL_DetectionFrame;
})();

export { $root as default };
