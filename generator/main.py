from datetime import datetime
import shutil
import math

import generators as g
from packets import packets

for packetName in packets.keys():

	filename = "%s.h" % packetName
	file = open("generated/" + filename, "w")

	timestamp = datetime.now()

	file.write("// AUTOGENERATED. Run generator/main.py to regenerate\n")
	file.write("// Generated on %s\n\n" % timestamp.strftime("%B %d %Y, %H:%M:%S"))
	
	file.write("#ifndef %s\n" % g.toHeaderGuard(packetName))
	file.write("#define %s\n" % g.toHeaderGuard(packetName))
	file.write("\n")
	file.write("#include <stdbool.h>\n")
	file.write("#include <stdint.h>\n")
	file.write("#include \"BaseTypes.h\"\n")
	file.write("\n")
	file.write("%s\n" % g.toStructPayload(packetName))
	
	file.write("\n\n\n/** ================================ PACKET ================================ \n")
	file.write(g.toStructure(packetName, packets[packetName]))
	file.write("\n*/")
	file.write("\n")
	
	file.write("\n\n\n/** ================================ STRUCT ================================ */\n")
	file.write(g.toStruct(packetName, packets[packetName]))
	file.write("\n")

	file.write("\n\n\n/** ================================ GETTERS ================================ */\n")
	file.write("%s\n" % g.toGetters(packetName, packets))

	file.write("\n\n/** ================================ SETTERS ================================ */\n")
	file.write("%s\n" % g.toSetters(packetName, packets))

	file.write("\n\n/** ================================ DECODE ================================ */\n")
	file.write(g.toDecode(packetName, packets[packetName]))
	file.write("\n")

	file.write("\n\n\n/** ================================ ENCODE ================================ */\n")
	file.write(g.toEncode(packetName, packets[packetName]))
	file.write("\n")
	file.write("\n")
	file.write("#endif /*%s*/\n" % g.toHeaderGuard(packetName))

	file.close()

	shutil.copy("generated/%s" % filename, "../include/%s" % filename)
	print("Generated file %s" % filename)


############### Generate BaseTypes.h ###############
# Set of codewords with hamming distance 4. CRC in the SX1280 should already catch bit errors, buuuuut just to be sure
# Don't want a robot to go haywire because it interpreted another message as a RobotCommand
# Table taken from this paper : "The VFAT3-Comm-Port: a complete communication port for front-end ASICs intended for use within the high luminosity radiation environments of the LHC"
# I have no idea what that title means. It's complete gibberish. But whatever, it has nice codeword tables

# Warning : Check the unicode table before assigning a byte, to make sure that the byte isn't used for anything special : https://unicode-table.com/
# For example, don't use the following bytes
#      0b00000000 : The null-terminator, used to signal the end of strings / arrays / etc.
#      0b00001010 : The byte for newline, used for line termination.

codewords = [
	              "0b00001111", "0b00110011", "0b00111100",
	"0b01010101", "0b01011010", "0b01100110", "0b01101001",
	"0b10010110", "0b10011001", "0b10100101", "0b10101010",
	"0b11000011", "0b11001100", "0b11110000", "0b11111111"
]

if len(codewords) < len(packets.keys()):
	print("[Error] More packets than codewords. Add more codewords. Remove packets! DO SOMETHING!!!")
	print("[Error] If you're really desparate and in a hurry, then paste the array below.")
	print("[Error] But these are not good codewords!! Might as well have no codewords.")
	codewords = ["0b" + "{0:b}".format(20 + i*5).zfill(8) for i in range(len(packets))]
	print(codewords)
	exit()



filename = "BaseTypes.h"
file = open("generated/" + filename, "w")
timestamp = datetime.now()

file.write("// AUTOGENERATED. Run generator/main.py to regenerate\n")
file.write("// Generated on %s\n\n" % timestamp.strftime("%B %d %Y, %H:%M:%S"))

file.write("#ifndef __BASETYPES_H\n")
file.write("#define __BASETYPES_H\n")
file.write("\n")

file.write("// Warning : Check the unicode table before assigning a byte, to make sure that the byte isn't used for anything special : https://unicode-table.com/\n")
file.write("// For example, don't use the following bytes\n")
file.write("// 0b00000000 : The null-terminator, used to signal the end of strings / arrays / etc.\n")
file.write("// 0b00001010 : The byte for newline, used for line termination.\n")
file.write("\n")

packet_sizes = []
packet_types = []
for iPacket, packetName in enumerate(packets.keys()):
	variables = packets[packetName]
	total_bits = sum([variable[1] for variable in variables])
	total_bytes = math.ceil(total_bits / 8)
	
	packet_type = ("\tPACKET_TYPE" + g.CamelCaseToUpper(packetName)).ljust(30) + " = " + codewords[iPacket]
	packet_size = ("\tPACKET_SIZE" + g.CamelCaseToUpper(packetName)).ljust(30) + " = " + str(total_bytes)
	packet_types.append(packet_type)
	packet_sizes.append(packet_size)

file.write("typedef enum _PACKET_TYPE {\n")
file.write(",\n".join(packet_types) + "\n")
file.write("} PACKET_TYPE;\n")
file.write("\n")
file.write("typedef enum _PACKET_SIZE {\n")
file.write(",\n".join(packet_sizes) + "\n")
file.write("} PACKET_SIZE;\n")
file.write("\n")
file.write("# endif /*__BASETYPES_H*/")
file.write("\n")

file.close()

shutil.copy("generated/%s" % filename, "../include/%s" % filename)
print("Generated file BaseTypes.h")
